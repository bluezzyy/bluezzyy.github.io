<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OkHttp4.3源码解析之 - 重试和重定向]]></title>
    <url>%2Farticles%2Fokhttp_source_code_retry_redirect.html</url>
    <content type="text"><![CDATA[OkHttp4.3源码解析之 - 重试和重定向回顾上一篇文章：发起请求 大家还记得OkHttp是如何发起一条请求的吗？上面这篇文章里介绍了OkHttp是在什么时候把多个拦截器加入到责任链中的。如果大家没看过的可以先去了解一下，因为这个流程和本文息息相关。 如果是忘了的话我们再简单的回顾一遍： 构建OkHttpClient对象 构建Request对象 使用enqueue()发起请求，并处理回调 在第一步里，我们可以通过addInterceptor(xxx)来添加自定义的拦截器，在第三步里，我们通过源码可以看到在RealCall中通过getResponseWithInterceptorChain()方法来处理这些拦截器。 一个简单的例子现在有个需求，希望每个请求都能把请求时间给打印出来，该怎么做呢？ OkHttpTest类 123456789101112131415161718192021class OkHttpTest &#123; internal fun test() &#123; Request.Builder() .url("https://www.baidu.com").build().let &#123; request -&gt; OkHttpClient.Builder() .addInterceptor(LoggingInterceptor()) // 添加自定义的拦截器 .build() .newCall(request).enqueue(object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println("bluelzy --- $&#123;e.message&#125;") &#125; override fun onResponse(call: Call, response: Response) &#123; println("bluelzy --- $&#123;response.body.toString()&#125;") &#125; &#125;) &#125; &#125;&#125; LoggingInterceptor 123456789101112131415161718class LoggingInterceptor : Interceptor &#123; override fun intercept(chain: Interceptor.Chain): Response &#123; val request = chain.request() val startTime = System.nanoTime() logger.info(String.format("Bluelzy --- Sending request %s", request.url) val response = chain.proceed(request) val endTime = System.nanoTime() logger.info(String.format("Bluelzy --- Received response from %s in %.1fms%n%s", response.request.url, (endTime-startTime)/1e6, response.headers)) return response &#125;&#125; 运行程序然后打开Logcat 1234567891011com.bluelzy.kotlinlearning I/TaskRunner: Bluelzy --- Sending request https://www.baidu.com/ com.bluelzy.kotlinlearning I/TaskRunner: Bluelzy --- Received response for https://www.baidu.com/ in 172.9ms Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: keep-alive Content-Type: text/html Date: Sat, 15 Feb 2020 12:41:37 GMT Last-Modified: Mon, 23 Jan 2017 13:24:32 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ Transfer-Encoding: chunked 可以看到这里把我们需要的信息都打印出来了。 思考一下： 这个logger拦截器是怎么添加到OkHttp的呢？ OkHttp如何运用责任链模式进行多个不同网络层之间的责任划分？ 我们在实际开发中还能运用责任链模式做其他什么操作吗？ OkHttp中的责任链模式自定义的拦截器是如何添加到OkHttp中的？还记得上一篇文章说的吗，我们构建一个OkHttpClient对象，使用的就是Builder模式，通过addInterceptor(interceptor: Interceptor) 这个方法，把拦截器加入到队列中，这个拦截器队列就是OkHttpClient中的一个全局变量，不仅用于存放我们自定义的拦截器，也用于存放OkHttp默认实现的拦截器。 123fun addInterceptor(interceptor: Interceptor) = apply &#123; interceptors += interceptor&#125; OkHttp的责任链模式是如何起作用的？我们看RealCall里的这段代码： 12345678910111213141516@Throws(IOException::class) fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) // 省略代码 &#125; 这里做了几件事： 把OkHttpClient里面的Interceptor加入到列表中 把默认的几个Interceptor加入到列表中 判断是不是Socket请求，不是的话把networkInterceptor加入到列表中 最后加入CallServerInterceptor，这个拦截器是用来向服务器发起请求的，因此要加在最后 RetryAndFollowUpInterceptor大家如果看了上一篇文章的话，应该还记得真正处理责任链的是RetryAndFollowUpInterceptor.proceed()方法，通过index取出对应的拦截器并执行interceptor.intercept() 方法。而无论是我们自定义的Interceptor，还是OkHttp中默认实现的，都会继承Interceptor这个接口，因此都会实现intercept()方法。 接下来，我们来看看RetryAndFollowUpInterceptor里面做了什么？ 12345&gt; This interceptor recovers from failures and follows redirects as necessary. It may throw an [IOException] if the call was canceled.&gt; &gt; 这个拦截器主要是请求失败时尝试恢复连接，还有处理重定向的问题。&gt; 如果请求被取消了，可能会抛出IOException异常&gt; 既然主要是处理这两个问题，那么我们就重点关注看看，这个拦截器是如何处理的。 失败时尝试重连123456789101112131415161718192021222324252627282930313233343536373839@Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response &#123; var request = chain.request() val realChain = chain as RealInterceptorChain val transmitter = realChain.transmitter() var followUpCount = 0 var priorResponse: Response? = null while (true) &#123; transmitter.prepareToConnect(request) // 创建Stream if (transmitter.isCanceled) &#123; throw IOException("Canceled") // 请求被取消时抛出异常 &#125; var response: Response var success = false try &#123; response = realChain.proceed(request, transmitter, null) success = true &#125; catch (e: RouteException) &#123; // 路由异常，调用recover() if (!recover(e.lastConnectException, transmitter, false, request)) &#123; throw e.firstConnectException &#125; continue &#125; catch (e: IOException) &#123; // 服务端异常，调用recover() val requestSendStarted = e !is ConnectionShutdownException if (!recover(e, transmitter, requestSendStarted, request)) throw e continue &#125; finally &#123; // The network call threw an exception. Release any resources. if (!success) &#123; transmitter.exchangeDoneDueToException() &#125; &#125; // 省略代码 &#125; &#125; 在发起请求的时候，如果出现了异常，根据不同异常会调用recover()方法，我们看看这个方法做了什么 1234567891011121314151617181920private fun recover( e: IOException, transmitter: Transmitter, requestSendStarted: Boolean, userRequest: Request): Boolean &#123; // 判断客户端是否禁止重连，是的话直接返回false if (!client.retryOnConnectionFailure) return false // 如果已经发送了请求，那么也直接返回false if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false // 如果是Fatal类异常，返回false if (!isRecoverable(e, requestSendStarted)) return false // 如果没有其他路由可以尝试重连，返回false if (!transmitter.canRetry()) return false return true&#125; 如果我们在OkHttpClient设置了不能重连，game over 这个重连只能发生在连接失败的时候，如果是请求已经发送了，game over 如果这个异常是协议相关的问题，那么同样game over OkHttp会在连接池里面尝试不同的IP，如果没有其他可用的IP，game over 如果这个异常是在连接的时候发生的，而且还有可用的IP，我们也设置了可以重试（默认为true），那么就会再构造一个Request，用于重试。 这里OkHttp用了一个很巧妙的方法来实现，那就是递归。 首先在intercept()方法开头加入了while(true)，只要没有return或者throw excpetion，就会一直执行下去 1response = realChain.proceed(request, transmitter, null) 通过上面这一句代码，每次构建一个Request，然后调用proceed进行请求 每一个请求的结果都会返回到上一个Response中 每次请求完毕followUpCount 加一，在OkHttp中，这个参数用于控制请求最大数，默认是20，一旦超过这个数，也会抛出异常 如何进行重定向重定向和重试其实都在intercept()方法中，主要是这句代码： 1val followUp = followUpRequest(response, route) followUpRequeset(): 123456789101112131415161718192021222324252627282930313233343536@Throws(IOException::class)private fun followUpRequest(userResponse: Response, route: Route?): Request? &#123; val responseCode = userResponse.code val method = userResponse.request.method when (responseCode) &#123; HTTP_PROXY_AUTH -&gt; &#123; // 省略代码 // 1.重定向 (307, 308) HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123; if (method != "GET" &amp;&amp; method != "HEAD") &#123; return null &#125; return buildRedirectRequest(userResponse, method) &#125; // 2.重定向（300,301,302,303） HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123; return buildRedirectRequest(userResponse, method) &#125; HTTP_CLIENT_TIMEOUT -&gt; &#123; // 省略代码 return userResponse.request &#125; HTTP_UNAVAILABLE -&gt; &#123; // 省略代码 return null &#125; else -&gt; return null &#125;&#125; 可以看到，这里通过判断responseCode来进行不同的处理，我们重点关注重定向，看看buildRedirectRequest()方法： 1234567891011121314151617181920212223242526272829303132333435363738private fun buildRedirectRequest(userResponse: Response, method: String): Request? &#123; // 1.客户端是否支持重定向 if (!client.followRedirects) return null val location = userResponse.header("Location") ?: return null // 2.是不是http/https协议，不是的话抛异常，返回null val url = userResponse.request.url.resolve(location) ?: return null // 3.是否支持Ssl重定向 val sameScheme = url.scheme == userResponse.request.url.scheme if (!sameScheme &amp;&amp; !client.followSslRedirects) return null // 4.构建请求体 val requestBuilder = userResponse.request.newBuilder() if (HttpMethod.permitsRequestBody(method)) &#123; val maintainBody = HttpMethod.redirectsWithBody(method) if (HttpMethod.redirectsToGet(method)) &#123; requestBuilder.method("GET", null) &#125; else &#123; val requestBody = if (maintainBody) userResponse.request.body else null requestBuilder.method(method, requestBody) &#125; if (!maintainBody) &#123; requestBuilder.removeHeader("Transfer-Encoding") requestBuilder.removeHeader("Content-Length") requestBuilder.removeHeader("Content-Type") &#125; &#125; // When redirecting across hosts, drop all authentication headers. This // is potentially annoying to the application layer since they have no // way to retain them. if (!userResponse.request.url.canReuseConnectionFor(url)) &#123; requestBuilder.removeHeader("Authorization") &#125; return requestBuilder.url(url).build()&#125; 这里就是一个很标准的Builder模式的应用了，通过request.newBuilder()和后续的builder.xxx()构建一个Request.Builder对象。最终调用build()方法返回Request对象。 总结在RetryAndFollowUpInterceptor中，主要做了两件事 重试 重定向 这两者都是通过followUpRequest()方法来构建一个新的Request，然后递归调用proceed()方法进行请求。中间有很多的错误/异常判断，一旦条件不满足就会停止请求并且释放资源。 我们在实际工作中如何使用？例如，我们现在不想使用OkHttp默认的重试拦截器，希望自己定义重试次数，那么可以这样写： RetryInterceptor: 1234567891011121314151617181920/** * author : BlueLzy * e-mail : bluehobert@gmail.com * date : 2020/02/16 16:07 * desc : 重试拦截器 */class RetryInterceptor(private val maxRetryCount: Int = 2) : Interceptor &#123; private var retryNum = 0 override fun intercept(chain: Interceptor.Chain): Response = chain.proceed(chain.request()).apply &#123; while (!isSuccessful &amp;&amp; retryNum &lt; maxRetryCount) &#123; retryNum++ logger.info("BlueLzy --- 重试次数：$retryNum") chain.proceed(request) &#125; &#125;&#125; 为了能测试重试拦截器，我们定义一个测试请求，每次返回400 TestInterceptor: 12345678910111213141516171819202122232425/** * author : BlueLzy * e-mail : bluehobert@gmail.com * date : 2020/02/16 16:18 * desc : */class TestInterceptor : Interceptor &#123; override fun intercept(chain: Interceptor.Chain): Response &#123; val request = chain.request() return if (request.url.toString() == TEST_URL) &#123; val responseString = "我是响应数据" Response.Builder() .code(400) .request(request) .protocol(Protocol.HTTP_1_1) .message(responseString) .body(responseString.toResponseBody("application/json".toMediaTypeOrNull())) .addHeader("content-type", "application/json") .build() &#125; else &#123; chain.proceed(request) &#125; &#125;&#125; 最后发起请求 OkHttpTest: 123456789101112131415161718192021222324252627class OkHttpTest &#123; internal fun test() &#123; Request.Builder() .url(TEST_URL).build().let &#123; request -&gt; OkHttpClient.Builder() .addInterceptor(RetryInterceptor()) // 添加重试拦截器，默认重试次数为2 .addInterceptor(TestInterceptor()) // 添加测试请求 .build() .newCall(request).enqueue(object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println("BlueLzy --- $&#123;e.message&#125;") &#125; override fun onResponse(call: Call, response: Response) &#123; println("BlueLzy --- $&#123;response.message&#125;") &#125; &#125;) &#125; &#125; companion object &#123; const val TEST_URL = "https://www.baidu.com/" &#125;&#125; 我们可以看到logcat打印出来的信息： 1234562020-02-16 16:46:29.338 1914-2113/com.bluelzy.kotlinlearning I/TaskRunner: BlueLzy --- Sending request https://www.baidu.com/2020-02-16 16:46:29.338 1914-2113/com.bluelzy.kotlinlearning I/TaskRunner: BlueLzy --- 重试次数：12020-02-16 16:46:29.339 1914-2113/com.bluelzy.kotlinlearning I/TaskRunner: BlueLzy --- 重试次数：22020-02-16 16:46:29.339 1914-2113/com.bluelzy.kotlinlearning I/TaskRunner: BlueLzy --- Received response for https://www.baidu.com/ in 1.0ms content-type: application/json2020-02-16 16:46:29.339 1914-2113/com.bluelzy.kotlinlearning I/System.out: BlueLzy --- 我是响应数据 发起了1次默认请求+2次重试的请求 = 3次请求。这样就实现了自由控制重试次数的需求了，当然我们也可以在每次重试中做其他的操作，例如更改请求头和请求体。 总结本文我们主要说了OkHttp中的重试机制和重定向，分析了RetryAndFollowUpinterceptor的源码。最后举了个在实际工作中应用的小例子。 下一篇我们说一下OkHttp中的缓存机制 - CacheInterceptor 如有不对之处，欢迎大家多多交流。感谢阅读！]]></content>
      <categories>
        <category>Android, OkHttp</category>
      </categories>
      <tags>
        <tag>Adnroid Source Code</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp4.3源码解析之 - 发起请求]]></title>
    <url>%2Farticles%2Fokhttp_source_code_request.html</url>
    <content type="text"><![CDATA[1.OkHttp4.3源码解析之 - 发起请求什么是OkHttp?OkHttp在Android开发领域里面应该是无人不知了吧。它是一个由Square公司开源的第三方库。主要用于处理网络请求。 OkHttp Github地址：https://github.com/square/okhttp/ 关于Square公司，大家可以去看看他们的其他开源库，质量都挺高的，不仅包括Android相关的，还有Go，Ruby，JS，Kotlin等等 Square官方网站：https://square.github.io/ 到目前为止，OkHttp的最新版本是4.3.1,里面一部分代码也已经用Kotlin来重写了，而大部分分析OkHttp源码的文章还停留在以前旧的版本，因此在写这系列源码分析的文章同时，也是学习Kotlin的一个好机会。 从一个简单的请求说起如果有做过Android开发的话，相信以下代码大家都很熟悉了： 12345678910111213val client = OkHttpClient()val request = Request.Builder().url("https://www.baidu.com").build()val response = client.newCall(request).enqueue(object: Callback&#123; override fun onFailure(call: Call, e: IOException) &#123; println("bluelzy --- $&#123;e.message&#125;") &#125; override fun onResponse(call: Call, response: Response) &#123; println("bluelzy --- $&#123;response.body.toString()&#125;") &#125;&#125;) 这段代码做的事情很简单： 创建一个OkHttpClient对象 使用建造者模式创建一个Request对象 使用OkHttpClient.newCall(request).enqueue() 发起请求，并处理回调 但是这短短的几行代码里面，就已经有很多我们可以学习的东西了。 首先是建造者模式，也叫Builder模式，它的作用是让用户自由组合需要的参数，来实现不同的需求。具体实现方法可以通过接口，也可以像OkHttp一样，使用内部类。这里我们不详细展开阐述，有兴趣的读者可以去看看《大话设计模式》或者《Android源码设计模式分析与实战》。 然后，通过val这种写法来定义变量也不太优雅，因为这些变量其实声明一次就够了，我们可以改进一下代码： 1234567891011121314// 定义RequestRequest.Builder().url("https://www.baidu.com").build().let &#123; request -&gt; // 定义OkHttpClient OkHttpClient().newCall(request).enqueue(object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println("bluelzy --- $&#123;e.message&#125;") &#125; override fun onResponse(call: Call, response: Response) &#123; println("bluelzy --- $&#123;response.body.toString()&#125;") &#125; &#125;) &#125; 把声明的三个变量都干掉，这样代码看起来是不是简洁多了？ 上面就是一个最简单的OkHttp发起GET请求的方式，下面我们一起来看看OkHttp是怎么做到的。 1.创建OkHttpClient这个类的作用就是发起HTTP请求和接收响应 首先OkHttpClient有两个构造方法，一个是无参构造方法，另外一个是传入参数为Builder的构造方法 OkHttpClient的构造方法无参构造方法 12&gt; constructor() : this(Builder())&gt; 有参构造方法 1234&gt; open class OkHttpClient internal constructor(&gt; builder: Builder&gt; ) &gt; OkHttpClient.Builder类可以看到，无参构造方法其实也是调用了Builder为参数的构造方法，这里传入的Builder() 就是默认的实现，继续看看Builder里面是怎么实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Builder constructor() &#123; internal var dispatcher: Dispatcher = Dispatcher() // 调度器 internal var connectionPool: ConnectionPool = ConnectionPool() // 连接池 internal val interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()//拦截器 // 网络拦截器 internal val networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf() // 事件监听 internal var eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory() internal var retryOnConnectionFailure = true internal var authenticator: Authenticator = Authenticator.NONE internal var followRedirects = true internal var followSslRedirects = true internal var cookieJar: CookieJar = CookieJar.NO_COOKIES // 缓存 internal var cache: Cache? = null internal var dns: Dns = Dns.SYSTEM internal var proxy: Proxy? = null // 代理选择器 internal var proxySelector: ProxySelector? = null // 代理身份验证 internal var proxyAuthenticator: Authenticator = Authenticator.NONE // Socket工厂 internal var socketFactory: SocketFactory = SocketFactory.getDefault() // SSL Socket工厂，用于HTTPS internal var sslSocketFactoryOrNull: SSLSocketFactory? = null internal var x509TrustManagerOrNull: X509TrustManager? = null internal var connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS // 协议 internal var protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS // 主机名字确认 internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier // 证书链 internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT // 验证确认响应链，用于HTTPS internal var certificateChainCleaner: CertificateChainCleaner? = null internal var callTimeout = 0 internal var connectTimeout = 10_000 internal var readTimeout = 10_000 internal var writeTimeout = 10_000 internal var pingInterval = 0 internal constructor(okHttpClient: OkHttpClient) : this() &#123; this.dispatcher = okHttpClient.dispatcher this.connectionPool = okHttpClient.connectionPool this.interceptors += okHttpClient.interceptors this.networkInterceptors += okHttpClient.networkInterceptors this.eventListenerFactory = okHttpClient.eventListenerFactory this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure this.authenticator = okHttpClient.authenticator this.followRedirects = okHttpClient.followRedirects this.followSslRedirects = okHttpClient.followSslRedirects this.cookieJar = okHttpClient.cookieJar this.cache = okHttpClient.cache this.dns = okHttpClient.dns this.proxy = okHttpClient.proxy this.proxySelector = okHttpClient.proxySelector this.proxyAuthenticator = okHttpClient.proxyAuthenticator this.socketFactory = okHttpClient.socketFactory this.sslSocketFactoryOrNull = okHttpClient.sslSocketFactoryOrNull this.x509TrustManagerOrNull = okHttpClient.x509TrustManager this.connectionSpecs = okHttpClient.connectionSpecs this.protocols = okHttpClient.protocols this.hostnameVerifier = okHttpClient.hostnameVerifier this.certificatePinner = okHttpClient.certificatePinner this.certificateChainCleaner = okHttpClient.certificateChainCleaner this.callTimeout = okHttpClient.callTimeoutMillis this.connectTimeout = okHttpClient.connectTimeoutMillis this.readTimeout = okHttpClient.readTimeoutMillis this.writeTimeout = okHttpClient.writeTimeoutMillis this.pingInterval = okHttpClient.pingIntervalMillis &#125; Builder是OkHttpClient的内部类，然后Builder声明了很多的参数，这些参数的作用我会在后面的文章中详细分析。 到这里为止，我们就完成了第一步，创建一个OkHttpClient对象，在构造方法里面创建了Builder()对象。然后看第二步：Request.Builder() 创建Request对象 2.创建Request对象Request的构造方法Request的构造方法需要4个参数 1234567class Request internal constructor( @get:JvmName("url") val url: HttpUrl, // 请求的url @get:JvmName("method") val method: String, // 请求方法类型 @get:JvmName("headers") val headers: Headers, // 请求头 @get:JvmName("body") val body: RequestBody?, // 请求体 internal val tags: Map&lt;Class&lt;*&gt;, Any&gt;) Request.Builder类Request同样使用了Builder模式，我们直接看Request.Builder类： 12345678910111213141516171819202122232425262728293031323334open class Builder &#123; internal var url: HttpUrl? = null internal var method: String internal var headers: Headers.Builder internal var body: RequestBody? = null /** A mutable map of tags, or an immutable empty map if we don't have any. */ internal var tags: MutableMap&lt;Class&lt;*&gt;, Any&gt; = mutableMapOf() // 无参构造方法 constructor() &#123; // 默认为GET this.method = "GET" this.headers = Headers.Builder() &#125; // 有参构造方法 internal constructor(request: Request) &#123; this.url = request.url this.method = request.method this.body = request.body this.tags = if (request.tags.isEmpty()) &#123; mutableMapOf() &#125; else &#123; request.tags.toMutableMap() &#125; this.headers = request.headers.newBuilder() &#125; open fun url(url: HttpUrl): Builder = apply &#123; this.url = url &#125; // 省略代码&#125; 可以看到，Builder默认的请求方法是GET，并且初始化了一个大小为20的ArrayList作为Headers的容器 除了method和haders之外，还有两个关键的参数，一个是url，另外一个就是RequestBody。这几个参数都提供了set方法，支持链式调用，例如url： 1234567891011121314open fun url(url: String): Builder &#123; // Silently replace web socket URLs with HTTP URLs. val finalUrl: String = when &#123; url.startsWith("ws:", ignoreCase = true) -&gt; &#123; "http:$&#123;url.substring(3)&#125;" &#125; url.startsWith("wss:", ignoreCase = true) -&gt; &#123; "https:$&#123;url.substring(4)&#125;" &#125; else -&gt; url &#125; return url(finalUrl.toHttpUrl()) &#125; 这里做了一点处理，如果是基于web socket协议的url，会被替换成http，而wws则是加密的web socket协议。 设置完了url / requestBody / mothod / headers 之后，我们都会调用build()方法： 123456789open fun build(): Request &#123; return Request( checkNotNull(url) &#123; "url == null" &#125;, method, headers.build(), body, tags.toImmutableMap() )&#125; 其实就是把刚刚设置的作为参数，调用Request的有参构造方法，创建一个Request对象。到这里为止，第二步也就完成了。 3.发起请求做完前面两步之后，终于到了激动人心的时刻了，我们通过OkHttpClient.newCall(request).enqueue()来发起请求 到源码里面看看newCall和enqueue这两个方法分别做了什么 newCall()方法123override fun newCall(request: Request): Call &#123; return RealCall.newRealCall(this, request, forWebSocket = false)&#125; 调用RealCall.newRealCall方法，并且传入了OkHttpClient和Request作为参数 再看看newRealCall： 123456789101112companion object &#123; fun newRealCall( client: OkHttpClient, originalRequest: Request, forWebSocket: Boolean ): RealCall &#123; // Safely publish the Call instance to the EventListener. return RealCall(client, originalRequest, forWebSocket).apply &#123; transmitter = Transmitter(client, this) // okhttp和网络层的中介 &#125; &#125;&#125; 其实就是创建了一个RealCall对象，注意这里同时创建了一个Transmitter对象。它后面会再出现的，暂时先忽略，我们先回到发起请求这个过程中来。 enqueue()方法上一步创建了RealCall对象是吧，传入了OkHttpClient和Request对象是吧，那么enqueue()方法又做了什么呢？ 这个enqueue()方法其实是Call接口的其中一个方法，除了enqueue之外，还有request(), execute()等其他方法。我们先看这个enqueue()方法： 123456789101112override fun enqueue(responseCallback: Callback) &#123; synchronized(this) &#123; check(!executed) &#123; "Already Executed" &#125; executed = true &#125; transmitter.callStart() client.dispatcher.enqueue(AsyncCall(responseCallback))&#125;override fun cancel() &#123; transmitter.cancel()&#125; 可以看到，首先这个方法有一个Callback作为参数，而这个Callback接口里面又有两个方法： 123456789101112131415161718192021interface Callback &#123; /** * Called when the request could not be executed due to cancellation, a connectivity problem or * timeout. Because networks can fail during an exchange, it is possible that the remote server * accepted the request before the failure. */ fun onFailure(call: Call, e: IOException) /** * Called when the HTTP response was successfully returned by the remote server. The callback may * proceed to read the response body with [Response.body]. The response is still live until its * response body is [closed][ResponseBody]. The recipient of the callback may consume the response * body on another thread. * * Note that transport-layer success (receiving a HTTP response code, headers and body) does not * necessarily indicate application-layer success: `response` may still indicate an unhappy HTTP * response code like 404 or 500. */ @Throws(IOException::class) fun onResponse(call: Call, response: Response)&#125; 分别用于处理失败和成功两种情况的回调。 在enqueue的方法体内，首先通过一个synchronized关键字，确保这个方法只会执行一次， 然后通过dispatcher.enqueue来执行异步请求 12345678910111213internal fun enqueue(call: AsyncCall) &#123; synchronized(this) &#123; readyAsyncCalls.add(call) // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) &#123; val existingCall = findExistingCallWithHost(call.host()) if (existingCall != null) call.reuseCallsPerHostFrom(existingCall) &#125; &#125; promoteAndExecute()&#125; 继续看看promoteAndExecute() 12345678910111213141516171819202122232425262728private fun promoteAndExecute(): Boolean &#123; this.assertThreadDoesntHoldLock() val executableCalls = mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i = readyAsyncCalls.iterator() while (i.hasNext()) &#123; val asyncCall = i.next() if (runningAsyncCalls.size &gt;= this.maxRequests) break // 最大请求数为64 if (asyncCall.callsPerHost().get() &gt;= this.maxRequestsPerHost) continue // 相同的Host最大同时请求数为5 i.remove() asyncCall.callsPerHost().incrementAndGet() executableCalls.add(asyncCall) // 把请求加入到list中 runningAsyncCalls.add(asyncCall) &#125; isRunning = runningCallsCount() &gt; 0 &#125; for (i in 0 until executableCalls.size) &#123; val asyncCall = executableCalls[i] asyncCall.executeOn(executorService) // &#125; return isRunning&#125; 首先判断是不是超过了最大请求数或者是相同Host的最大请求数，如果是的话就直接return 否则就执行asyncCall.excuteOn方法 123456789101112131415161718fun executeOn(executorService: ExecutorService) &#123; client.dispatcher.assertThreadDoesntHoldLock() var success = false try &#123; executorService.execute(this) // 执行请求 success = true &#125; catch (e: RejectedExecutionException) &#123; val ioException = InterruptedIOException("executor rejected") ioException.initCause(e) transmitter.noMoreExchanges(ioException) responseCallback.onFailure(this@RealCall, ioException) &#125; finally &#123; if (!success) &#123; client.dispatcher.finished(this) // This call is no longer running! &#125; &#125;&#125; AsyncCall是RealCall里面的一个内部类，因此在这里已经持有了OkHttpClient对象，也就持有了Dispatcher，而这个executorService又是什么呢？ 其实这是一个线程池执行器，在Dispatcher中定义为一个变量 123456789@get:Synchronized@get:JvmName("executorService") val executorService: ExecutorService get() &#123; if (executorServiceOrNull == null) &#123; executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS, SynchronousQueue(), threadFactory("OkHttp Dispatcher", false)) &#125; return executorServiceOrNull!! &#125; 而 executorService.execute(this) 中的 this 指的就是AsyncCall对象，一个实现了Runnable接口的对象 因此，上面的excuteOn方法，其实就是执行AsyncCall的run()方法啊。 12345678910111213141516171819202122232425262728override fun run() &#123; threadName("OkHttp $&#123;redactedUrl()&#125;") &#123; var signalledCallback = false transmitter.timeoutEnter() try &#123; val response = getResponseWithInterceptorChain() // 1 signalledCallback = true responseCallback.onResponse(this@RealCall, response) //2 &#125; catch (e: IOException) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log("Callback failure for $&#123;toLoggableString()&#125;", INFO, e) &#125; else &#123; responseCallback.onFailure(this@RealCall, e) &#125; &#125; catch (t: Throwable) &#123; cancel() if (!signalledCallback) &#123; val canceledException = IOException("canceled due to $t") canceledException.addSuppressed(t) responseCallback.onFailure(this@RealCall, canceledException) &#125; throw t &#125; finally &#123; client.dispatcher.finished(this) &#125; &#125; &#125; 这里又用到了Kotlin的内联函数，相当于在方法体外面多加了一层try…finally，关于内联函数，大家可以看看官方文档的说明：Kotlin中文网 - 内联函数 12345678910inline fun threadName(name: String, block: () -&gt; Unit) &#123; val currentThread = Thread.currentThread() val oldName = currentThread.name currentThread.name = name try &#123; block() &#125; finally &#123; currentThread.name = oldName &#125;&#125; 首先我们来看注释1 12345678910111213141516171819202122232425262728293031323334@Throws(IOException::class)fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis) var calledNoMoreExchanges = false try &#123; val response = chain.proceed(originalRequest) if (transmitter.isCanceled) &#123; response.closeQuietly() throw IOException("Canceled") &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges = true throw transmitter.noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null) &#125; &#125;&#125; 这里用到了另外一个设计模式：责任链模式，用来处理整个网络请求中不同的部分，例如失败重试，缓存，连接等等。这些不同的部分都通过拦截器的方式来实现。 在chain.proceed(originalRequest)方法中，其实就是调用了RealInterceptorChain.proceed()方法 这个方法的源码： 12345678910111213141516171819202122232425262728293031323334@Throws(IOException::class) fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123; if (index &gt;= interceptors.size) throw AssertionError() calls++ // If we already have a stream, confirm that the incoming request will use it. check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port" &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). check(this.exchange == null || calls &lt;= 1) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once" &#125; // Call the next interceptor in the chain. val next = RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout) val interceptor = interceptors[index] @Suppress("USELESS_ELVIS") val response = interceptor.intercept(next) ?: throw NullPointerException( "interceptor $interceptor returned null") // Confirm that the next interceptor made its required call to chain.proceed(). check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) &#123; "network interceptor $interceptor must call proceed() exactly once" &#125; check(response.body != null) &#123; "interceptor $interceptor returned a response with no body" &#125; return response &#125; 可以看到，通过index + 1的方法，我们取出下一个拦截器，然后执行里面的intercept方法，这就是proceed方法主要进行的工作。最终把Response返回。得到的这个Response又通过Callback.onResponse回调方法，使得我们可以获取到这个Response对象。而如果中途抛出异常，那么则会回调onFailure方法。 至于我们在上面加入的那些拦截器，详细的说明会放到下一篇文章中讲解，我们也会加入自定义拦截器的例子。毕竟这种情况在实际开发中还是经常会遇到的，例如自定义ConverterFactory来解析后台返回的数据。 总结最后，让我们再来回顾一下OkHttp是如何发起请求的： 构造一个OkHttpClient对象，这里有许多的变量用于控制请求时候的参数 构造一个Request对象，这里主要是4个要素：url, method, header, body 调用OkHttpClient.newCall(request).enqueue()方法发起请求，在RealCall类中，实现了Call接口，并且持有OkHttpClient和Request对象，还有一个AsyncCall的内部类，这个内部类就是用来发起异步请求的，这个类同时也实现了Runnable接口，它的getResponseWithInterceptorChain()方法通过责任链的模式，把请求相关的拦截器一个个加入到List中，然后再通过RealInterceptorChain的proceed()方法来执行这些不同的拦截器所定义的方法。 最后成功则回调Callback.onResponse， 失败回调Callback.onFailure 还有，到目前为止我们已经发现了OkHttp使用了两个设计模式，分别是： Builder模式 责任链模式 有兴趣的童鞋可以自行上网查找相关资料~ 好了，一个简单的请求大致上就是这么个流程，下一篇文章我们继续深入了解OkHttp里面的拦截器~]]></content>
      <categories>
        <category>Android, OkHttp</category>
      </categories>
      <tags>
        <tag>Adnroid Source Code</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Android9.0的WindowManager源码解析]]></title>
    <url>%2Farticles%2Fwindowmanager_source_code_analysis.html</url>
    <content type="text"><![CDATA[本文主题关于WindowManager这个复杂的系统，本文会基于Android9.0源码，把其中的关键代码截取出来进行分析，并通过问答的形式来进行叙述，最终回答以下几个问题： WindowManager是什么？它的作用是什么？ Window和WindowManager如何关联？ Window、WindowManager和WindowManagerService三者有什么关系？ Window有哪些类型？ Window在Activity启动过程中的作用？ Window如何处理View的添加、移除和更新？ WindowManager是什么摘自 Android开发者官网： The interface that apps use to talk to the window manager.Each window manager instance is bound to a particular Display. To obtain a WindowManager for a different display, use Context#createDisplayContext to obtain a Context for that display, then use Context.getSystemService(Context.WINDOW_SERVICE) to get the WindowManager.The simplest way to show a window on another display is to create a Presentation. The presentation will automatically obtain a WindowManager and Context for that display. 用通俗一点的话来讲就是： WindowManager是一个实现了ViewManager的接口，至于它是干嘛用的，官方文档并没有详细说明，从名字上我们可以知道它和显示有关，用于管理Window，具体作用还是直接看源码吧。 如何获取WindowManager正如官方文档所说，我们可以直接通过 Context.getSystemService(Context.WINDOW_SERVICE) 来获取WindowManager 继承ViewManager接口WindowManager继承ViewManager接口，而ViewManager接口很简单，只有三个方法 12345678910111213141516171819public interface ViewManager&#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ // 添加View public void addView(View view, ViewGroup.LayoutParams params); // 更新View public void updateViewLayout(View view, ViewGroup.LayoutParams params); // 移除View public void removeView(View view);&#125; 定义了许多Flags在WindowManager.LayoutParams里面有许多Flags，这些Flag的作用就是在创建Window的时候用于区分这个Window到底是什么类型的，关于Window类型的问题我们会在后面再详细说明。 下面列举了一小部分Flags 123456789101112131415161718public static final int TYPE_BASE_APPLICATION = 1;public static final int TYPE_APPLICATION = 2;public static final int TYPE_APPLICATION_STARTING = 3;public static final int TYPE_DRAWN_APPLICATION = 4;public static final int LAST_APPLICATION_WINDOW = 99;public static final int FIRST_SUB_WINDOW = 1000;public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;// 后面省略N个Flag 通过int类型的Type，我们可以区分不同的Window类型。 大家也可以直接跳到第四个问题查看：Window有哪些类型？ 回答：WindowManager是什么WindowManager负责的事情其实并不多，主要完成一些配置工作（定义Window类型的Flags，以及LayoutParams静态内部类），具体的跨进程通信还是要看WindowManagerService，而对View的操作则是通过WindowManagerGlobal来进行。 Window和WindowManager如何关联说了这么多，分析了一通WindowManager这个类的源码，我们只知道它是一个接口，但是还不知道它具体是怎么使用的。别急，接下来就轮到Window登场了。 关联的关键：Window.java我们在Window.java找到以下代码: 1234567891011121314151617181920212223242526272829/** * Set the window manager for use by this Window to, for example, * display panels. This is &lt;em&gt;not&lt;/em&gt; used for displaying the * Window itself -- that must be done by the client. * * @param wm The window manager for adding new windows. */ public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123; setWindowManager(wm, appToken, appName, false); &#125; /** * Set the window manager for use by this Window to, for example, * display panels. This is &lt;em&gt;not&lt;/em&gt; used for displaying the * Window itself -- that must be done by the client. * * @param wm The window manager for adding new windows. */ public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated; if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; // 通过WindowManagerImpl创建WindowManager对象，并赋值给mWindowManager mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125; 这两个setWindowManager()方法分别在Activity和Dialog中被调用了。说明在Activity创建，Toast显示的过程中都需要用到WindowManager。 注意：mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); 这一行代码就是Window和WindowManager产生化学反应的关键！ 首先需要看看WindowManagerImpl是什么 WM的实现类：WindowManagerImpl.javaWindowManagerImpl.java 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; 其实Window.java里面调用的这个方法，就是创建一个Impl对象。 在WindowManagerImpl中，我们会看到有个成员变量 private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); 这个WindowManagerGlobal 正是用于对View进行操作的实际对象。 无论是addView(), updateView(), removeView()，都是通过这个对象进行操作的。 12345678910111213141516171819202122232425@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); // 调用WindowManagerGlobal 的addView()方法 mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); // 同理 mGlobal.updateViewLayout(view, params); &#125; @Override public void removeView(View view) &#123; // 同理 mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; // 同理 mGlobal.removeView(view, true); &#125; 关于WindowManagerGlobal 怎么处理View的逻辑，我们在后面会继续解析。这里还是先回到Window和WindowManager这两者是如何关联这个问题上来。 如果大家有细心留意的话就能看到，WindowManagerImpl的构造方法里面有一个parentWindow 的参数，这个参数的类型是Window，也就是说，当我们在Activity或者Dialog调用setWindowManager()的时候，就会把当前Window作为参数传递过来，在创建WindowManager的同时把这两者给关联起来。 回答：Window和WindowManager如何关联在创建Activity或者Dialog的时候会调用Window.setWindowManager()方法，然后把当前Window作为参数传递到WindowManagerImpl的createLocalWindowManager()方法中，在创建WindowManager对象的时候把Window关联起来。 Window、WindowManager和WindowManagerService三者有什么关系通过前面的分析，我们知道Window和WindowManager是如何关联起来的，然鹅到目前为止，我们还是不知道在Framework层的Window是如何同Native层的WindowManagerService进行通信的，让我们继续看源码。 上面说到，具体对View的操作实际是WindowManagerGlobal这个类来做的，那我们看看addView()方法里做了什么： 12345678910111213141516171819202122232425262728293031 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; // 省略代码 synchronized (mLock) &#123; // 继续省略代码 // 构建ViewRootImpl对象 root = new ViewRootImpl(view.getContext(), display); // 设置参数 view.setLayoutParams(wparams); // 把view,root, param添加到对应的list中 mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; // 调用setView方法显示View root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; 这里主要做了几件事： 构建ViewRootImpl对象 设置参数 添加到list中 把View显示出来 我们一个个来看，首先是构建ViewRootImpl对象 123456789101112public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mBasePackageName = context.getBasePackageName(); mThread = Thread.currentThread(); mLocation = new WindowLeaked(null); mLocation.fillInStackTrace(); // 省略代码 &#125; 这里初始化了许多的成员变量，其中有一个是mWindowSession，我们进去看看 123456789101112131415161718192021222324252627@UnsupportedAppUsagepublic static IWindowSession getWindowSession() &#123; // 同步代码块，保证线程安全 synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; // Emulate the legacy behavior. The global instance of InputMethodManager // was instantiated here. // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary(); // 获取WindowManagerService对象 IWindowManager windowManager = getWindowManagerService(); // 建立一个Session sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; 看一下WindowManager是如何获取WMS对象的： 123456789101112131415161718@UnsupportedAppUsagepublic static IWindowManager getWindowManagerService() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowManagerService == null) &#123; sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService("window")); try &#123; if (sWindowManagerService != null) &#123; ValueAnimator.setDurationScale( sWindowManagerService.getCurrentAnimatorScale()); &#125; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowManagerService; &#125;&#125; 通过ServiceManager.getService(“window”)获取到WMS，然后再转为IWindowManager，那么在getService()方法中做了什么呢？ 12345678910111213public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return Binder.allowBlocking(rawGetService(name)); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, "error in getService", e); &#125; return null; &#125; 可以看到getService()方法返回的是IBinder对象。到这里我们就真正拿到了WMS了，也知道了Framework层与Native底层其实都是通过Binder机制进行通信。 这里比较绕，我们按照流程来捋一遍：首先在ViewRootImpl构建过程中，我们需要初始化IWindowSession对象，因此在getWindowSession() -&gt; getWindowManagerService() -&gt; getService()中从缓存列表(HashMap)获取WMS，然后通过asInterface函数转为WindowManager对象，最后通过openSession()与WMS建立会话，也就是在Framework层和Native层之间建立了连接。 回答：Window，WM和WMS有什么关系经过前面三个问题的分析，我们应该有比较清晰的脉络了，对于这三者，Window和WM有关联（通过Activity和Dialog，忘记了可以回头看），WM和WMS有关联（通过WM的实现类WindowManagerImp的小弟WindowManagerGlobal） 因此，在Activity或者Dialog创建的时候，其实这三者就已经创建并且相互关联起来了。 我们还没说View到底是怎么显示出来的，这个问题留到最后一步再来解决。 Window有哪些类型我们现在来填第一个问题时候埋下的坑，关于Window有哪些类型，其实就三种 System Window Sub Window Application Window System Window（系统窗口）常见的例如Toast，输入法，系统弹出框等等，这部分窗口我们是没有权限创建的。 还记得上面我们列举了一小部分的Flags吗？System Window的type范围是2000以上，下面列举一部分 WindowManager.java: 1234567891011121314151617 //系统窗口 public static final int FIRST_SYSTEM_WINDOW = 2000; //状态栏 public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW; // 搜索栏 public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;// 来电窗口 @Deprecated public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2; // 系统提示 @Deprecated public static final int TYPE_SYSTEM_ALERT = FIRST_SYSTEM_WINDOW+3; Sub Window（子窗口）所谓子窗口，则是指这个窗口还要有一个父窗口，例如PopupWindow Sub Window的范围是是1000~1999，由于Sub Window比较少，我就全部列出来了 WindowManager.java 12345678910111213141516171819 // 子窗口 public static final int FIRST_SUB_WINDOW = 1000; // 面板窗口 public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW; // 媒体窗口 public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1; // 应用程序窗口子面板 public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;child of its container. // 对话框 public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3; // 媒体信息 @UnsupportedAppUsage public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4; // 应用程序窗口顶层子面板 public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5; // 结束子窗口 public static final int LAST_SUB_WINDOW = 1999; Application Window(应用程序窗口)常见的例如Activity，由于比较少，我也全部列举出来了： WindowManager.java 123456789101112// 开始应用程序窗口 public static final int FIRST_APPLICATION_WINDOW = 1;// 程序窗口的base窗口，其他窗口都在它之上 public static final int TYPE_BASE_APPLICATION = 1; // 普通应用程序窗口 public static final int TYPE_APPLICATION = 2;// 程序启动窗口 public static final int TYPE_APPLICATION_STARTING = 3;// 普通应用程序窗口的一种变体，显示应用程序之前等待时的窗口 public static final int TYPE_DRAWN_APPLICATION = 4;// 结束程序窗口 public static final int LAST_APPLICATION_WINDOW = 99; 回答：Window有哪些类型三种，分别是系统窗口，子窗口，应用程序窗口，根据Type大小，系统窗口&gt;子窗口&gt;应用窗口，因此系统窗口在最上层，优先级最高。 WindowManager在Activity启动过程中的作用Activity的attach()方法 关于Activity启动过程我们先忽略，只了解与Window/WindowManager相关的源码 在Activity.attach() 方法中，我们找到了WindowManager的身影 123456789101112131415161718192021222324252627@UnsupportedAppUsage final void attach(Context context, ActivityThread aThread, // 忽略代码... // 创建Window mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); // 创建WindowManager mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); setAutofillOptions(application.getAutofillOptions()); setContentCaptureOptions(application.getContentCaptureOptions()); &#125; 在attach()方法中，Activity会创建一个Window，然后setWindowManager() 我们在上面已经分析过了，其实就是创建了一个WindowManagerImpl类，并把Window和WM关联了起来。 接下来在Activity的onCreate()方法中，我们会调用setContentView()方法: AppCompatActivity.java 1234@Override public void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID); &#125; 继续进入AppCompatDelegate.java，这是一个抽象类，没有实现具体方法，我们直接看他的子类AppCompatDelegateImpl.java 123456789101112131415161718192021222324252627@Override public void setContentView(View v) &#123; ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v); mAppCompatWindowCallback.getWrapped().onContentChanged(); &#125; // 主要关注这个方法 @Override public void setContentView(int resId) &#123; ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mAppCompatWindowCallback.getWrapped().onContentChanged(); &#125; @Override public void setContentView(View v, ViewGroup.LayoutParams lp) &#123; ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v, lp); mAppCompatWindowCallback.getWrapped().onContentChanged(); &#125; 这里提供了三个setContentView的重载方法，我们只看第二个，也就是传入layoutId的这个方法： ensureSubDecor(); 123456789101112131415161718192021222324252627282930313233private void ensureSubDecor() &#123; if (!mSubDecorInstalled) &#123; mSubDecor = createSubDecor(); // 创建Decor // If a title was set before we installed the decor, propagate it now CharSequence title = getTitle(); if (!TextUtils.isEmpty(title)) &#123; if (mDecorContentParent != null) &#123; mDecorContentParent.setWindowTitle(title); &#125; else if (peekSupportActionBar() != null) &#123; peekSupportActionBar().setWindowTitle(title); &#125; else if (mTitleView != null) &#123; mTitleView.setText(title); &#125; &#125; applyFixedSizeWindow(); onSubDecorInstalled(mSubDecor); mSubDecorInstalled = true; // Invalidate if the panel menu hasn't been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!mIsDestroyed &amp;&amp; (st == null || st.menu == null)) &#123; invalidatePanelMenu(FEATURE_SUPPORT_ACTION_BAR); &#125; &#125; &#125; createSubDecor() 123456789101112131415161718192021222324252627282930private ViewGroup createSubDecor() &#123; // 忽略代码... // 获取Window ensureWindow(); mWindow.getDecorView(); final LayoutInflater inflater = LayoutInflater.from(mContext); ViewGroup subDecor = null; // 忽略代码... // 调用PhoneWindow的setContentView方法 mWindow.setContentView(subDecor); contentView.setAttachListener(new ContentFrameLayout.OnAttachListener() &#123; @Override public void onAttachedFromWindow() &#123;&#125; @Override public void onDetachedFromWindow() &#123; dismissPopups(); &#125; &#125;); return subDecor; 这个方法主要做了两个事情 获取Window，保证mWindow对象不为空 获取到Window对象后再调用setContentView()方法 我们先看第一步： 123456789101112131415161718192021222324252627282930313233343536373839private void ensureWindow() &#123; // We lazily fetch the Window for Activities, to allow DayNight to apply in // attachBaseContext if (mWindow == null &amp;&amp; mHost instanceof Activity) &#123; // 调用Activity的getWindow()方法 attachToWindow(((Activity) mHost).getWindow()); &#125; if (mWindow == null) &#123; throw new IllegalStateException("We have not been given a Window"); &#125; &#125; // 把上面获取到的window对象赋值给mWindow private void attachToWindow(@NonNull Window window) &#123; if (mWindow != null) &#123; throw new IllegalStateException( "AppCompat has already installed itself into the Window"); &#125; final Window.Callback callback = window.getCallback(); if (callback instanceof AppCompatWindowCallback) &#123; throw new IllegalStateException( "AppCompat has already installed itself into the Window"); &#125; mAppCompatWindowCallback = new AppCompatWindowCallback(callback); // Now install the new callback window.setCallback(mAppCompatWindowCallback); final TintTypedArray a = TintTypedArray.obtainStyledAttributes( mContext, null, sWindowBackgroundStyleable); final Drawable winBg = a.getDrawableIfKnown(0); if (winBg != null) &#123; // Now set the background drawable window.setBackgroundDrawable(winBg); &#125; a.recycle(); mWindow = window; &#125; 还记得在这个问题的开头，Activity的attach()方法中做了什么吗？ 没错，我们初始化了一个PhoneWindow对象，并赋值为了mWindow！因此在这里拿到的Window对象自然也是PhoneWindow了！ 因此第二步调用的setContentView()方法，也就是：PhoneWindow.setContentView()了。我们继续往下看 PhoneWindow的setContentView()方法 PhoneWindow.java 12345678910111213141516171819202122232425262728@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; //1.创建DecorView,以及DecorView中的mContentParent 布局 installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //2,将layoutResID布局加载到mContentParent和上 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; //3通知视图改变回调 cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125; 我们看一下installDecor()做了什么 12345678910111213141516171819202122232425262728293031323334353637private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; // 创建Decor mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; // 生成一个Layout mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; &#125; 具体的源码就不再仔细分析了，在这里系统主要做了：创建Decor，然后根据Window的Flag, Theme等配置创建一个布局，并且添加到Decor中。 至此，Activity已经成功的创建了WindowManager, 创建了Decor，创建了相应的布局，还差最后一步：把这个布局添加到Window中并显示出来。 让我们回到最初的起点，也就是ActivityThread，在这里我们能看到有个方法：handleResumeActivity()并找到其中一段 1234567891011121314// 设置activity为可见状态if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125;void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; // 注意这个调用，正是因为它用户才能看到activity的界面内容 mDecor.setVisibility(View.VISIBLE); &#125; 在这里系统又做了三件事情： 获取WindowManager 把刚刚创建的Decor对象添加到WM中 设置Decor为可见状态 最终Activity才能正常显示在用户的面前。 回答：WindowManager在Activity启动过程中的作用首先ActivityThread.attach()方法会创建Window和WindowManager 然后在onCreate()方法中会调用创建的PhoneWindow的setContentView()方法，接着在里面创建Decor以及一个根布局，创建完毕后把layoutResId加载到布局中，然后通知回调 最后调用ActivityThead.handleResumeActivity()方法，在这里把WindowManager和Decor关联起来，并且调用setVisibility让Decor可见，最终把UI呈现在用户面前。 WindowManager如何处理View的添加、移除和更新这一个问题其实是上一个问题的延伸和扩展，虽然在上面我们说到了ActivityThread()调用handleResumeActivity()方法，然后把Decor通过addView()的方式加入到WindowManager中，但是我们有没有想过，这个addView()的过程有涉及到哪些模块呢？ 正是因为这一过程比较复杂，因此也值得单独提出来探究。 addView() 过程还记得WindowManager.addView() 实际调用的是哪个类的方法吗？忘了的请回去重新看一遍第二问~ WindowManagerGlobal.java 12345678910111213141516public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; // 省略N行代码... try &#123; // 调用ViewRootImpl.setView方法 root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; RootViewImpl.setView() 12345678910111213141516171819202122232425262728293031323334353637383940public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; // 1 requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; mForceDecorViewVisibility = (mWindowAttributes.privateFlags &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); // 2 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame, mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel, mTempInsets); setFrame(mTmpFrame); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException("Adding window failed", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; &#125; &#125; RootViewImpl.setView()方法很复杂，其中我们需要关注的是两点： requestLayout() mWindowSession.addToDisplay() 我们先看一下requestLayout()方法： 12345678910111213141516171819202122232425262728293031323334// 定义 TraversalRunnable final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125;// 初始化 mTraversalRunnablefinal TraversalRunnable mTraversalRunnable = new TraversalRunnable(); @Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); // 检查锁 mLayoutRequested = true; scheduleTraversals(); // 发送 CALLBACK_TRAVERSAL 消息 &#125; &#125; @UnsupportedAppUsage void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); // 向 mTraversalRunnable 发送一条 CALLBACK_TRAVERSAL 消息 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125; &#125; 往Handler里面发送一条CALLBACK_TRAVERSAL消息，这条消息的意思就是刷新界面。 最终会调用 doTraversal() 方法 1234567891011121314151617void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing("ViewAncestor"); &#125; performTraversals(); //1 if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; 然后到 performTraversals() 方法, 这个方法非常复杂，整个方法加起来大概有800多行，主要工作就是 测量各个View的大小(performMeasure) 布局(performLayout) 绘制(performDraw) 最终把整个视图树展示出来 updateViewLayout() 过程update过程比较简单，直接上源码： 1234567891011121314151617181920public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); // 1 mParams.remove(index); // 2 mParams.add(index, wparams); // 3 root.setLayoutParams(wparams, false); // 4 &#125; &#125; 首先获取要update的View的ViewRootImpl 把这个View的LayoutParam移除掉 重新添加LayoutParam 刷新根布局 removeView() 过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@UnsupportedAppUsage public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); // 1 if (curView == view) &#123; return; &#125; throw new IllegalStateException("Calling with view " + view + " but the ViewAncestor is attached to " + curView); &#125; &#125; // 移除对应的View private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = view.getContext().getSystemService(InputMethodManager.class); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); // 2 if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125; &#125; boolean die(boolean immediate) &#123; if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); // 3 return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(mTag, "Attempting to destroy the window while drawing!\n" + " window=" + this + ", title=" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); // 5 return true; &#125; void doDie() &#123; checkThread(); if (LOCAL_LOGV) Log.v(mTag, "DIE in " + this + " of " + mSurface); synchronized (this) &#123; if (mRemoved) &#123; return; &#125; // 省略代码... WindowManagerGlobal.getInstance().doRemoveView(this); //4 首先通过removeView()方法来移除View，在这个方法里面调用了removeViewLocked() 在removeViewLocked()又调用了 root.die(immediate) 在die() 又调用了 doDie() 在doDie()中调用了 doRemoveView() 如果需要延迟，则再发送一条MSG_DIE，重新调用doDie()方法 doRemoveView() 12345678910111213void doRemoveView(ViewRootImpl root) &#123; synchronized (mLock) &#123; final int index = mRoots.indexOf(root); if (index &gt;= 0) &#123; mRoots.remove(index); mParams.remove(index); final View view = mViews.remove(index); mDyingViews.remove(view); &#125; &#125; if (ThreadedRenderer.sTrimForeground &amp;&amp; ThreadedRenderer.isAvailable()) &#123; doTrimForeground(); &#125; 这个方法和上面的update方法类似，从缓存列表中找到对应的view，然后移除掉。 总结在这篇文章中，我们从Acitivty的创建过程说起，涉及到ActivityThread, Window, WindowManager, WindowManagerService, RootViewImpl, PhoneWindow, WindowManagerImpl, WindowManagerGlobal 这么多类的相关源码分析，希望大家看完之后能对WindowManager相关的知识点有所了解。 如果文章有不对的地方也欢迎大家批评指正，感谢阅读！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Adnroid Framework</tag>
        <tag>WindowManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移Valine到Disqus]]></title>
    <url>%2Farticles%2Fchange_valine_to_disqus.html</url>
    <content type="text"><![CDATA[最近由于Leancloud DNS解析不稳定的原因，决定把评论系统从Valine迁移到Disqus。 也正好把博客从国外主机迁移回Github Pages 上。 缘由今年过完年以后就没写过博客了，一个原因是因为懒，另外一个原因也是因为最近国外的主机不太稳定，5月底banwagong的VPS被封了，6月初leancloud又莫名其妙无法解析DNS，导致我的博客访问很不稳定，评论系统也挂了，有考虑过自己搭建一个WordPress，但是在国内的话又要备案，想想还是算了，这一折腾又要好几天。还是直接把评论系统迁移到Disqus省事。 正好banwagong也放弃了，把博客老老实实放回到Github上，以后安安静静写博客，不折腾了。 博客迁移由于我之前hexo -deploy的时候就是vps和github两个仓库都会push的，因此Github上一直都有我最新的代码。这次只要把域名解析换一下就可以了。 这部分没有截图，所以也不细说了，有需要的童鞋可以直接谷歌github自定义域名 重点说一下Disqus的迁移 评论迁移我用的是next主题，本身就内置了Disqus，因此步骤比较简单 注意：Disqus需要梯子，国内无法直接访问。 注册Disqus账号打开 disqus官方：https://disqus.com/ ，注册一个账号 创建站点登录后，点击 GET STARTED 然后选择第二个 I want to install Disqus on my site Your Sites输入你的网址，还有Website Name, 这一栏填写的就是hexo中所使用的short_name, category选择种类，我的是Tech 进入到Install Disqus界面，这里我们选择 Universal Code，因为Hexo不在列表项里面。 最后进入到Configure Disqus界面，这里填入Website Name 和 Website URL，name一般是上面填写的short_name。 配置本地文件打开主题配置文件_config.yml 搜索disqus，输入short_name，保存再重启hexo就可以了 总结虽然在墙内用不了Disqus，但是慢慢我也想通了，暂时这个博客对于我来说就是一个记录的地方，时间精力应该放在写作和学习，而不是折腾上。如果以后访问量增加了，可能我也会考虑自己搭建WP，所有的东西都保存到自己的服务器上，这样更加安全和稳定。 现在还是专心写博客，提升自己。 最后附上Valine的评论统计截图。纪念过去的341条评论，谢谢你们！]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Disqus</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 网易云音乐无法打开]]></title>
    <url>%2Farticles%2Fubuntu_can_not_open_netease_cloud_music.html</url>
    <content type="text"><![CDATA[最近发现家里PC升级到Ubuntu18.04之后，网易云音乐无法打开了 把解决问题的过程记录下来，也方便遇到这个问题的人。 起因 命令行打开网易云音乐（下面简称网易云） sudo netease-cloud-music 终端报错： error while loading shared libraries: libvlc.so.5: cannot open shared obect file: No such file or direcory 点击启动图标启动网易云 无反应，不能显示网易云的界面 但是终端报错已经给我们提供了思路，既然是libvlc.so.5这个依赖库找不到，那么我们把它装上不就好了嘛 解决首先用命令查看一下libvlc.so.5在哪里： whereis libvlc.so.5 终端输出： libvlc.so: /usr/lib/x86_64-linux-gnu/libvlc.so.12 OK, 既然我们Ubuntu里面没有so.5，但是有so.12，那么可不可以尝试用软连接的方式呢？ 试一下： cd /usr/lib/x86_64-linux-gnu/ sudo ln -s libvlc.so.12 libvlc.so.5 把so.12 和 so.5 连接起来，然后再看看结果： ls -il | grep vlc 一切正常的话应该可以看到所有vlc的软连接，这个时候我们再来运行网易云发现一切正常了~ 命令行启动： sudo netease-cloud-music 注意如果启动需要sudo的话，可以修改netease-cloud-music.desktop文件 找到该文件： dpkg -L netease-cloud-music|grep desktop 打开： sudo vim /usr/share/applications/netease-cloud-music.desktop 找到Exec这行并修改为： Exec=sh -c “unset SESSION_MANAGER &amp;&amp; netease-cloud-music %U 最后保存并退出，就可以了。]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Netease Cloud Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 219.Contains Duplicate II]]></title>
    <url>%2Farticles%2Fleetcode_219_solutions.html</url>
    <content type="text"><![CDATA[今天是大年初七，祝大家新年快乐！万事如意！恭喜发财！ 同时也是实现今年小目标的第一篇文章：LeetCode 219 题解 说说LeetCode作为大名鼎鼎的面试刷题网站，最近也出了中文版，如果之前没有了解过的童鞋，建议去网站看看，里面有各大互联网公司的算法面试题，包括谷歌，Fackbook，微软，亚马逊等等，近年来国内的互联网公司也越来越重视算法和数据结构了，特别是后端，经常看到高级工程师 职位以上的jd都写明，算法水平需要到LeetCode Hard程度，前端稍微好一点，但是也需要LeetCode Easy 水平，因此无论是为了巩固基础，还是找工作跳槽，我们都需要不断练习算法，那么比较好的方式自然就是找一个靠谱的平台刷题了。 英文网站：https://leetcode.com/ 中文网站：https://leetcode-cn.com/ 值得一提的是，现在中文LeetCode【力扣】 还支持同步英文网站的账号数据，但是就个人而言，英语过得去的还是建议上英文，因为里面的功能比中文网多一点，而且最重要的是，Discuss里面的人数也会多一些，经常能看到NB的解法，还是很有帮助的。 那么为什么刷题还要写文章记录下来呢？ 其实这篇文章的题目我在两年前就已经做过了，但是今天重新看，发现还是需要花很多时间去想解法，一方面当然是因为没有坚持做算法题，思维跟不上，另外一方面就是当时做完就算了，没有进一步思考，除了自己的这个解法，是否还有更好的方法。 因此我选择了把思考和改进的过程记录下来，当然大家用笔记类的工具记录，或者放到Github上都可以，目的都是为了锻炼自己的思维，提高算法水平罢了。 我当时的提交记录： 我打败了58%的人，那么前面的算法是怎么样的呢？ 之前使用的是Java，那么如果换成C，C++，Python等语言，结果又是怎么样呢？ 除了算法之外，是不是也有一些编程语言的技巧呢？ 通过进一步的思考，我们会发现越来越多可以深入学习的地方。 因此，我决定把一部分题目写成博客，初衷就是为了方便自己，如果正好也能给予他人一点帮助的话，那就更好了。 219.Contains Duplicate II难度： Easy 分类：Array题目Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: 12Input: nums = [1,2,3,1], k = 3Output: true Example 2: 12Input: nums = [1,0,1,1], k = 1Output: true Example 3: 12Input: nums = [1,2,3,1,2,3], k = 2Output: false 翻译： 给定一个数组和一个整数k，找出是否存在两个不同下标i和j，满足nums[i] = nums[j]，并且这两个数字的绝对值不大于k。 解答思路： 根据题目可知：我们需要一个数组和一个整形，返回值是Boolean类型的。 1234567public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; boolean isTrue = false; return isTrue; &#125;&#125; 然后我们要找出是否存在满足题目条件的两个数，这里我的想法是使用一个HashMap来存储下标，然后遍历找出满足条件的数组下标 12345678910111213141516public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; boolean isTrue = false; // Setp 2 HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;&gt;(); // 通过遍历数组，把数组的值存到HashMap中，再找后面是否存在值一样，而且下标差值&lt;=k的数，有的话返回 true for(int i=0;i&lt;nums.length;i++)&#123; if(hashMap.containsKey(nums[i]) &amp;&amp; i - hashMap.get(nums[i]) &lt;= k)&#123; isTrue = true; &#125;else &#123; hashMap.put(nums[i], i); &#125; &#125; return isTrue; &#125;&#125; 考虑边界条件，虽然这样做就可以达到题目的要求了，但是提交的时候没能通过test cast，原因是没有考虑到当数组大小&lt;=1的情况，加上这个条件，最终我的提交结果为： 123456789101112131415161718public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; boolean isTrue = false; // Step 3 if(nums.length&lt;=1)&#123; return isTrue; &#125; HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(hashMap.containsKey(nums[i]) &amp;&amp; i - hashMap.get(nums[i]) &lt;= k)&#123; isTrue = true; &#125;else &#123; hashMap.put(nums[i], i); &#125; &#125; return isTrue; &#125;&#125; 这个解答的时间是：11ms，打败了58%的人，那么有没有更简单更好的解答呢？ 思考这个是LeetCode Discuss上的解答，经过我在LeetCode上Run Code，Runtime为 0 ms： 12345678public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(i &gt; k) set.remove(nums[i-k-1]); if(!set.add(nums[i])) return true; &#125; return false; &#125; 思路： 同样是通过遍历数组， 如果i&gt;k，那么说明前面的值已经不满足|i-j| &lt;= k 的条件，可以移除 i-k-1的值 然后再判断，如果发现，咦，有一个数已经在集合里面了，我没办法加进去， set.add() 返回的是 false，那么这个数就是符合题目要求的，存在这样的数，因此我们直接 return true 我们来看看HashSet的源码： 123456789101112131415/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; 通过这个方法就可以判断当前元素是否已经在集合里面了。 其实这个解法的思路和我的解法是大同小异的，但是代码写得很巧妙，值得学习的地方有好几个： 通过set.add()的方法来判断，不需要 i - hashMap.get(nums[i]) &lt;= k 通过set.remove(nums[i-k-1]) 来移除不满足条件的数字，而不是像我的方法，通过add，再一个个判断，减少了工作量 除了学习算法思路以外，也可以学习到集合的一些源码和实现，也就是数据结构的知识 C++ 解法 - Runtime: 8 ms123456789101112131415class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_set&lt;int&gt; st; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; k) &#123; st.erase(nums[i - k - 1]); &#125; if (!st.insert(nums[i]).second) &#123; return true; &#125; &#125; return false; &#125;&#125;; Python解法 - Runtime: 24 ms1234567def containsNearbyDuplicate(self, nums, k): dic = &#123;&#125; for i, v in enumerate(nums): if v in dic and i - dic[v] &lt;= k: return True dic[v] = i return False 总结今年立下的目标就是巩固基础，包括设计模式，算法与数据结构，学习第三方框架源码等，每天都要进步一点点，量变引起质变！与大家共勉！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array Question</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blog一周年心路历程]]></title>
    <url>%2Farticles%2Fblog_one_anniversary.html</url>
    <content type="text"><![CDATA[不知不觉一年的时间过去了 截止到12月19日，这个Blog已经顺利运行了1年零2天 正好趁这个日子写点东西记录Blog的历程 0.搭建博客 只是为了翻墙 ​ — 来自天朝的呐喊 一开始购买VPS的目的很简单，只是为了翻墙而已。用了一个星期之后，觉得一年花100多RMB就为了搭个梯子太浪费了，还是要拿来做点别的，折腾折腾也是好的，于是就开始了购买域名，配置博客等等一系列的事情了。 刚开始的时候真的是什么都不懂，全靠谷歌给我指路，详情就不说了，主要的内容我都写在这几篇文章里了： 使用Hexo搭建个人博客(一) 使用Hexo搭建个人博客(二) 使用Hexo搭建个人博客(三) CentOS 6 安装Nginx Vim简单入门 花了一个周末的时间把前期的准备工作都做好，顺便把主题也给设置好 当初刚开始的时候用的还是Material主题，成功部署到VPS的时候打开自己的网站，那一刻觉得真的是太酷了！太酷了！太酷了！ 有点可惜的是没有截图保存，附上一些链接： Hexo-Material-Theme主题的Github地址：https://github.com/viosey/hexo-theme-material/ 看到第一个基于Hexo-Material-Theme的Blog：neoFelhz’s Blog 截图既然没有保存，就让它随风而去吧。这大概就是搭建这个Blog的第一个阶段了，对于我来说一切都是全新的，遇到问题，百度谷歌，修改各种配置文件+源码，最后得到还算满意的版本。 1.更换主题 怎么没有一个好用的评论系统？ ​ — From：Hexo-Material-Theme 在Blog成功部署之后，每天最大的乐趣就是打开MacBook，用hexo -n &#39;xxx&#39; 新建一篇文章，然后一点点地完成，最后hexo -g + hexo -s 来查看效果。看到自己的文章顺利的出现在网站上，部署后通过百度和谷歌还能搜索到，就觉得特别有成就感。 但是毕竟是刚开的博客，自己也没有什么知名度，感觉写了文章但是都没有收到反馈，而Material-Theme的评论系统只有来必力还可以，又必须要登陆才能使用，最后找了很久，发现Next 主题的星星（Stars）最多，支持的插件也比较丰富，于是只好忍痛抛弃Material，转去使用Next，具体的过程我也写成了文章： 弃暗投明-Hexo更换next主题 为你的Hexo加上评论系统-Valine 到目前为止，为你的Hexo加上评论系统-Valine 是我网站上阅读量最多的一篇，三天两头就能看到评论区里面多了一些奇奇怪怪的评论，哈哈哈~ 其实搭建博客，一方面是为了记录自己的日常和感想，另外一方面其实也是和大家交流的过程，自从写了博客以后，发现自己对技术的热情更高了，对待问题的态度更积极了，对Bug….还是一如既往的烦 但是起码能够静下心来Debug，解决问题并且弄懂背后的原理，而且这种变化是潜移默化的。一年前的我绝对想不到自己的改变会这么大。 2. 折腾不止其实来到8102年，Android开发，或者说移动互联网，已经来到了下半场，再也不是2013、2014年风口上的猪了，相应的对于移动开发人员的需求自然也会变少，但是同时要求也变高了。这几年出现了RN，Weex，Kotlin，Flutter，小程序，快应用等各种新技术和新产品，对于原生开发来说，确实可以算是江河日下。 就我个人而言，虽然市场的需求量仍然比较大，找工作求职没问题，但是按照技术发展日新月异，语言框架更新越来越快的趋势，只会单一的技术栈还是不够的，需要不断拓宽自己的技术边界，例如COBOL，Scheme，Lisp等等很多古老的语言，现在已经被淘汰了。作为AI新贵：Python，近两年变得越来越流行，因此我也在业余时间自学一些新的语言和技术。 例如，买一个树莓派回来跑脚本： 树莓派新手指南（一） 树莓派新手指南(二)-必备设置 现在在跑的脚本就是： 每天获取天气预报，然后定时闹钟并播报 每周爬取一次电影天堂数据，存入数据库（Scrapy） 学习Python： 第一课就是爬虫，爬各种网站并且存入到数据库中 第二课就是Python Web By Flask，目前跟着《Flask Web开发实战》学习 第三课就是把后端和移动端结合起来，做一个个人项目(Todo) 顺便把开发环境换成了Ubuntu： 从Mac转投Ubuntu进行Android开发 Ubuntu使用魅族手机进行Debug 学习Vim 和 Linux常用命令 还有就是在Android开发方面好好学习，天天向上~ 学习Kotlin并且在个人+公司项目中使用 学习Jetpack全家桶 接触Flutter 最近发现自己的基础还是不够扎实，买了一堆经典书籍回来，打算慢慢啃，后面把读书笔记整理好之后觉得还可以的话，再分享出来吧~ 3. 未来展望站在2018年的尾巴，终于完成了一年前搭建博客时立下的目标，在1年的时间里写下50篇文章。 这应该也是今年的最后一篇文章了，因为接下来工作会比较忙。 👋顺便立个Flag：接下来的一年调整文章方向，主要写算法+原理解析+项目实战，比较硬核的东西！ 最后，祝大家工作顺利！生活愉快！明年再见！👋👋👋]]></content>
      <categories>
        <category>日常说</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu使用魅族手机进行Debug]]></title>
    <url>%2Farticles%2Fubuntu_use_meizu_mobile_debug.html</url>
    <content type="text"><![CDATA[最近在使用Ubuntu系统进行Android开发 结果发现连接真机Debug的时候居然无法识别 一番折腾以后解决了问题，同时把过程记录下来。 前言由于公司的项目过大，用15年款13寸的乞丐版Macbook Pro 已经跑不动了，于是只好把项目导入到自己的PC上。 而自己又用习惯了Macbook Pro的开发环境，对于Windows的命令行实在是无法忍受了，于是给PC装了个Ubuntu 16.04. 诶，没想到Ubuntu还挺好用的。具体可以看 从Mac转投Ubuntu进行Android开发 但是，常在河边走，哪有不湿鞋。Android Studio + 模拟器 这个组合我觉得还是有点慢，想着要不试试真机，可能编译速度会快些呢，于是便接上了 魅蓝Note 6 ，开始了日常踩坑~ 无法识别手机连接手机后点击 Run 按钮，会发现手机那一项的版本是Null，运行项目的话也会失败。 在终端输入： adb devices 会看到手机是无法被识别的。这个时候就需要祭出谷歌大法了： 在硬件设备上运行应用 但是由于魅族不在谷歌的USB供应商ID列表里面，我们只能自己找办法了。 其他HTC ，Sony，ZTE，LG，Huawei，Samsung 都是有的~ 解决方案 连接电脑后在手机上选择 usb计算机连接 ** -&gt; **内置光盘 在弹出来的文件夹中选择 USB Reference Manual -&gt; 简体 打开 ADB_参考说明 一步步进行操作就可以了 注意：修改完之后不需要重启电脑，只要重启服务，然后把手机连接选项改回来就可以了 成功后的截图： 2018-12-04 Updated 一加厂商ID ： 2a70 魅族厂商ID ：2a45]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ubuntu</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Mac转投Ubuntu进行Android开发]]></title>
    <url>%2Farticles%2Fuse_ubuntu_to_develop_android.html</url>
    <content type="text"><![CDATA[Macbook Pro 13寸 乞丐版：开始撤退 I7 7700 Win 10： 猥琐发育，别浪 I5 4570 Ubuntu ：进攻敌方水晶 前言由于公司的Android项目过大，15年款13寸的乞丐版Macbook Pro 已经跑不动了，于是只好把项目导入到自己的PC上。 而自己又用习惯了Macbook Pro的开发环境，对于Windows的命令行实在是无法忍受，于是给PC装了Ubuntu 16.04. 诶，没想到Ubuntu还挺好用的，不仅速度快，开发起来还很顺手（就是有点想念渣渣辉，古天乐了），于是就把其他的开发环境都一并配上，开始用Ubuntu作为主要开发环境。 首先对三个机器对同一个项目的编译速度做个比较吧Macbook Pro 2015 Early 13 公司PCCPU：I7 7700 内存：16G DDR4 系统：Win 10 因为这篇文章是周末在家写的，就不放图片了 个人PC - Ubuntu 项目大小（Build后） 编译速度第一次编译 （包括切换分支后的第一次编译时间）Macbook Pro ： 12 min + 风扇的怒吼 公司PC：4min 30s - 6min 10s Ubuntu：1min 39s - 2min 16s Instant RunMacbook Pro ： 12 min + 风扇的怒吼 公司PC：2min 8s - 4min Ubuntu：3s 虽然公司的PC是 I7 7700 的CPU + 16G 内存，但是每次编译的时间都够我去泡个咖啡了，哪怕是Instant Run 都需要2分钟左右。再加上Macbook Pro的阵亡，我一开始对家里用了4年的PC老年机真的没抱任何希望。刚开始在Win 10 环境下的编译时间和Mac差不多，没想到换成Ubuntu后会有这么 Perfect 的表现，Perfect！ Perfect！ Perfect！ 最后上个图吧 Ubuntu下第一次编译时间： Instant Run的编译时间： 疑问Macbook Pro 2015款比不过是很正常的，但是为什么I7 7700 的 win10 PC 还会比不过i5 4570 的 Ubuntu呢… 而且这个差距不像游戏的FPS 差 5 -10 帧， 用编译时间来算的话这个差别已经是200 % - 4000%( 2min / 3s)了。 仿佛在Win10上是不存在Instant Run的，哪怕我一句代码都没有改，点击Build 和 Instant Run 的时间都需要2min以上… 总结通过这一个多月的Ubuntu使用来看，作为程序员的生产环境真是一点问题都没有，对我而言是这样的。如果需要玩游戏的话还是选择Windows吧。 而且美化过后的Ubuntu其实还是挺好看的~]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D14)-学习资料汇总]]></title>
    <url>%2Farticles%2Flearn_kotlin_day14.html</url>
    <content type="text"><![CDATA[首先祝所有程序员1024节日快乐 我们也来到了Kotlin学习之旅的最后一天 今天的主题是：学习资料汇总 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 Kotlin学习之旅(D8)-From Java to Kotlin Kotlin学习之旅(D9)-Android Extensions Kotlin学习之旅(D10)- Unit Test with Kotlin Kotlin学习之旅(D11)-第一个App之项目介绍 Kotlin学习之旅(D12)-第一个App之功能实现 Kotlin学习之旅(D13)-第一个App之功能完善 官方文档俗话说得好，官方文档就是最好的入门教程，对于有其他语言基础的开发者来说，通过官方文档来学习是最好的了，因为结构清晰，解释准确，而且保证最新的（相对书籍和视频来说）。 因此建议大家可以通过官网来学习Kotlin，除了看理论基础，Kotlin还提供了在线编辑器和代码示例 文档类 Kotlin官网 Kotlin中文站 Kotlin中文文档 Github地址 在线编程 Playground Kotlin Examples Koans PS: Koans 还提供了Android Studio的插件，直接在Plugins里面搜索Kotlin Educational Plugin安装就可以了 书籍如果是没有编程基础，或者觉得官方文档看完了还是不太懂的童鞋，我推荐你们去看看以下的书籍，因为书籍往往是作者的经验的总结，并且是通过一定的结构和顺序来组织的，不像官网文档是一个个零散的知识点，很多书籍在学习完理论以后，都会通过一个综合的Demo来运行书中学习到的知识点，这种方式更适合初学者。 《Kotlin in Action》这本书就不多介绍了，豆瓣评分*9.1分 *，每个学习Kotlin的人都应该看一遍。建议看英文，中文版的名字是《Kotlin实战》 Kotlin实战 - 京东 Kotlin实战 - 亚马逊 Kotlin实战 - 当当 Kotlin实战 - 中国图书网 有需要英文版的童鞋请自行百度，我就不放电子版的链接了 《Kotlin for Android Developers》这本书的作者是Antonio Leiva，一名Android开发者，因此从书名就可以知道，这本书就是教大家用Kotlin来开发一款Android App。由于章节讲解比较详细，因此很适合初学者。一步步从零开始，最后实现自己的第一个App，这个过程还是很有成就感的，推荐给Android开发者 因为这本书国内没有出版，而京东上原版的售价是366RMB，而且还要经常没货，所以还是自行百度吧。。 《Programming Kotlin》这本书的作者是Stephen Samuel 和 Stefan Bocutiu。两名来自英国的小哥哥。本书主要的内容包括Kotlin语言的特性，例如lambda和higher-order functions，空安全和泛型等，如果想对Kotlin这门语言有更深入的了解，可以通过这本书来学习。 总结按照我的情况来说，光靠看官网文档是不够的，最好买1-2本书一起看。我自己选择的是《Kotlin in Action》，有些官方文档写的比较简洁的知识点，可以在书中找到对应的章节，然后跟着作者的思路完成一些小例子，在实践中学习效果更好，效率也更高。 视频Youtube - Kotlin TutorialYoutube上的这个视频，我就是看着它入门的。。Kotlin Tutorial 虽然英语不够好没有全听懂，但是up主一边讲解一边敲代码，在看完官方文档之后再来看这些例子就很容易理解了。每一个视频大概就是5-10分钟，讲解一个语法/特性，零碎时间也可以跟着学~ B站- 黑马Kotlin教程B站地址：https://www.bilibili.com/video/av17644218/ 如果是在校生，时间比较充裕的话可以看这个，但是还是推荐看Youtube的，因为通过比较国内（慕课网，网易云课堂）和国外（Pluralsight , Youtube）的教学特点，发现国外的废话比较少。。整节课讲的基本上都是干货，国内的在线课程很喜欢讲理论，而且比较空洞，一个知识点照着PPT念，一下子5分钟就过去了。 其他视频Introduction to KotlinGoogle I/O 2017演讲致力于首次向人们介绍Kotlin，并提出如何改进他们的工作流程，他涵盖了许多的基础知识，并展示了一些很酷的Kotlin用法。 Life is Great and Everything Will Be Ok, Kotlin is Here第二个Kotlin演讲也是来自于Google I/O,涵盖了更多高级话题，如涉及模式，最佳实践和其他常用原则，这也揭示了使用Kotlin在生产中的意义以及作为新的语言的挑战。 使用Kotlin和Gradle更好的开发Android应用介绍了Kotlin如何适应典型的Android工作流程中现有的工具 Better Android Development with Kotlin &amp; Gradle一个非常好的8分钟教程，可以快速了解最重要的Kotlin功能，例如缩短的变量声明，lambdas和扩展功能等。 项目AnkoAnko是Jetbrains官方提供的一个让Kotlin开发更快速简单的类库，旨在使代码书写更加清晰易懂，形式上为DSL编程。 KBindingMVVM模板框架 android-topekagoogle 官方 material design 示例应用 GankClient-Kotlin用 Kotlin 实现的干货集中营客户端 总结如果是初学者，建议学习顺序为 官方文档（遇到不懂的） -&gt; Kotlin in Action -&gt; 看视频/项目加深理解 -&gt; 自己做项目 如果是老司机，建议直接看官方文档，了解基本语法和特性后就可以开始做项目了，因为很多语言特性都是想通的，只是语法上有所区别，直接上手敲代码，加深理解和巩固语法就OK了。 最最重要的一条建议： Practice make Prefect. 从10月7日国庆的最后一天，到10月24日程序员日，写下了14篇博客，记录下了自己的成长轨迹。 完成了整个Kotlin学习之旅，接下来也要继续加油~ 如果这一系列文章对大家有帮助的话，那真的是我的荣幸~ Day 14 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D13)-第一个App之功能完善]]></title>
    <url>%2Farticles%2Flearn_kotlin_day13.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第十三天 今天主要是编写代码，继续实现其他的功能 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 Kotlin学习之旅(D8)-From Java to Kotlin Kotlin学习之旅(D9)-Android Extensions Kotlin学习之旅(D10)- Unit Test with Kotlin Kotlin学习之旅(D11)-第一个App之项目介绍 Kotlin学习之旅(D12)-第一个App之功能实现 今日目标首先要说的就是，昨天我们已经完成了App基本的添加，编辑功能了，但是有一个很不方便的地方，就是App来查看笔记的时候没有办法直接查看下一条，因此今天我们要做的就是，在ActionBar加入一个Next按钮，点击按钮之后能显示下一条笔记的信息。 点击笔记 -&gt; 显示笔记内容 -&gt; 点击右上角的 ‘’&gt;’’ -&gt; 显示下一条笔记 这种交互方式对用户来说更为友好，顺便我们也能学习一下ActionBar的用法~走你 修改MenuItem 首先我们来看一下res -&gt; menu 文件夹下的 menu_main.xml文件： 12345678910&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" tools:context="com.blue.notekeeper.MainActivity"&gt; &lt;item android:id="@+id/action_settings" android:orderInCategory="100" android:title="@string/action_settings" app:showAsAction="never" /&gt;&lt;/menu&gt; 这个时候只有一个item,我们加入Next Item 12345678&lt;item android:id="@+id/action_next" android:checkable="true" android:enabled="true" android:icon="@drawable/ic_forward_white_24dp" android:title="Next" android:visible="true" app:showAsAction="ifRoom|withText" /&gt; 创建icon的方式和前面创建其他图标是一样的 drawable文件夹右键 -&gt; new -&gt; Vector Asset 在Clip Art 选项中选择 forward 把颜色设置为白色 也可以看图片： 注意：app:showAsAction=”ifRoom|withText” 的意思就是 当屏幕空间足够的时候，这个item会显示到ActionBar 具体效果大家可以运行项目，然后 切换屏幕方向 就懂了 横屏的时候Next的图标和文字都会显示出来 竖屏的时候Next只有图标显示出来，文字由于空间不足就隐藏起来了 修改MainActivityxml文件搞定以后，我们就要开始在代码中处理逻辑了 Menu提供了两个方法给我们处理menu item的相关逻辑 onPrepareOptionsMenu() - 这个方法很常见，在item被点击的时候会触发，因此我们在这里做对应的点击事件的处理 onPrepareOptionsMenu() - 这个方法可能用的比较少，在item还未初始化之前会被调用，因此我们可以在这里做一些准备工作，例如对item图标的更换，点击事件的控制等，接下来大家就知道为什么要重新这个方法了 重写onPrepareOptionsMenu()12345678910111213override fun onOptionsItemSelected(item: MenuItem): Boolean &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. return when (item.itemId) &#123; R.id.action_settings -&gt; true R.id.action_next -&gt; &#123; moveNext() true &#125; else -&gt; super.onOptionsItemSelected(item) &#125;&#125; 知识点：when 表达式 moveNext()12345private fun moveNext() &#123; ++notePosition displayNote() invalidateOptionsMenu()&#125; 每一次点击 next 按钮，我们先让记录当前笔记位置的变量notePosition +1，然后再显示下一条笔记，这个方法已经在昨天的文章里实现了，最后就是调用invalidateOptionsMenu() 方法。 重写onPrepareOptionsMenu()在没有重写这个方法之前，如果我们不停的点击next,到了最后一条笔记的时候，再点击next，app会crash，原因就是数组下标越界了。这个问题很容易解决，就是当我们已经显示了最后一条笔记时，next按钮变成一个不可点击的状态，如图： 在onPrepareOptionsMenu()方法里面，我们通过当前的位置来进行判断是否需要变更图标 123456789101112override fun onPrepareOptionsMenu(menu: Menu?): Boolean &#123; if (notePosition&gt;= DataManager.notes.lastIndex)&#123; val menuItem = menu?.findItem(R.id.action_next) if (menuItem != null)&#123; menuItem.icon = getDrawable(R.drawable.ic_block_white_24dp) menuItem.isEnabled = false &#125; &#125; return super.onPrepareOptionsMenu(menu) &#125; 如果还没到最后一条笔记，那么就显示next，否则的话就显示block，并且设置为不可点击。 关于如何生成 block icon，这里就不重复了，步骤和上面生成Next图标是一样的 最后再运行一遍App，看一下效果，应该就和Day11那篇文章开头的动图是一样的了。 总结在这个笔记App中，我们实现了以下功能： 新增笔记 查看和编辑笔记 通过Next查看下一条笔记 横竖屏切换时保存笔记状态 但是其实还有许多可以改进的地方，例如： 删除笔记（List 左滑 / 长按 / 进入编辑页面删除 等等） 优化控件（RecyclerView 替换 ListView） 优化界面（让笔记通过卡片形式展示，加入点击和过场动画，使用不同颜色的字体 等等） 优化笔记功能（可以插入图片，url，等额外的信息） 有兴趣的童鞋可以在此基础上继续开发~通过实战提高自己的技术！！ 不过我们Kotlin学习之旅的目的还是达到了，虽然只是一个简单的半成品App，通过前期学习Kotlin的语法和特性，然后到一步步写出这个App，这个过程中的成就感还是非常大的，同时也让自己对Android和Kotlin得以一直保持热度和兴趣。 明天就是Kotlin学习之旅的最后一天了，我会做一个Kotlin学习资料的总结，包括文档，博客，视频，Github的开源项目等 Day 13 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D12)-第一个App之功能实现]]></title>
    <url>%2Farticles%2Flearn_kotlin_day12.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第十二天 今天主要是Koltin编写代码，进行功能实现 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 Kotlin学习之旅(D8)-From Java to Kotlin Kotlin学习之旅(D9)-Android Extensions Kotlin学习之旅(D10)- Unit Test with Kotlin Kotlin学习之旅(D11)-第一个App之项目介绍 新建项目开发环境： MacOS Mojave Version 10.14 Android Studio 3.2 创建NoteKeeper 打开Android Studio -&gt; New Project -&gt; 输入项目名称NoteKeeper 到Add an Activity to Mobile 的时候，选择 Basic Activity 别忘了勾上 include kotlin support 完成项目创建 管理实体类我们要记录笔记，那么首先就需要有一个实体类用于记录课程，还有一个实体类用于记录笔记信息，这个时候我们可以创建一个 数据管理类 来统一管理这些实体类 创建NoteKeeperData在Java文件夹下的com.blue.notekeeper文件夹(你们的应该是各自的项目名称) 右键，new -&gt; kotlin file 创建一个名为NoteKeeperData 的Kotlin File 注意：在新建文件的时候，下面有个kind选项，我们选择的是File 而不是Class 此时我们的需求是： 课程有id，有title 笔记有title，text，还需要课程的信息 所以在NoteKeeperData里面编写代码： 123456789101112131415161718/** * author : BlueLzy * e-mail : bluehobert@gmail.com * date : 2018/10/20 09:58 * desc : */data class CourseInfo (val courseId: String, val title: String) &#123; override fun toString(): String &#123; return title &#125;&#125;data class NoteInfo(var course: CourseInfo? = null, var title: String? = null, var text: String? = null)&#123; override fun toString(): String &#123; return "课程： $course \n课题： $title \n笔记： $text" &#125;&#125; CourseInfo 和 NoteInfo 都是Data Class，然后重写toString()方法，返回我们需要的信息和指定的格式 知识点：Data Class , 字符串模板，构造函数，默认参数，空安全 数据管理类有个实体管理类，我们就可以开始加入模拟数据了 首先创建一个Kotlin Class -&gt; DataManager 定义存储数据类型我们使用HashMap来存储课程(CourseInfo)，使用ArrayList来存储笔记(NoteInfo)，因此定义两个val 12val courses = HashMap&lt;String, CourseInfo&gt;() // use courseId to find CourseInfo classval notes = ArrayList&lt;NoteInfo&gt;() // Arraylist for NoteInfo 加入模拟的课程数据我们通过courses.set() 方法加入数据 这里有好几种方式，还记得我们的CourseInfo类吗 1class CourseInfo (val courseId: String, val title: String) 我们实例化一个CourseInfo对象的时候，需要传入courseId 和 title 两个参数，但是传参也有好几种方式 不指定参数名，指定参数名，指定参数名但是不按顺序 都是没问题的，可以看代码注释 1234567891011121314 var course = CourseInfo("android_intent", "使用Intent进行Activity跳转") courses.set(course.courseId,course) // 指定参数名 course = CourseInfo(courseId = "android_async", title = "Android中的异步编程") courses.set(course.courseId, course) // title 作为第一个参数 course = CourseInfo(title = "Java 基础", courseId = "java_lang") courses.set(course.courseId, course)// 不指定参数名 course = CourseInfo("java_core", "Java 核心编程") courses.set(course.courseId, course) 加入模拟的笔记数据12345678910111213141516171819202122232425262728293031var course = courses["android_intent"]!! var note = NoteInfo(course, "我是Intent笔记", "Intent里面可以传值，通过这种方式和其他页面交互") notes.add(note) note = NoteInfo(course, "Intent 的方式", "除了普通的Intent，还有PendingIntents") notes.add(note) course = courses["android_async"]!! note = NoteInfo(course, "Service 的使用", "Service 主要是运行在哪个线程？") notes.add(note) note = NoteInfo(course, "Service 的类型", "前台Service和后台Service") notes.add(note) course = courses["java_lang"]!! note = NoteInfo(course, "集合", "List，Array，Map等") notes.add(note) note = NoteInfo(course, "面向对象", "是不是这样我们就不怕找不到对象了？") notes.add(note) course = courses["java_core"]!! note = NoteInfo(course, "编译选项", "-jar 不兼容 -cp 命令") notes.add(note) note = NoteInfo(course, "序列化", "记得包含 SerialVersionUID ") notes.add(note) DataManager完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.blue.notekeeper/** * author : BlueLzy * e-mail : bluehobert@gmail.com * date : 2018/10/20 10:00 * desc : Manage the data */object DataManager &#123; val courses = HashMap&lt;String, CourseInfo&gt;() // use courseId to find CourseInfo class val notes = ArrayList&lt;NoteInfo&gt;() // Arraylist for NoteInfo // 构造函数，进行私有属性的初始化，通常是代码块 init &#123; initializeCourses() initializeNotes() &#125; // 私有的初始化方法 private fun initializeCourses() &#123; var course = CourseInfo("android_intent", "使用Intent进行Activity跳转") courses.set(course.courseId,course) // 指定参数名 course = CourseInfo(courseId = "android_async", title = "Android中的异步编程") courses.set(course.courseId, course) // title 作为第一个参数 course = CourseInfo(title = "Java 基础", courseId = "java_lang") courses.set(course.courseId, course) // 不指定参数名 course = CourseInfo("java_core", "Java 核心编程") courses.set(course.courseId, course) &#125; // 初始化Notes数据 private fun initializeNotes()&#123; var course = courses["android_intent"]!! var note = NoteInfo(course, "我是Intent笔记", "Intent里面可以传值，通过这种方式和其他页面交互") notes.add(note) note = NoteInfo(course, "Intent 的方式", "除了普通的Intent，还有PendingIntents") notes.add(note) course = courses["android_async"]!! note = NoteInfo(course, "Service 的使用", "Service 主要是运行在哪个线程？") notes.add(note) note = NoteInfo(course, "Service 的类型", "前台Service和后台Service") notes.add(note) course = courses["java_lang"]!! note = NoteInfo(course, "集合", "List，Array，Map等") notes.add(note) note = NoteInfo(course, "面向对象", "是不是这样我们就不怕找不到对象了？") notes.add(note) course = courses["java_core"]!! note = NoteInfo(course, "编译选项", "-jar 不兼容 -cp 命令") notes.add(note) note = NoteInfo(course, "序列化", "记得包含 SerialVersionUID ") notes.add(note) &#125;&#125; 数据展示页-NoteListActivity在完成了所需要的实体类和模拟数据之后，我们终于可以进入到界面的编写阶段了，首先创建NoteListActivity 我们通过这种方式来创建： 然后选择 Empty Activity 就可以了，Android Studio会自动帮我们生成 继承自CompatActivity的NoteListActivity文件 activity_note_list.xml文件 OK，让我们进入activity_note_list.xml，把代码改成： activity_note_list.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".NoteListActivity"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:popupTheme="@style/AppTheme.PopupOverlay" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout="@layout/content_note_list" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="@dimen/fab_margin" app:srcCompat="@drawable/ic_add_white_24dp" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 然后再创建一个名为: content_note_list的xml文件，代码为： content_note_list.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" tools:context=".MainActivity" tools:showIn="@layout/activity_main"&gt; &lt;Spinner android:id="@+id/spinner" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginStart="32dp" android:layout_marginTop="16dp" android:layout_marginEnd="32dp" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;EditText android:id="@+id/textNoteTitle" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:ems="10" android:hint="@string/note_title_hint" android:inputType="textMultiLine" app:layout_constraintEnd_toEndOf="@+id/spinner" app:layout_constraintStart_toStartOf="@+id/spinner" app:layout_constraintTop_toBottomOf="@+id/spinner" /&gt; &lt;EditText android:id="@+id/textNoteText" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:ems="10" android:hint="@string/note_text_hint" android:inputType="textMultiLine" app:layout_constraintEnd_toEndOf="@+id/spinner" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintStart_toStartOf="@+id/spinner" app:layout_constraintTop_toBottomOf="@+id/textNoteTitle" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 然后，编写NoteListActivity的代码 123456789101112class NoteListActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_note_list) setSupportActionBar(toolbar) listNotes.adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, DataManager.notes) &#125;&#125; 最后，修改我们的AndroidMainfest.xml文件，让NoteListActivity成为启动项 12345678910111213&lt;activity android:name=".MainActivity" android:label="@string/edit_note" android:theme="@style/AppTheme.NoActionBar"/&gt; &lt;activity android:name=".NoteListActivity" android:label="@string/app_name" android:theme="@style/AppTheme.NoActionBar"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 一切就绪，此时运行App，看到的效果应该是这样的： 只有一个ListView用于展示模拟数据，FAB和Item都没有点击效果，接下来我们要往里面加入其它功能了。 新建笔记修改NoteListActivity在NoteListActivity加入FAB和Item的点击事件，跳转到MainActivity 在onCreate方法加上： 1234567891011fab.setOnClickListener &#123; view -&gt; val activityIntent = Intent(this, MainActivity::class.java) startActivity(activityIntent) &#125; listNotes.setOnItemClickListener&#123; parent, view, position, id -&gt; val activityIntent = Intent(this, MainActivity::class.java) activityIntent.putExtra(NOTE_POSITIONI, position) startActivity(activityIntent) &#125; 创建名为Constants的Kotlin FileNOTE_POSITIONI 和 POSITION_NOT_SET 是无关界面的常量，因此我们需要创建一个文件来保存，这样可以方便管理，代码的结构也会比较清晰。 加入以下代码： 12const val NOTE_POSITIONI = "NOTE_POSITIONI"const val POSITION_NOT_SET = -1 到目前为止，数据列表页的工作就完成了，接下来就是跳转后的编辑页面的工作 修改MainActivity我们现在回到MainActivity，把MainActivity当成是新建和编辑笔记的页面。首先修改布局文件activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:popupTheme="@style/AppTheme.PopupOverlay" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout="@layout/content_main" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 然后修改content_main 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" tools:context=".MainActivity" tools:showIn="@layout/activity_main"&gt; &lt;Spinner android:id="@+id/spinner" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginStart="32dp" android:layout_marginTop="16dp" android:layout_marginEnd="32dp" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;EditText android:id="@+id/textNoteTitle" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:ems="10" android:hint="@string/note_title_hint" android:inputType="textMultiLine" app:layout_constraintEnd_toEndOf="@+id/spinner" app:layout_constraintStart_toStartOf="@+id/spinner" app:layout_constraintTop_toBottomOf="@+id/spinner" /&gt; &lt;EditText android:id="@+id/textNoteText" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:ems="10" android:hint="@string/note_text_hint" android:inputType="textMultiLine" app:layout_constraintEnd_toEndOf="@+id/spinner" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintStart_toStartOf="@+id/spinner" app:layout_constraintTop_toBottomOf="@+id/textNoteTitle" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 由于布局不是我们的重点，所以在这里编写和调整的过程就先忽略，大家只要能看懂大概是什么意思就可以了 OK，回到MainActivity 我们需要处理几个事情： 判断进来的是新笔记还是旧笔记 新笔记不用处理 旧笔记需要把数据放到对应的位置 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MainActivity : AppCompatActivity() &#123; private var notePosition = POSITION_NOT_SET // 定义变量记录当前位置 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) val coursesAdapter = ArrayAdapter&lt;CourseInfo&gt;(this, android.R.layout.simple_spinner_item, DataManager.courses.values.toList()) coursesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item) spinner.adapter = coursesAdapter notePosition = savedInstanceState?.getInt(NOTE_POSITIONI, POSITION_NOT_SET) ?: intent.getIntExtra(NOTE_POSITIONI, POSITION_NOT_SET) // 判断是否点击进来的Item，是的话填充数据 if (notePosition != POSITION_NOT_SET) displayNote() else &#123; DataManager.notes.add(NoteInfo()) notePosition = DataManager.notes.lastIndex &#125; &#125; override fun onSaveInstanceState(outState: Bundle?) &#123; super.onSaveInstanceState(outState) outState?.putInt(NOTE_POSITIONI, notePosition) &#125; private fun displayNote() &#123; // 设置 textView 填充内容 val note = DataManager.notes[notePosition] textNoteTitle.setText(note.title) textNoteText.setText(note.text) // 设置 spinner val coursePosition = DataManager.courses.values.indexOf(note.course) spinner.setSelection(coursePosition) &#125; override fun onPause() &#123; super.onPause() saveNote() &#125; private fun saveNote() &#123; val note = DataManager.notes[notePosition] note.title = textNoteTitle.text.toString() note.text = textNoteText.text.toString() note.course = spinner.selectedItem as CourseInfo &#125;&#125; 我们除了处理新建/编辑笔记两种情况，还做了一点特殊处理 通过onPause()保存数据 通过onSaveInstanceState()保存状态 OK，这个时候再运行一下App，效果应该是： 进入App通过列表形式展示模拟数据 点击FAB进入一个新的页面，填入数据后返回，在列表页可以看到新增笔记 点击列表中的任意一项，进入编辑页面，笔记数据在对应位置展示出来 总结其实到这里我们就已经完成了大部分的功能了，明天我们主要的任务就是在ActionBar上加入一个Next按钮，可以查看下一条笔记，这个功能有利于提高用户体验，这种交互也是Android官方所提倡的，通过按钮或者手势来进行交互。 Day 12 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>App开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D11)-第一个App之项目介绍]]></title>
    <url>%2Farticles%2Flearn_kotlin_day11.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第十一天 接下来这三天，我们会用Kotlin编写一个记事本App 今天主要是项目介绍 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 Kotlin学习之旅(D8)-From Java to Kotlin Kotlin学习之旅(D9)-Android Extensions Kotlin学习之旅(D10)- Unit Test with Kotlin 项目简介我们接下来要做的App是一个简单的笔记类app 老规矩，先上图： 主要的功能： 查看已有的笔记 添加新的笔记 编辑已有的笔记 能够通过Action Bar查看下一条笔记 暂时没有完成的功能点： 缓存添加的笔记（目前退出App后数据会被清空，由于需要使用ORM，而且和Kotlin无关，所以这里暂时舍弃了） 删除已有的笔记（理由同上） 通过这个App学习到的技能包括： 通过Intent进行Activity跳转 Intent中传递参数 Action Bar 和 Menu的使用 CoordinatorLayout onSaveInstanceState保存状态 Kotlin 基础语法和特性 分解需求查看已有的笔记首先我们在App里面加入一些假数据，然后通过ListView进行展示，这里选择ListView的原因很简单，就是因为简单。我们不需要额外的元素，也不需要复杂的布局，有兴趣的童鞋可以改成用RecyclerView来进行展示。 那么这个功能我们就需要用到： ListView 编辑已有的笔记首先通过ListView进行展示，点击每一条笔记的时候，我们跳转到详情页，也就是编辑页面，把对应的课题，笔记都显示到EditText中，然后可以进行编辑和保存 那么这个功能需要用到： setOnItemClickListener -&gt; 监听点击的item startActivity -&gt; 跳转到编辑页面 intent.putIntExtra() -&gt; 把点击的位置传给编辑页面，从而获取对应的笔记内容 添加新的笔记如果大家有留意上面的Gif图，可以看到在主界面的右下角，有一个FAB，也就是FloatingActionButton ，我们新建笔记的功能可以通过这个按钮来完成 这个功能需要用到： startActivity -&gt; 复用编辑页面 vector drawable -&gt; 修改FAB的icon 通过Action Bar查看下一条笔记从主界面跳转到编辑页面以后，如果我们想要看其他的笔记，只能返回然后再点击对应的，这样的交互对用户来说不太友好，因此我在Action Bar加了一个Next的按钮，用于查看下一条笔记 这个功能需要用到： ActionBar 的Menu vector drawable 未完成的功能缓存笔记 &amp; 删除笔记大家可以使用Android官方推荐的Room作为ORM，我在之前的项目中使用过，觉得还是挺方便的 Android Developers For Room Android Room概述 当然使用其他ORM也是可以滴~ 总结这个App比较简单，但是由于我的个人时间也不是很多，每天下班回到家，吃完晚饭都是8点以后了，除了完成代码编写还要写成文章进行总结，所以只能分开3天来完成。希望大家谅解~ 接下来的两天就是代码编写的时间了~加油 Day 11 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>App开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D10)- Unit Test with Kotlin]]></title>
    <url>%2Farticles%2Flearn_kotlin_day10.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第十天 今天的主题是 - - Unit Test with Kotlin 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 Kotlin学习之旅(D8)-From Java to Kotlin Kotlin学习之旅(D9)-Android Extensions 添加JUnit依赖Kotlin里面的Unit Test 和 java里面大同小异，因此我们直接上手写一个测试就能掌握了。 说到Unit Test，就不得不提一下JUnit了，这是一个第三方库，用途就是跑测试用例。因此天才第一步，我们需要在build.gradle里面添加依赖 1234dependencies &#123; ... testImplementation "junit:junit:4.12"&#125; 记得依赖方式是testImplementation，这样在打正式包的时候这个依赖被不会编译，可以减少APK的体积 实际上，在我们新建一个Android项目的时候，Android Studio会自动帮我们生成三个文件夹，分别是 code test androidTest test 和 androidTest 文件夹就是我们编写Unit Test的地方 Unit Test 例子让我们在 test 文件夹下创建一个名为MyTest的文件： 1234567class MyTest &#123; @Test fun proof_of_concept() &#123; assertEquals(4 , 2 + 2) &#125;&#125; 这个时候看到左边有个绿色的箭头，点一下就能运行Unit Test 运行结果如下： 可以看到我们写的这个Unit Test通过了，这就是一个最简单的例子，那么代码里面写的每一句是什么意思呢？ @Test - 这个注解表示接下来的方法是一个Unit Test 方法，通过上面的import信息也能看出来，这个注解是属于JUnit的 assertEquals(4, 2+2) - 这行代码表示 判断 4 是否等于 2+2，assertEquals方法同样也是JUnit里面的方法 所以这段代码的执行结果很明显是相等的，因此测试通过。 除了assertEquals，JUnit还提供了其他许多的判断方法 关于JUnit的一切详情都可以从这里找到：JUnit 5 User Guide 另外推荐一个学习JUnit的网站：极客学院JUnit测试框架 Unit Test in Android经过简单的介绍，我们已经知道了什么是Unit Test，如果还不太清楚的话，可以看一下以下几篇文章： 首先是关于TDD （Test-driven development）- 测试驱动开发 简单介绍就是：先写测试程序，然后编码实现功能，使得测试程序能够顺利运行的一种开发方法。 测试驱动开发-维基百科 浅谈测试驱动开发（TDD） Why Use Test-Driven Development? 然后是关于Unit Testing的： Unit testing - Wikipedia Unit Testing - Fundamentals 虽然在实际开发过程中，我们很少会使用TDD的方式进行项目开发，但是编写Unit Test还是有它的好处的，因此在Android开发里面，我们也需要掌握这项技能。 Let’s do it. 在Android里面进行测试，经常需要用到另外一个依赖库，叫做Mockito，那么下面我们就使用这个库来做个最简单的Unit Test 为什么要用Mockito在JUnit中，我们可以验证有返回值方法是否正确，但是如果一个方法的返回值为void，也就是没有返回值，特别是这个方法是为了调用另外一个方法，那么这个时候就需要验证这个方法有没有被调用。我们就可以通过Mockito这个框架来验证。 怎么使用Mockito在build.gradle文件中加入： 1testImplementation "org.mockito:mockito-core:2.18.3" 在我们在MyTest文件中加入以下代码： 12345678910@Testfun mockito_test() &#123; val mockedList = mock(mutableListOf&lt;String&gt;().javaClass) //using mock object mockedList.add("one") mockedList.clear() //verification verify(mockedList).add("one") verify(mockedList).clear()&#125; 运行结果如下： 这个例子是不是特别简单，它来自Mockito的官方，其实学习这些第三方框架，最好的教程就是他们的官方文档，因此这里我把几个不错的学习Mockito的资源列一下： Mockito 官网 Mockito Github 地址 Mocking-and-verifying Unit tests with Mockito - Tutorial 上面这个例子首先通过mock()创建List类，然后在mockedList中添加元素one，最后通过verify来验证mockedList有没有成功调用List里面的对应方法。我们一个个来看： 验证方法调用通过verify 来验证方法是否被调用，例如： 12345678910111213141516171819202122mockedList.add("once")mockedList.add("twice")mockedList.add("twice")mockedList.add("three times")mockedList.add("three times")mockedList.add("three times")//following two verifications work exactly the same - times(1) is used by defaultverify(mockedList).add("once");verify(mockedList, times(1)).add("once")//exact number of invocations verificationverify(mockedList, times(2)).add("twice")verify(mockedList, times(3)).add("three times")//verification using never(). never() is an alias to times(0)verify(mockedList, never()).add("never happened")//verification using atLeast()/atMost()verify(mockedList, atLeastOnce()).add("three times")verify(mockedList, atLeast(2)).add("three times")verify(mockedList, atMost(5)).add("three times") 在verify 方法中，我们可以指定方法调用的次数，通过times(1) 的形式，大家有兴趣的话可以跑一下上面的代码，看一下测试能不能通过。 stubbing指定方法的实现除了空方法，我们有时候还需要检验方法的返回值或者实现。这个时候就需要用到when方法 看一个例子： 1234567891011121314151617181920//You can mock concrete classes, not just interfaces val mockedList = mock(LinkedList::class.java) //stubbing `when`(mockedList.get(0)).thenReturn("first") `when`(mockedList.get(1)).thenThrow(RuntimeException()) //following prints "first" System.out.println(mockedList.get(0)) //following throws runtime exception System.out.println(mockedList.get(1)) //following prints "null" because get(999) was not stubbed System.out.println(mockedList.get(999)) //Although it is possible to verify a stubbed invocation, usually it's just redundant //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed). //If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See here. verify(mockedList).get(0) 这个例子的运行结果是： 为什么会失败呢？ 因为有这么一行代码 1`when`(mockedList.get(1)).thenThrow(RuntimeException()) 当mockedList.get(1)的时候，我们让他抛出异常，因此运行的结果就是我们写的RuntimeException。 所以when 方法是不是很有用呢，有点像if..else 和 switch…case 的体系，可以通过不同的参数来控制测试方法对应的结果。 除了方法的运行结果可以控制以外，我们还可以测试方法的参数 参数匹配例子： 123456789val mockedList = mock(LinkedList::class.java)//stubbing using built-in anyInt() argument matcher`when`(mockedList[anyInt()]).thenReturn("element")//following prints "element"System.out.println(mockedList[999])//you can also verify using an argument matcherverify(mockedList)[anyInt()] 这个例子的运行结果是pass，因为我们需要的参数是anyInt()，verify的时候参数也是anyInt()。 注意：当你使用参数匹配的时候，所有的参数都必须是可匹配的，什么意思呢？看例子： 123456verify(mock).someMethod(anyInt(), anyString(), eq("third argument"));//above is correct - eq() is also an argument matcherverify(mock).someMethod(anyInt(), anyString(), "third argument");//above is incorrect - exception will be thrown because third argument is given without an argument matcher. 第一行代码是正确的，因为eq()也是一种匹配模式，但是第二行代码直接传入一个String就不是匹配模式，在这里会抛出异常。 最后，由于Mockito的功能十分强大，因此在这里我也只是简单介绍一些常见的用法，对Mockito有一个初步的认识，其他的在需要的时候再去官方文档学习就可以了。 Mockito官方文档：Mockito Docs 总结除了这篇文章里面说到的JUnit，Mockito这两个框架，我们还有可能需要用到一个叫做Robolectric 的框架，这个框架是用来测试运行在JVM上的Android代码的，不过由于暂时我们还接触不到，所以这里就不讲了，在后面进行项目实战的时候如果有需要，我们再去学习~ 到目前为止，使用Kotlin开发Android项目所需要的基本知识都已经学完了，那么接下来就是实战阶段！加油！ Day 10 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D9)-Android Extensions]]></title>
    <url>%2Farticles%2Flearn_kotlin_day9.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第九天 今天的主题是 - -Android Extensions 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 Kotlin学习之旅(D8)-From Java to Kotlin Android Extensions 是什么Kotlin Android Extensions 是 Kotlin 团队开发的一个插件，目的是让我们在开发过程中可以减少代码的编写量。主要的功能就是：视图绑定 在Java中，我们经常要写的一句代码就是 findViewById()，但是在一个Layou有许多View存在的情况下，重复写这句代码不仅工作量大，而且可读性差，因此各路大神发挥智慧，推出了许多的第三方库，其中最著名的就是ButterKnife了 ，但是使用ButterKnife有个不好的地方，就是需要定义成员变量，代码量和原生的方式差不多。 现在 Kotlin Android Extensions 能够提供与这些开源库功能相同的体验，并且不需要添加任何额外代码。 Android Extensions 怎么用1.在Moudle中的build.gradle文件添加插件配置1apply plugin: &apos;kotlin-android-extensions&apos; 2. 在View中引入资源文件1import kotlinx.android.synthetic.main.activity_main.* 3.访问id12345678910111213import kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 1 btn_login.setOnClickListener &#123; Toast.makeText(this@MainActivity,"Android Extensions test",Toast.LENGTH_SHORT).show() &#125; &#125;&#125; 通过btn_login.setXXX 的方式来访问view，并且调用view相关方法，不需要写findViewById() import格式import格式是这样的：kotlinx.android.synthetic.main.布局名称.*。需要注意的是include进来的布局，也是需要通过import导入相应布局，这样才能正常使用。 ViewHolder 使用Extensions刚开始的时候Extensions是不支持在ViewHolder中使用视图绑定的，因此还是需要些findViewById，但是从Kotlin 1.1.4起，Extensions加入了增强功能，由于这项功能还未正式发布，因此需要开启实验标志 ####1.开启experimental 在Module的build.gradle文件中设置： 123androidExtensions &#123; experimental = true&#125; 2.编写ViewHolder12345678910111213import android.support.v7.widget.RecyclerViewimport android.view.Viewimport kotlinx.android.extensions.LayoutContainerimport kotlinx.android.synthetic.main.activity_main.*class ViewHolder constructor(override val containerView: View?) : RecyclerView.ViewHolder(containerView), LayoutContainer &#123; // 1 fun setContent(str: String) &#123; helloTv.text = str // 2 &#125;&#125; 实现LayoutContainer 使用helloTv.text 3. 什么是LayoutContainer在Activity，Fragment，View中我们知道import对应的layout就可以了，但是像ViewHolder这些特殊的，我们就需要通过实现LayoutContainer接口，接口返回一个containerView，按照字面意思理解就是内容视图，这个containerView就包含了ViewHolder里面的所有子View，因此可以直接使用view.setxxx / view.property 的写法 Android多渠道版本Android Extensions 插件支持Android 多渠道版本，假如在你的build.gradle中有一个名为free的版本 1234567android &#123; productFlavors &#123; free &#123; versionName "1.0-free" &#125; &#125;&#125; 然后你就可以通过如下方式导入针对free/res/layout/activity_free.xml的所有生成的属性。 1import kotlinx.android.synthetic.free.activity_free.* 内部原理Kotlin Android Extensions 是一个Kotlin编译器插件。它执行下面两个操作： 为每一个Kotlin Activity添加一个隐藏的缓存方法和一个域。这个方法相当之小，基本不会增加APK 的大小。 用方法调用替换每一个属性调用。 例如： 1234class MyActivity: Activity()fun MyActivity.a() &#123; this.textView.setText(“”) &#125; 总结Kotlin Android Extensions 的主要功能其实就是视图绑定，但是这一个功能也可以减少许多重复代码的编写，因此有机会还是把这个插件用上吧~ Day 9 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D8)-From Java to Kotlin]]></title>
    <url>%2Farticles%2Flearn_kotlin_day8.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第八天 今天的主题是：From Java to Kotlin 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 Kotlin学习之旅(D7)-Kotlin Idioms part 2 学习资源Kotlin官网在线学习课程（需要翻墙）：Kotlin Koans kotlin中文(不需要翻墙)：Kotlin语言中文站 Github学习资源 : From Java To Kotlin kotlin必备知识： Learn Kotlin - lateinit vs lazy Learn Kotlin - apply vs with Learn Kotlin - Data Class Learn Kotlin - Destructuring Declarations Learn Kotlin - Extension Functions Learn Kotlin - Sealed Classes 首先如果是有Java基础的童鞋，推荐直接从官网文档上手，可以快速学习Kotlin这门语言的特性和用法。 如果是零基础的童鞋，那么推荐看视频+看书，一般都是直接在youtube上搜索kotlin就可以找到很有有用的视频了，书籍的话推荐《Kotlin in Action》 这两天的任务比较轻松，因为From Java to Kotlin 其实在前面我们讲语法和习惯用法的时候，基本上都已经见过了，这里其实只是相当于再复习一遍，而且上面的 From Java To Kotlin已经很全了，我就把自己不太熟练的摘录下来。 常见区别NullJava 123if(text != null)&#123; int length = text.length();&#125; Kotlin 123val length = text?.lengthval length = text!!.length // NullPointerException if text == null ？：可以为空，但是如果没做非空判断，在编译的时候会报错 !!.：可以为空，编译的时候也不会报错，但是运行的时候有可能会NPE Strings IIJava 123String text = "First Line\n" + "Second Line\n" + "Third Line"; Kotlin 12345val text = """ |First Line |Second Line |Third Line""".trimMargin() Kotlin里面通过 &#39;&#39;&#39; 来表示多行字符串，通过 | 来表示换行 Bits OperationsJava 12345final int andResult = a &amp; b;final int orResult = a | b;final int xorResult = a ^ b;final int rightShift = a &gt;&gt; 2;final int leftShift = a &lt;&lt; 2; Kotlin 12345val andResult = a and bval orResult = a or bval xorResult = a xor bval rightShift = a shr 2val leftShift = a shl 2 Java 和 Kotlin 的位操作符 CollectionsJava 123456789for (int number : numbers) &#123; System.out.println(number);&#125;for (int number : numbers) &#123; if(number &gt; 5) &#123; System.out.println(number); &#125;&#125; Kotlin 123456numbers.forEach &#123; println(it)&#125;numbers.filter &#123; it &gt; 5 &#125; .forEach &#123; println(it) &#125; Kotlin通过 filter{x &gt; 5} 来表示 Java里面的 if(x &gt; 5) 这个条件语句的区别需要注意 Constructors Java 12345678910public class Utils &#123; private Utils() &#123; // This utility class is not publicly instantiable &#125; public static int getScore(int value) &#123; return 2 * value; &#125;&#125; Kotlin 1234567891011121314class Utils private constructor() &#123; companion object &#123; fun getScore(value: Int): Int &#123; return 2 * value &#125; &#125;&#125;// another wayobject Utils &#123; fun getScore(value: Int): Int &#123; return 2 * value &#125;&#125; Java：通过 静态方法 来实现工具类 Kotlin：一切皆是对象，通过 companion object / ojbect utils 来实现工具类 Class methods Java 12345678910111213public class Utils &#123; private Utils() &#123; // This utility class is not publicly instantiable &#125; public static int triple(int value) &#123; return 3 * value; &#125;&#125;int result = Utils.triple(3); Kotlin 12345fun Int.triple(): Int &#123; return this * 3&#125;var result = 3.triple() Java：通过static实现类方法 Kotlin：通过扩展函数实现类方法 enum Java 12345678910111213141516public enum Direction &#123; NORTH(1), SOUTH(2), WEST(3), EAST(4); int direction; Direction(int direction) &#123; this.direction = direction; &#125; public int getDirection() &#123; return direction; &#125; &#125; Kotlin 12345678910111213enum class Direction constructor(direction: Int) &#123; NORTH(1), SOUTH(2), WEST(3), EAST(4); var direction: Int = 0 private set init &#123; this.direction = direction &#125;&#125; 总结一开始以为From Java to Kotlin 要讲两天的，因为我是先大致浏览了一遍官方文档，然后做的学习计划，结果发现经过前面的学习，对Kotlin的语法掌握了的情况下，其实很多Java和kotlin之间的区别都已经很熟悉了，强烈推荐大家去看看 From Java To Kotlin，就当是一个复习/总结，加深对Kotlin语法的熟悉。 明天开始正式进入Kotlin in Android 的学习，这个才是我们Kotlin学习之旅的重点。 Day 8 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D7)-Kotlin Idioms part 2]]></title>
    <url>%2Farticles%2Flearn_kotlin_day7.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第七天 今天的主题是：Kotlin中的习惯用法-第二部分 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 Kotlin学习之旅(D6)-Kotlin Idioms part 1 今日目标 使用表达式 静态方法 使用命名参数替代setter 使用apply() 处理可空对象 使用as替代is 快速创建JSON 使用表达式通过使用Lambda表达式，我们可以减少很多的代码量，同时也会牺牲可读性，但是我们还是鼓励使用表达式 举个栗子： 12345678910111213fun getDefaultLocale(deliveryArea: String): Locale &#123; val deliverAreaLower = deliveryArea.toLowerCase() if (deliverAreaLower == "germany" || deliverAreaLower == "austria") &#123; return Locale.GERMAN &#125; if (deliverAreaLower == "usa" || deliverAreaLower == "great britain") &#123; return Locale.ENGLISH &#125; if (deliverAreaLower == "france") &#123; return Locale.FRENCH &#125; return Locale.ENGLISH&#125; 这个函数的目的是为了获取正确的地区，在函数体中做了很多的判断，每一个需要接手的人都要重新过一遍逻辑，但是由于大量的if，读一遍代码的速度会变慢，时间自然就会变长，那么使用表达式的效果是怎么样的呢？ 123456fun getDefaultLocale2(deliveryArea: String) = when (deliveryArea.toLowerCase()) &#123; "germany", "austria" -&gt; Locale.GERMAN "usa", "great britain" -&gt; Locale.ENGLISH "france" -&gt; Locale.FRENCH else -&gt; Locale.ENGLISH&#125; 没错，只要6行，就能达到和上面13行代码一样的效果，并且可读性上面我觉得还提升了。因为人的大脑是习惯有关联的东西，when表达式其实就是把并列的条件一个个列出来，对于读代码的人来说是很好理解的。 因此，考虑多使用 when 而不是if 静态方法在Kotlin里面，没有提供static关键字让我们定义静态的变量，方法，类，但是我们可以通过别的方式来实现 1.通过Object关键字123object MyUtil &#123; fun changeAnswer(string: String) : Int &#123; ... &#125;&#125; 使用： 1MyUtil.changeAnswer("test") 2.通过扩展函数这个在昨天的 Kotlin学习之旅(D6)-Kotlin Idioms part 1 已经讲过了，所以这里就不再重复了。 使用命名参数替代setter在Java里面，我们通过setXXX这样的命名方法来区分每个参数 12345val config = SearchConfig() .setRoot("~/folder") .setTerm("kotlin") .setRecursive(true) .setFollowSymlinks(true) 在Kotlin里面，我们通过直接给参数命名~ 123456val config2 = SearchConfig2( root = "~/folder", term = "kotlin", recursive = true, followSymlinks = true) 简洁又明了：参数名 = &quot;参数值&quot; 使用apply()这个用法和上面的差不多 12345678val dataSource = BasicDataSource()dataSource.driverClassName = "com.mysql.jdbc.Driver"dataSource.url = "jdbc:mysql://domain:3309/db"dataSource.username = "username"dataSource.password = "password"dataSource.maxTotal = 40dataSource.maxIdle = 40dataSource.minIdle = 4 常规操作是这样的，那么Kotlin有什么骚操作呢？ 123456789val dataSource = BasicDataSource().apply &#123; driverClassName = "com.mysql.jdbc.Driver" url = "jdbc:mysql://domain:3309/db" username = "username" password = "password" maxTotal = 40 maxIdle = 40 minIdle = 4&#125; 同样的道理，通过apply() 后面也是 参数名 = &quot;参数值&quot; 就搞定了 处理可空对象大家都知道，Kotlin默认是空安全的，但是也支持可空对象，那么如果对象是可为空的，在使用的时候我们就需要判断是否为空 1234if (order == null || order.customer == null || order.customer.address == null)&#123; throw IllegalArgumentException("Invalid Order")&#125;val city = order.customer.address.city 这是很常见的一种写法，但是如果大量使用，特别是在解析JSON的时候，就会让人觉得做了大量重复的工作，在Kotlin中,我们鼓励用这种写法： 1val city = order?.customer?.address?.city ?: throw IllegalArgumentException("Invalid Order") 通过 ? 来判断是否为空，如果为空会直接抛出异常，避免写大量的if 和 xxx == null 使用as替代is同样的，我们在kotlin里面常用的判断还有 is 1234if (service !is CustomerService) &#123; throw IllegalArgumentException("No CustomerService")&#125;service.getCustomer() 在这里我们可以通过as 来替换 12service as? CustomerService ?: throw IllegalArgumentException("No CustomerService")service.getCustomer() 反正出发点就是减少if语句的使用，提高代码的可读性，顺便还能减少代码量 快速创建JSON这个功能也是非常有用的，毕竟写单元测试的时候需要模拟测试数据~ 12345678910val customer = mapOf( "name" to "Clair Grube", "age" to 30, "languages" to listOf("german", "english"), "address" to mapOf( "city" to "Leipzig", "street" to "Karl-Liebknecht-Straße 1", "zipCode" to "04107" )) 通过 参数名 to 参数值 这样的形式来创建JSON，不仅仅是String，Int等常用的数据类型，包括map，list都可以创建，是不是很方便呢？ 总结在Day 6 和 Day 7 里面我们总结了一些Kotlin的习惯用法，多加练习，掌握这些用法可以提高我们的开发效率，并且促使我们写出好的代码。 接下里就要进入到Java to Kotlin 的学习里面啦，其实经过了前面Kotlin的语法，用法的学习，对于Kotlin这门语言的常用知识点都了解得差不多了，加油💪 Day 7 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D6)-Kotlin Idioms part 1]]></title>
    <url>%2Farticles%2Flearn_kotlin_day6.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第六天 今天的主题是：Kotlin中的习惯用法-第一部分 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 Kotlin学习之旅(D5)-高级语法 习惯用法 创建DTOs 函数的默认参数 过滤list String字符串模板 类型判断 遍历Map 扩展函数 创建单例 —————————————————— Part 1 使用表达式 静态方法 使用命名参数替代setter 使用apply() 处理可空对象 使用as替代is 快速创建JSON 创建DTOs在Android中，我们经常需要创建Bean，也就是包括了setter,getter,toString等常见代码的一种类，一般用于接收后台返回的JSON格式的数据，在Kotlin里面，我们可以用很简单的语法完成Bean类的编写： 1data class Customer(val name: String, val email: String) 我们定义了一个Customer类，构造方法传入两个参数name, email，这个类包括以下方法： 所有属性的 getters （对于 var 定义的还有 setters） equals() hashCode() toString() copy() 在Kotlin中，这种类也叫做数据类，data class，一个关键字即可完成之前在Java里面需要写的大量模板代码，是不是很方便呢？ 函数的默认参数这个之前在讲函数的时候也提到过，可以减少重载方法的数量 1fun foo(a: Int = 0, b: String = "")&#123;...&#125; 这里定义了一个foo函数，传入a，b两个参数，其中a的默认值为0，b的默认值为空字符串 那么在调用foo的时候，我们可以直接写 1foo() 不传a，b的话，就使用默认值进行运算。 过滤list1val positives = list.filter &#123; x -&gt; x &gt; 0 &#125; 或者可以更短: 1val positives = list.filter &#123; it &gt; 0 &#125; String字符串模板这个之前也提到过，就是在字符串里面，加入其它的字符串变量，在Java中，需要通过format函数来进行赋值，在kotlin中也是变得更加简洁： 1println("Name $name") $ 加上 变量名 就可以实现在String中插入变量的功能 类型判断这个特性是经常会用到的，例如在解析JSONObject，或者是需要把JSON转成需要的数据类型时，以前的写法 123456789if(json.getXXX != null)&#123; if (json.getXXX instanceOf Foo)&#123; .... &#125; else if (json.getXXX instanceOf Bar)&#123; ... &#125; else &#123; ... &#125;&#125; 在Kotlin中，通过when + is 来实现 12345when (x) &#123; is Foo //-&gt; …… is Bar //-&gt; …… else //-&gt; ……&#125; 是不是一目了然，妈妈再也不用担心我看代码看到心烦意乱了？ 遍历map/pair类型的list123for ((k, v) in map) &#123; println("$k -&gt; $v")&#125; 如果是在Java里面，我们需要通过key来找value，然后再输出，代码量又是蹭蹭的往上串 扩展函数emmm，这个之前在函数那一篇文章里面已经讲得比较清楚了，忘了的童鞋可以重温一下：Kotlin学习之旅(D4)-函数与Lambda表达式 直接上代码： 123fun String.spaceToCamelCase() &#123; …… &#125;"Convert this to camelcase".spaceToCamelCase() String里面是没有spaceToCamelCase这个方法的，但是我们又不想通过继承让所有子类都加上这个方法，那么可以通过扩展函数来实现。 创建单例单例模式我们经常都会用到，在Java里面的写法也是多种多样，但是所有形式的代码量都没有Kotlin里面来的简洁： 123object Resource &#123; val name = "Name"&#125; 没错，就是通过object关键字定义单例。 总结这些习惯用法都是前人通过大量实践总结出来的，可以提高我们的开发效率，所以我们也应该多学习这些用法，努力让自己写出来的代码简洁易懂。 Day 6 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D5)-高级语法]]></title>
    <url>%2Farticles%2Flearn_kotlin_day5.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅第五天 今天的主题是：高级语法 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 Kotlin学习之旅(D4)-函数与Lambda表达式 高级语法空安全写过Java代码的人都知道，空指针异常是时刻都要注意的，特别是在Android里面，一个NullPointerException就会让App Crash，因此在Kotlin里面，为了消除来自代码空引用的危险，默认引用是不能为空的。关于空指针异常，这里还有个趣闻：《十亿美元的错误》 在Kotlin里面，如果允许某个变量为null，我们可以通过 “ ? ” 来表示： 12345var b: String? = "abc"b = null // okvar a: String = "abc"a = null // 编译错误 如果变量是可以为空的，那么每次都需要显示检查是否为null： 1val l = if(b != null) b.length - 1 或者，通过安全调用操作符 -&gt; “ ?. “ 123456fun main(args: Array&lt;String&gt;) &#123; val a = "Kotlin" val b: String? = null println(b?.length) // 如果b为null，则返回null println(a?.length)&#125; !!操作符这个操作符在kotlin里面经常都能看到，他的作用就是：非空断言操作符。例如： a!! ，如果a为null，那么就会抛出异常，如果不为null，则返回a的值 因此，如果你不希望NPE没有被捕获而导致appcrash，也不希望字符串为null但是没有处理，那么你就需要使用！！操作符，在变量为null的时候会抛出异常，我们就能在控制台看到了。 异常在Kotlin中，我们使用throw - Exception 来抛出异常： 1throw Exception("this is an exception") 使用try来捕获异常： 1234567try &#123; &#125; catch (e: Exception)&#123; &#125; finally &#123; &#125; 这个语法结构和Java里面是很类似的 反射类引用在反射中我们用的比较多的就是类引用 1val c = MyClass::class 该引用是 KClass 类型的值。 请注意，Kotlin 类引用与 Java 类引用不同。要获得 Java 类引用， 请在 KClass 实例上使用 .java 属性。 函数引用通常我们会直接调用函数，通过 xxx() 来调用，但是我们也可以把函数传给另外一个函数当参数，使用的也是 ::操作符 123456fun isOdd(x: Int) = x % 2 != 0fun main(args: Array&lt;String&gt;) &#123; val numbers = listOf(1, 2, 3) println(numbers.filter(::isOdd))&#125; 在这个例子里面，我们首先定义了一个函数isOdd() 判断参数x是否为奇数，在main函数里，我们把这个方法作为参数传到了filter()方法里，这里其实是把函数当成 函数类型的值 ，这个和Lambda表达式有点类似，都是把函数作为参数。 属性引用同样，我们也是使用::来引用属性 12345val x = 1fun main(args: Array&lt;String&gt;) &#123; println(::x.get()) println(::x.name) &#125; 在这里，表达式 ::x 的意思是： 求值为 KProperty&lt;Int&gt; 类型的属性对象，它允许我们使用 get() 读取它的值，或者使用 name属性来获取属性名。更多信息请参见关于 KProperty 类的文档。 总结除了上面说的这几个语法，其实官方文档还有别的，例如：注解，类型别名，类型安全的构造器等等，我觉得这些语法用的都比较少，在看到或者需要用到的时候再去了解也可以，所以这里就没讲。 其实Kotlin的语法和Java还是很相像的，只是有一些技巧或者特性，需要在实践中掌握，从而提高开发效率。因此明天开始我们就会进入：Kotlin Idioms 环节，介绍一些好用的开发技巧~ Day 5 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D4)-函数与Lambda表达式]]></title>
    <url>%2Farticles%2Flearn_kotlin_day4.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅-第四天 今天的主题是：函数与Lambda表达式 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 Kotlin学习之旅(D3)-类与继承 函数Kotlin里面的函数其实在之前的学习中已经见过了，通过 fun 关键字来标识 123fun double(x: Int): Int &#123; return 2 * x&#125; 默认参数除了一般的使用 x: Int 这种方式定义参数，我们也可以使用默认参数的方式，这种方式可以有效减少重载方法的数量 1fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) &#123;...&#125; off是默认值为0的Int类型参数 len是默认值为b.size的Int类型参数 命名参数在Java里面，我们调用具有多个参数的方法，是无法直接看到每个参数的意思的，例如： 123456private void reformat(String str, Boolean normalizeCase, Boolean upperCaseFirstLetter, Boolean, divideByCamelHumps, Char wordSeparator)&#123; ...&#125;// 调用方法reformat(str, true, ture, ture, '_') 在Kotlin里面，我们可以在调用的时候给参数加个名字，就像： 123456789101112131415fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = ' ') &#123;……&#125;// 调用方法reformat(str, normalizeCase = true, upperCaseFirstLetter = true, divideByCamelHumps = false, wordSeparator = '_') 这样代码的可读性更高，在多个参数的时候能清晰看到每个参数的作用 返回Unit的函数前面写的几个方法都有返回值，那么如果要像Java里面一样返回void，在kotlin要怎么写呢？ 1234567fun printHello(name: String?): Unit &#123; if (name != null) println("Hello $&#123;name&#125;") else println("Hi there!") // `return Unit` 或者 `return` 是可选的&#125; 通过 Unit 关键字表示返回 Unit类型，他的作用类似于Java里面的void，在Kotlin里面，Unit返回类型是可以省略的。 中缀表示法标有 infix 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求： 它们必须是成员函数或扩展函数； 它们必须只有一个参数； 其参数不得接受可变数量的参数且不能有默认值。 1234567infix fun Int.shl(x: Int): Int &#123; …… &#125;// 用中缀表示法调用该函数1 shl 2// 等同于这样1.shl(2) 中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符。 以下表达式是等价的： 1 shl 2 + 3 与 1 shl (2 + 3) 0 until n * 2 与 0 until (n * 2) xs union ys as Set&lt;*&gt; 与 xs union (ys as Set&lt;*&gt;) 另一方面，中缀函数调用的优先级高于布尔操作符 &amp;&amp; 与 ||、is- 与 in- 检测以及其他一些操作符。这些表达式也是等价的： a &amp;&amp; b xor c 与 a &amp;&amp; (b xor c) a xor b in c 与 (a xor b) in c 完整的优先级层次结构请参见其语法参考。 Lambda 表达式关于Lambda表达式这部分，从Java8就开始支持了，在实际开发中也会经常用到，但对我来说还是太抽象了，一直都不太理解，因此这一块我是参照官方文档来写的。如果有好的学习资料，欢迎大家留言~ lambda 表达式与匿名函数是“函数字面值”，即未声明的函数， 但立即做为表达式传递。考虑下面的例子： 1max(strings, &#123; a, b -&gt; a.length &lt; b.length &#125;) 函数 max 是一个高阶函数，它接受一个函数作为第二个参数。 其第二个参数是一个表达式，它本身是一个函数，即函数字面值，它等价于以下命名函数： 1fun compare(a: String, b: String): Boolean = a.length &lt; b.length 从上面的例子看来，其实Lambda就是一种函数的表达方式，这个函数还未声明，但是通过Lambda表达式可以直接调用，只要掌握了语法，就能很方便的写出来了。 Lambda 表达式语法Lambda 表达式的完整语法形式如下： 1val sum = &#123; x: Int, y: Int -&gt; x + y &#125; lambda 表达式总是括在花括号中， 完整语法形式的参数声明放在花括号内，并有可选的类型标注， 函数体跟在一个 -&gt; 符号之后。如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。 如果我们把所有可选标注都留下，看起来如下： 1val sum: (Int, Int) -&gt; Int = &#123; x, y -&gt; x + y &#125; 把上面的官方文档说明翻译一下，就是： 1231.lambda表达式总是括在花括号中2.参数在-&gt;之前3.函数在-&gt;之后 因此上面的例子翻译一下，就是： 1231.&#123; x, y -&gt; x + y &#125; 为lambda表达式2.(Int, Int) 为参数3.Int = &#123;...&#125; 就是一个返回类型为Int的函数 it：单个参数的隐式名称一个 lambda 表达式只有一个参数是很常见的。 如果编译器自己可以识别出签名，也可以不用声明唯一的参数并忽略 -&gt;。 该参数会隐式声明为 it： 1ints.filter &#123; it &gt; 0 &#125; // 这个字面值是“(it: Int) -&gt; Boolean”类型的 几个Tips Lambda表达式可以传递给一个高阶函数当做参数 12345678910fun &lt;T, R&gt; Collection&lt;T&gt;.fold( initial: R, combine: (acc: R, nextElement: T) -&gt; R): R &#123; var accumulator: R = initial for (element: T in this) &#123; accumulator = combine(accumulator, element) &#125; return accumulator&#125; fold这个函数的第二个参数是 combine(R, T)，同样是一个函数，他的返回值会作为fold的参数，那么flod就是一个高阶函数，而combine里面可以使用Lambda表达式~ 如果函数的最后一个参数是一个函数，并且你传递一个 lambda 表达式作为相应的参数，你可以在圆括号之外指定它 例如： 123val product = items.fold(1, &#123; acc, e -&gt; acc * e &#125;) =&gt; val product = items.fold(1) &#123; acc, e -&gt; acc * e &#125; 如果一个函数的参数只有一个，并且参数也是一个函数，那么可以省略圆括号 例如： 123run (&#123; println("...") &#125;)=&gt;run &#123; println("...") &#125; 总结由于Kotlin里面Lambda表达式的使用还是很多的，所以建议大家多去看看其他的博客，因为我觉得官方文档对于没接触过Lambda的初学者来说还是太难懂了一点。 Day 4 - Learn Kotlin Trip， Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D3)-类与继承]]></title>
    <url>%2Farticles%2Flearn_kotlin_day3.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅-第三天 今天的主题是：类与继承 前言Kotlin学习之旅(D1)-学习计划&amp;基本语法 Kotlin学习之旅(D2)-基本语法 今日目标今天空闲的时候 baidu一下，发现简书，掘金上有很多Kotlin学习总结，但是基本上都是把官方文档一字不落地复制粘贴了过来。我不希望自己也是这样子的，因此在Kotlin学习之旅里面： 我只会把最常用的归纳总结起来，其他的大家可以去官方文档进行查看 除了官方文档有的知识点，也会加上自己的思考，标注一些不太容易理解，或者容易踩坑的地方 根据自己经验，或者评论的意见，不断补充和修改 把这一系列的学习经验写成简洁易懂又实用的文章 话不多说, 今天我们的目标就是搞定下面几个知识点： 类与对象基本用法 数据类 嵌套类 内部类 继承与接口 Tips： Kotlin中文参考手册 Kotlin Docs Reference 类与对象基本用法最基本的用法： 1class Day3 没有类体，只有类名，连大括号都省了 然后在Day3中加上构造方法 1class Day3 constructor(name: String) &#123;...&#125; // 关键字constructor 但是一般我们看别人写的代码都是没有constructor这个关键字的，为什么呢？ 官方文档给了答案： 如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字 也就是说，Day3可以写成 1class Day3(name: String) &#123;...&#125; 直接 类名(参数1,参数2){…} 这种格式就可以了 在kotlin里面，只能有一个主构造函数，和多个次构造函数，例如： 123456789class Day3(name: String)&#123; // 1 constructor(name: String, age: Int): this(name)&#123; // 2 println("this is second constructor and the age is " + age) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var day3 = Day3("hello") // 3&#125; Day3(…) 括号里的就是主构造函数，只是省略了constructor关键字 { } 大括号里的 constructor(…) 就是次构造函数，每个次构造函数都要委托给主构造函数 实例化一个Day3对象 运行代码的结果：啥都没有~ 因为我们没有在主构造函数里面做任何的操作，那么如果我们要做初始化操作，要怎么写呢？ 1234567891011121314class Day3(name: String)&#123; init &#123; // 1 println("this is main constructor") &#125; constructor(name: String, age: Int): this(name)&#123; println("this is second constructor and the age is " + age) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var day3 = Day3("hello") // 2 var day33 = Day3("hello", 1) // 3&#125; init就是主构造函数的初始化方法 使用主构造函数初始化Day3对象 使用次构造函数初始化Day3对象 运行代码的结果： 123this is main constructorthis is main constructorthis is second constructor and the age is 1 这里输出了两次main和一次second，原因就是上面我们讲到的 每个次构造函数都要委托给主构造函数 ，通过this关键字，在调用次构造函数之前，都会先调用一次主构造函数，因此会有两个main输出~ 通过这个例子，应该就能弄懂 类的定义，主/次构造函数，init的用法，如何实例化对象了 数据类Kotlin中通过 data 关键字来表示数据类： 1data class dataClass(val name: String, val age: Int) 在实际开发中，数据类的使用是很常见的，那么Kotlin里的数据类具有哪些特性呢？ 编译器自动从主构造函数中声明的所有属性导出以下成员： equals()/hashCode() 对； toString() 格式是 &quot;User(name=John, age=42)&quot;； componentN() 函数 按声明顺序对应于所有属性； copy() 函数（见下文）。 为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求： 主构造函数需要至少有一个参数； 主构造函数的所有参数需要标记为 val 或 var； 数据类不能是抽象、开放、密封或者内部的； 因此，有两点需要注意： 我们不能像普通类一样 class test(name: String, age: Int) 参数必须标记 val 或 var 不能写 data class test()，而是必须至少有一个参数 这样创建数据类，编译器才不会报错~ 请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排出一个属性，请将其声明在类体中 这句话是什么意思呢？举个例子： 123456789101112data class Person(val name: String) &#123; var age: Int = 0&#125;fun main(args: Array&lt;String&gt;) &#123; val person1 = Person("John") val person2 = Person("John") person1.age = 10 person2.age = 20 println("person1 == person2: $&#123;person1 == person2&#125;") println("person1 with age $&#123;person1.age&#125;: $&#123;person1&#125;") println("person2 with age $&#123;person2.age&#125;: $&#123;person2&#125;")&#125; 输出结果： 123person1 == person2: trueperson1 with age 10: Person(name=John)person2 with age 20: Person(name=John) 虽然age不一样，但是 == 结果是 true 说明只有在主构造函数内部定义的属性才具有toString()、 equals()、 hashCode() 、copy()这几个方法，由于属性age定义在类体中，因此是没有的。 最后，标准库提供了Pair和Triple这两个标准数据类 我们来看一下Pair的源码： 12345678910public data class Pair&lt;out A, out B&gt;( public val first: A, public val second: B ) : Serializable &#123; /** * Returns string representation of the [Pair] including its [first] and [second] values. */ public override fun toString(): String = "($first, $second)"&#125; 会发现其中他就是key-value格式的数据类，重写了toString()方法，其他的默认属性都是一样的~ 在代码中运行一下： 1234567fun main(args: Array&lt;String&gt;) &#123; var pair = Pair("1","2") println(pair) println(pair.toString()) println(pair.toList())&#125; 输出结果： 123(1, 2)(1, 2)[1, 2] Triple也是类似的，这里就不看了。数据类知识点大概就是这么多~ 嵌套类与内部类嵌套在类里面的类，就是嵌套类，这句话说起来比较拗口，直接看代码： 12345678class Outer &#123; // 1 private val bar: Int = 1 class Nested &#123; // 2 fun foo() = 2 &#125;&#125;val demo = Outer.Nested().foo() // == 2 外部类 内部类 通过Outer.Nested().foo()调用内部类的方法 但是这个时候 Nested 类是不能访问Outer类的成员变量的，直接访问的话会报错~ 如果需要，要加上inner关键字，让Nested成为内部类 12345678class Outer &#123; private val bar: Int = 1 inner class Inner &#123; fun foo() = bar &#125;&#125;val demo = Outer().Inner().foo() // == 1 继承与接口这部分在实际应用中也是非常重要的，经常都会用到，毕竟抽象封装多态这三大特性，除了类与对象以外基本上就是通过继承和接口实现了 继承我们都知道，在Java里面是只能实现单继承的，也就是一个子类只能有一个父类，但是通过接口的方式，其实也就相当于实现了多继承，在Kotlin里面也是一样的，我们先说继承 12open class Father(name: String) // 1class Son(name: String) : Father(name) // 2 open class Father就是父类，主构造函数里面需要传入String类型的参数name Son继承自Father，需要用父类的主构造函数参数进行初始化 覆盖方法继承自然免不了要覆盖父类的方法，Kotlin里面通过关键字override 来标识 1234567open class Base &#123; open fun v() &#123; ... &#125; // 1 fun nv() &#123; ... &#125;&#125;class Derived() : Base() &#123; override fun v() &#123; ... &#125; // 2&#125; 被覆盖的方法需要用open标识 覆盖的方法需要用override标识 那么如果不想让子类继续覆盖要怎么做呢，只要加上final关键字就可以了 123open class AnotherDerived() : Base() &#123; final override fun v() &#123; ... &#125;&#125; 调用父类实现在子类中可以通过super关键字来调用父类的属性和方法 12345678910111213open class Foo &#123; open fun f() &#123; println("Foo.f()") &#125; open val x: Int get() = 1&#125;class Bar : Foo() &#123; override fun f() &#123; super.f() println("Bar.f()") &#125; override val x: Int get() = super.x + 1&#125; 接口在Kotlin中，我们使用interface关键字来定义接口 123456interface MyInterface &#123; // 1 fun bar() // 2 fun foo() &#123; // 可选的方法体 &#125;&#125; interface 表示接口 fun xxx() 定义方法名，不需要实现 接口中的继承 1234567891011121314151617interface Named &#123; val name: String&#125;interface Person : Named &#123; val firstName: String // 1 val lastName: String override val name: String get() = "$firstName $lastName" // 2&#125;data class Employee( // 不必实现“name” override val firstName: String, override val lastName: String, val position: Position) : Person 可以看到，Person 继承 Named ，并且重写了 name 属性的get()方法，因此在Employee类实现Person接口的时候，只要实现 firstName, lastName 两个属性就可以了，而不用实现 name 属性 一般来说，我们都会使用到继承+接口两种方式，格式是这样的: 1234567891011121314151617181920212223242526class Day3(name: String) : DayFather(), MyInterface&#123; // 1，2 init &#123; println("this is main constructor") &#125; constructor(name: String, age: Int): this(name)&#123; println("this is second constructor and the age is " + age) &#125; override fun test1() &#123; // 3 TODO("not implemented") &#125; override fun test2() &#123; TODO("not implemented") &#125;&#125;interface test&#123; fun test1() fun test2()&#125;open class DayFather&#123; &#125; 通过 :Father() 来继承父类 通过 ,Interface 来实现接口 实现接口中定义的方法 总结 类与对象基本用法 数据类 嵌套类 内部类 继承与接口 这几个知识点我们今天就学习完了，明天我们会继续学习 函数 和 Lambda表达式 Day 3 - Learning Kotlin Trip，Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D2)-基本语法]]></title>
    <url>%2Farticles%2Flearning_kotlin_d2.html</url>
    <content type="text"><![CDATA[Kotlin学习之旅的第二天 今天让我们完成 基础语法 的学习 前言昨天，我们学习了一部分的基础语法，文章链接：Kotlin学习之旅(D1)-学习计划&amp;基本语法 最后还剩下三个基础语法没讲： for循环和while循环 when表达式 遍历集合 今天让我们一个个解决掉~ 循环for循环在Java，C，Python等各种编程语言中，都会有循环控制，其中for循环又是最为常见的，在Kotlin中，for循环的语法为： 123for(item in collection)&#123; print(item)&#125; 通过 in 关键字来进行循环，当然，也可以指定范围： 123for (i in 1..3)&#123; println(i)&#125; 通过 “..” 表示范围，那么如果是只取奇数，或者偶数呢？间隔3个数取值呢？这时候就要用到 step 关键字了 123for(i in 1..6 step 2)&#123; println(i)&#125; 输出结果为： 123135 因为我们取值范围是1-6，每隔1个取值（step 2） 好了，那么如果我们希望从大到小取值呢，kotlin里面提供了一个downTo关键字 123for (i in 6 downTo 0 step 2) &#123; println(i)&#125; 这个函数的输出结果就是： 12346420 因为我们取值范围是6-0，每隔1个取值（step 2） 除了最基本的int型，我们还可以取数组的值： 123456fun main(args: Array&lt;String&gt;) &#123;val array = arrayOf("a", "b", "c") for (i in array.indices) &#123; println(array[i]) &#125;&#125; 其他的集合类型我们会在后面的 遍历集合 里面再讲 while循环while循环的语法比较简单： 1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) // y is visible here! 通常是 while(“条件语句”) { … } 或者是 do { … } while(“条件语句”) when表达式上面讲的 for 和 while 在 Java里面都有，所以看一遍基本上就差不多了，但是when表达式，在Java里面是没有的，比较相像的是switch语句，其实when也是条件判断，或者说是控制流的一种。 基本用法： 1234567when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; // Note the block print("x is neither 1 nor 2") &#125;&#125; 但是when表达式有个很厉害的地方，他可以接收表达式，或者是普通的语句，什么意思呢？看个例子就明白了： 123456when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125; 如果是switch语句，那么case的条件里面只能是string类型，但是在when里面则灵活许多，可以是1-10范围内的数字，可以使用”!”表示“非”，甚至可以在里面调用方法： 12345when &#123; x.isOdd() -&gt; print("x is odd") x.isEven() -&gt; print("x is even") else -&gt; print("x is funny")&#125; 虽然这种条件判断我们也可以通过if…else 来实现，但是阅读起来，还是when表达式比较好理解。 遍历集合一边遍历集合都会在for循环里面使用，例如： 123456fun main(args: Array&lt;String&gt;) &#123; val items = listOf("apple", "banana", "kiwifruit") for (item in items) &#123; println(item) &#125;&#125; 输出结果为： 123applebananakiwifruit 同样的，在while循环中也可以遍历集合：` 1234567fun main(args: Array&lt;String&gt;) &#123; val items = setOf("apple", "banana", "kiwifruit") when &#123; "orange" in items -&gt; println("juicy") "apple" in items -&gt; println("apple is fine too") &#125;&#125; 这里虽然不太明显，但是其实通过 “orange” in items 判断 “orange”是否在items中的时候，就需要遍历整个集合，所以说 “in” 关键字的作用就是遍历 总结好了，基础知识到这里就全部讲完了，这两天学到的基本语法在日常开发中我们经常会用到，貌似Kotlin的特性我们一个都还没说，例如：空安全，lambda表达式，如何自动生成getter和setter的类等等，这些我们会在接下来为期3天的高级语法之旅中进行学习。 这两天的基础语法其实就是让大家对kotlin这门语言有一点印象，想要真正要写出优雅，可读，高效的代码，我们还需要进行其他的理论学习，再加上不断不断的实践。 Day 2 - Learning Kotlin Trip，Completed.]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习之旅(D1)-学习计划&基本语法]]></title>
    <url>%2Farticles%2Flearning_kotlin_day1.html</url>
    <content type="text"><![CDATA[2017年的Google I/O 开发者大会 Kotlin正式成为了Android的官方支持语言 2018年的国庆小长假最后一天 BlueLzy正式开始Kotlin学习之旅 学习计划学什么？今天是Kotlin学习之旅的第一天，这次Kotlin之旅的行程计划是21天 目的：每天只要花30分钟-1个小时，坚持14天，也就是两个星期，掌握Kotlin开发Android项目所需知识 包括： 基础语法（2D） 高级语法（3D） Kotlin Idioms（2D） From Java to Kotlin（1D） Kotlin Android Extensions（1D） Unit Test with Kotlin（1D） 使用Kotlin完成一个Android小项目（3D） 总结（1D） 不包括： Kotlin对比Java的好处，为什么要学习Kotlin 怎么安装Android Studio / IDEA 怎么加入Kotlin依赖 … 需要的前置技能：任意一种编程语言基础，基本数据类型，操作符等基础知识已掌握即可 怎么学？1.根据20/80法则，我们不需要掌握Kotlin所有的知识点，只需要掌握20%最常用就足以应付80%的场景了 2.学习金字塔法则，被动学习和主动学习的知识留存率是差很多的： 尽量做创造性（输出）的事情，例如写总结，做笔记，敲代码，甚至内部分享，写成教程等 3.Learning By Doing法则，整个Kotlin学习之旅主要分为两个部分 理论部分：主要是参考kotlinlang.org，并配上Sample Code 实践部分：使用Kotlin编写一个Todo项目，选择这个项目的原因是：无网络请求，方便编写Unit Test，项目结构较为简单，7天即可完成 编程最重要就是动手敲，最终要的是能运行的程序，因此建议大家都跟着动手敲一遍 基本语法(Part Ⅰ)变量在Java里面，定义 常量 的写法是加上final关键字 而在Kotlin里面，定义常量的关键字是：val 12val a: Int = 0 // 相当于java里面的 private static final int a = 0;val b = 2 // 省略Int类型，在kotlin中也是允许的，Kotlin可以自动推断变量的类型 那么要定义 变量 要怎么写呢？ 通过关键字：var 12var c = 0 // 省略Int类型c += 1 Tips：在kotlin中，我们可以省略每行代码最后的分号 ‘ ; ‘ 延迟初始化 - Late-Initialized： 由于在Kotlin里面变量是non-null的，但是有些时候我们需要在执行完某个操作后再赋值，那么就需要用到延迟初始化，通过 lateinit 关键字来实现 12345678910class Address &#123; var name: String = ... var street: String = ... lateinit var city = ...&#125;// 通过isInitialized来检查变量是否已经被初始化if (address::city.isInitialized) &#123; println(address.city)&#125; 函数通过 fun 关键字来定义函数，例如： 123fun nothing()&#123; println("i am an empty function")&#125; 有参函数： 123fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 这里我们传入a，b两个Int参数，返回值也是Int类型 a: Int - 参数名: 参数类型 fun(): Int - 函数: 函数返回值类型 更简洁的写法： 1fun sum(a: Int, b: Int) = a + b 通过 ‘’=’’ 来表示 return 语句，注意：返回值只有一条表达式的时候才适用 参数有默认值的函数： 1fun sum(a: Int = 1, b: Int = 1) &#123;...&#125; 此时a，b的默认值都是1 注释1234// 单行注释/* 这是一个多行注释 这是一个多行注释 */ String字符串模板使用 $var_name 来表示变量的值 1234567var a = 1val s1 = "a is $a"a = 2val s2 = "$&#123;s1.replace("is","was")&#125;, but now is $a"println(s2) 这段代码的输出结果为： 1a was 1, but now is 2 s1 的初始值为： a is 1，然后通过.replace()函数，把 is 替换为 was ,此时 s1变成了 a was 1 条件语句条件语句的判断通常是 if 语句 1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 更简洁的写法，记得上面我们说过的 “=” 来替换 return 吗： 1fun maxOf(a: Int, b: Int) = if(a &gt; b) a else b 这里其实使用了if 不加括号只执行一行的特性，常规写法应该是这样的： 12345fun maxOf(a: Int, b: Int) = if (a &gt; b)&#123; a&#125; else &#123; b&#125; 但是这样实在是太难看了，所以就省略了大括号，把返回结果直接写在一行代码里 可空类型和null检查Kotlin具有空安全（null safety）特性，但是有时候我们就是想要返回null，该怎么办呢？ 当str不存在整数时返回null： 123fun parseInt(str: String): Int? &#123; // ... &#125; 官方文档给出的Sample： 123456789101112131415161718192021222324252627fun parseInt(str: String): Int? &#123; return str.toIntOrNull()&#125;fun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2) // ... if (x == null) &#123; println("Wrong number format in arg1: '$arg1'") return &#125; if (y == null) &#123; println("Wrong number format in arg2: '$arg2'") return &#125; // x and y are automatically cast to non-nullable after null check println(x * y)&#125;fun main(args: Array&lt;String&gt;) &#123; printProduct("6", "7") printProduct("a", "7") printProduct("99", "b")&#125; 输出结果为: 12342Wrong number format in arg1: 'a'Wrong number format in arg2: 'b' 分析一下： printProduct(“6”, “7”)：x，y都能转成Int类型，因此x,y都不是null，println(x * y) = 6 x 7 = 42 printProduct(“a”, “7”)：x为”a”不能转成Int，因此x为null，执行 1println("Wrong number format in arg1: '$arg1'") printProduct(“99”, “b”) ：同上 说明在fun或者var 加上 “?” 就表示该类型可以为null，后面就需要进行是否为null的判断 类型检查与强制类型转换Kotlin中，“is” 是类型检查的关键字 123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // `obj` is automatically cast to `String` in this branch return obj.length &#125; // `obj` is still of type `Any` outside of the type-checked branch return null&#125; 在这里，执行 obj.length 的时候，obj 会强制类型转换为 String 又或者可以这样写 123456fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // `obj` is automatically cast to `String` in this branch return obj.length&#125; 这两段代码的意思都是一样的，通过 is 或者 !is 进行类型检查 使用 “as?” 进行“安全的”类型转换 例如： null 不能转换为String，因为String 是不可为null的，那么这个时候我们可以用这种方式： 1val x: String? = y as? String 当y为null的时候，结果会返回null，而不会抛出异常 总结今天是Kotlin学习之旅的第一天，主要学习了Kotlin的基础语法，包括： 变量 函数 String字符串模板 条件语句 可空类型和null检查 类型检查与强制类型转换 明天会学习剩下的基础语法，包括： for循环和while循环 when表达式 遍历集合 面向对象编程打算在高级语法里面学习，因为这一块的知识点比较多，需要花的时间精力也会多一些。 好了，那么Day 1 的学习到此就结束啦。]]></content>
      <categories>
        <category>Kotlin学习之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView基本用法]]></title>
    <url>%2Farticles%2Frecyclerview_introduction.html</url>
    <content type="text"><![CDATA[Learning By Doing 一个Demo掌握RecyclerView基本用法 前言由于RecyclerView已经出来很久了，关于RecyclerView的文章网上也有很多，所以这篇文章只是作为一个基本用法的总结 + 常见功能的参考链接，可以理解为一篇查阅/总结的文章。 首先总结一下最基本的用法。 RecyclerView使用使用RecyclerView的步骤 添加RecyclerView依赖库（gradle build file） 定义Model类 在XML添加RecyclerView 创建XML布局文件，用于展示item 创建RecyclerView.Adapter和ViewHolder 绑定adapter和数据到RecyclerView 添加RecyclerView依赖库在build.gradle中加入依赖： 1implementation'com.android.support:recyclerview-v7:27.0.2' 定义Model类12345678910111213141516171819202122232425262728293031323334/** * author : BlueLzy * e-mail : bluehobert@gmail.com * date : 2018/09/10 22:11 * desc : */public class Contact &#123; private String mName; private boolean mOnline; public Contact(String name, boolean online) &#123; mName = name; mOnline = online; &#125; public String getName() &#123; return mName; &#125; public boolean isOnline() &#123; return mOnline; &#125; private static int lastContactId = 0; public static ArrayList&lt;Contact&gt; createContactsList(int numContacts) &#123; ArrayList&lt;Contact&gt; contacts = new ArrayList&lt;Contact&gt;(); for (int i = 1; i &lt;= numContacts; i++) &#123; contacts.add(new Contact("Person " + ++lastContactId, i &lt;= numContacts / 2)); &#125; return contacts; &#125;&#125; 在activity添加RecyclerView我们新建一个layout文件： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rvContacts" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 创建XML布局文件，用于展示item再创建一个layout文件： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingTop="10dp" android:paddingBottom="10dp" &gt; &lt;TextView android:id="@+id/contact_name" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;Button android:id="@+id/message_button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingLeft="16dp" android:paddingRight="16dp" android:textSize="10sp" /&gt;&lt;/LinearLayout&gt; 创建adapter和viewholder创建ContactsAdapter类： onCreateViewHolder:一般用于初始化布局文件和viewholder onBindViewHolder：一般用于初始化item布局中的控件 123456789101112131415161718192021222324252627282930313233343536/** * author : BlueLzy * e-mail : bluehobert@gmail.com * date : 2018/09/10 22:16 * desc : */public class ContactsAdapter extends RecyclerView.Adapter&lt;ContactsAdapter.ViewHolder&gt; &#123; private List&lt;Contact&gt; contacts; public ContactsAdapter(List&lt;Contact&gt; contacts)&#123; this.contacts = contacts; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; Context context = parent.getContext(); LayoutInflater inflater = LayoutInflater.from(context); View contactView = inflater.inflate(R.layout.item_recyclerview, parent, false); ViewHolder viewHolder = new ViewHolder(contactView); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Contact contact = contacts.get(position); TextView textView = holder.name; textView.setText(contact.getName()); Button button = holder.message; button.setText(contact.isOnline() ? "Message" : "Offline"); button.setEnabled(contact.isOnline()); &#125; 在activity绑定adapter和data在activity的onCreate()中加入以下代码： 123456789RecyclerView rvContacts = findViewById(R.id.rvContacts); contacts = Contact.createContactsList(20); ContactsAdapter adapter = new ContactsAdapter(contacts); rvContacts.setLayoutManager(new LinearLayoutManager(this)); rvContacts.setAdapter(adapter); SnapHelper snapHelper = new LinearSnapHelper(); snapHelper.attachToRecyclerView(rvContacts); compile &amp; run project运行程序，看一下我们的成果： 可以看到，根据Contact.createContactsList(20)方法，创建了20个item，并且成功的按照item的布局展示出来，这就是RecylerView最基本的用法了。over~ 步骤其实特别简单： 添加依赖，XML加入RecyclerView，编写item布局，编写Adapter和ViewHolder，创建RecyclerView，绑定Adapter 最后别忘了 运行程序 over~ 第三方库由于RecyclerView还有许多有用的特性，我们可以利用它来做很多有趣的事情，所以我也收集了一些资料，供大家参考。 让item在滚动后居中显示的库： Snap to Center Effect 给Recyclerview加上各种动画：recyclerview-animators 万能adapter：BaseRecyclerViewAdapterHelper tablayout：RecyclerTabLayout 文章/博客中文： Android RecyclerView 使用完全解析 体验艺术般的控件 深入浅出 RecyclerView 英文： Android Developer - Create a List with RecyclerView RecyclerView:Android-Developer-Traning 基本上常见的用法和原理的解析都在这里面了，有特定需求的可以上Github找一下第三方库，看一下里面的源码，了解原理之后，其实自己也能实现各种炫酷的效果~ 20181010更新评论里有朋友问怎么添加分割线，其实Android官方已经提供了默认实现。只需要一行代码即可： 1recyclerView.addItemDecoration(new DividerItemDecoration(context,DividerItemDecoration.VERTICAL)); 效果如图： 如果对默认的效果不满意，也可以使用其他的实现方式： 自定义Drawable文件 12recyclerView.addItemDecoration(new RecycleViewDivider( context, DividerItemDecoration.VERTICAL, R.drawable.divider_mileage)); OR 自定义分割线高度和颜色 12recyclerView.addItemDecoration(new RecycleViewDivider( context, DividerItemDecoration.VERTICAL, 10, getResources().getColor(R.color.divide_gray_color)));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android DataBinding基本用法]]></title>
    <url>%2Farticles%2Fandroid_databinding_introduction.html</url>
    <content type="text"><![CDATA[Learning By Doing 一个Demo掌握DataBinding的基本用法 前言DataBinding 是Google推出的一个支持库，它的作用是：通过layout文件绑定app逻辑和UI的更新，尽可能地减少编码工作。 说定义似乎有些隐晦，还是通过learning by doing的方式来学习吧。 这篇文章包括以下几方面的内容： 通过layout来绑定app逻辑 layout里包含include标签的用法 点击事件的处理 使用Observablues动态更新UI 使用ObervablueFields动态更新UI 我会按照上面列的顺序，一步步在Demo里面实现对应的功能 所有的源码都包含在这篇文章里，需要Demo的可以评论留言 由于是Learning By Doing，所以不会有理论的讲解，关于为什么是layout便签，为什么支持这样调用等问题，请去Android Developer 看官方文档，或者去Stack Overflow 提问 通过layout来绑定app逻辑注意： 首先打开Andriod Studio，并创建一个新的项目，然后再正式开始我们的DataBinding之旅。 加入Databinding在app/gradle文件中加入： 123Databinding&#123; Eanbled = true&#125; 就可以使用DataBinding了，前提是你的Android Studio是2.1.3以上的版本（目前最新版已经是3.1.4了~） 编写Bean这里我们用User类来演示 12345678910111213141516171819202122public class User &#123; private String name; private String email; public String getName() &#123; return name == null ? "" : name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email == null ? "" : email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; Android Stuido: command/ctrl + n 快捷键 可以快速创建构造方法，gettet/setter方法等 编写layout文件打开activity_main.xml 文件，把根目录改成layout，并且加入data 和 variable 标签 1234567891011121314151617181920212223&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:bind="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="user" type="com.blue.androidlearningcode.databinding.User"/&gt; &lt;/data&gt; &lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.name&#125;" /&gt; &lt;TextView android:id="@+id/email" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.email&#125;" /&gt;&lt;/layout&gt; layout data variables的官方定义： The Data Binding Library automatically generates the classes required to bind the views in the layout with your data objects. The library provides features such as imports, variables, and includes that you can use in your layouts. data：用于定义在DataBinding里面需要用到的数据对象（data objects） variable：比data更小的层级，通常是class，我们这里就是刚刚写的User类 textview: 通过@{user.xxx}来绑定user里面的属性 在代码中绑定xml里面的控件回到MainActivity.class文件中，现在我们需要做的就是把刚刚写的layout文件，和生成的DataBinding绑定起来。 首先，让我们愉快的 clean &amp; rebuild project吧 为什么呢？ 因为DataBinding需要在Build的过程中生成绑定类 ps：实际开发中，如果项目过大，可能Restart Android Studio比较快。。 OK，如果一切顺利的话，就开始写MainActivity的代码吧，在onCreate方法中： 123456ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); user = new User(); user.setName("BlueLzy"); user.setEmail("bluehobert@gmail.com"); binding.setUser(user); ActivityMainBinding：这货就是Build完生成出来的东西 binding.setUser()：绑定对应的bean 好了，run一下，应该就能看到在两个TextView中分别出现了name和email的value了 layout里包含include标签的用法上面的用法其实就是DataBinding最基本的用法，通过xml和class的绑定，减少我们在class里面编写的代码量。 但是理想很丰满，现实很骨感，项目中总是会有许多意想不到的需求，例如：我要在layout里面使用include标签，咋整？ 如果直接把include标签加入到父布局，然后运行程序，你会发现是不行的，我们有些小细节要处理。 So，let‘s do it. 新建content_data_binding.xml在layout文件夹下新建一个布局文件，用于存放我们需要用到的view 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;data&gt; &lt;variable name="user" type="com.blue.androidlearningcode.databinding.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.name&#125;" /&gt; &lt;TextView android:id="@+id/email" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.email&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 可以看到，其实我们就是把activity_main.xml的两个TextView搬到了这个新的layout中。 修改activity_main.xml1234567891011121314151617&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:bind="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="user" type="com.blue.androidlearningcode.databinding.User"/&gt; &lt;/data&gt; &lt;include android:id="@+id/content" layout="@layout/content_data_binding" bind:user="@&#123;user&#125;" /&gt;&lt;/layout&gt; 其实使用include标签要注意的地方就是： 父布局的include标签需要加上： bind:user=”@{user}” ，通过这行代码来关联bean和layout 子布局也需要加上layout,data,variable等标签 OK，再次运行程序，我们会发现效果和上面的一样，显示出来了name和email的值。 点击事件的处理上面的Demo只是静态的，还无法对view的onClick，onLongClick 或者其他方法进行响应，那么接下来我们首先处理的就是onClick事件 修改MainActivity创建MyClickHandlers内部类 在FAB点击的时候弹出Toast 123456public class MyClickHandlers &#123; public void onFabClicked(View view)&#123; Toast.makeText(getApplicationContext(), "FAB clicked!", Toast.LENGTH_SHORT).show(); &#125; &#125; 修改activity_main.xml我们在这里使用FAB(FloatingActionButton)来演示： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:bind="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="user" type="com.blue.androidlearningcode.databinding.User"/&gt; &lt;variable name="handlers" type="com.blue.androidlearningcode.DataBindingTestActivity.MyClickHandlers"/&gt; &lt;/data&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;include android:id="@+id/content" layout="@layout/content_data_binding" bind:user="@&#123;user&#125;" /&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="20dp" app:srcCompat="@android:drawable/ic_dialog_info" android:onClick="@&#123;handlers::onFabClicked&#125;"/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/layout&gt; 绑定MyClickHandlers又来到了clean &amp; rebuild 时刻，在onCreate()里面进行绑定 12MyClickHandlers handlers = new MyClickHandlers();binding.content.setHandlers(handlers); // binding content layout click event 为什么上面的User是binding.setUser()，而这里是binding.content.setHandlers()呢： 这个问题很有趣，细心的童鞋应该是可以发现的，原因在xml的代码里 OK，let‘s run it！！! 我们虽然没有在代码里面重写onClickListener和onClick方法，但是通过DataBinding的方式还是成功实现了view的onClick()，至于上面的name和email的更新，就是下面要讲的了。 使用Observablues动态更新UI推动人类进步的，其实是懒惰。为了能够少写两行代码，人类总是可以发明出各种新技术。例如：Observablues Question：有没有办法在数据变化的时候让UI自动刷新呢？ 答案当然是有的，let me show you： 修改User类1234567891011121314151617181920212223242526public class User extends BaseObservable&#123; private String name; private String email; @Bindable public String getName() &#123; return name == null ? "" : name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; @Bindable public String getEmail() &#123; return email == null ? "" : email; &#125; public void setEmail(String email) &#123; this.email = email; notifyPropertyChanged(BR.email); &#125;&#125; User继承BaseObservable 每个getter()加上注解@Bindable 每个setter()加上notifyPropertyChanged(BR.xxx); - BR在rebuild后自动生成 修改MainActivity我们只需要改一个地方：onFabClicked() 12345public void onFabClicked(View view)&#123; Toast.makeText(getApplicationContext(), "FAB clicked!", Toast.LENGTH_SHORT).show(); user.setName("BlueLzyzzz"); user.setEmail("blueblueblue@163.com");&#125; 我们并没有给textview设置text，而是给user的name和email重新赋值，看一下在FAB点击的时候UI会不会跟随data进行动态刷新。 run the project 。。。。。and 回头看上面的动图，哈哈哈~ 使用ObervablueFields动态更新UI其实上面已经把DataBinding的基本用法讲的差不多了，通过实践的方式一步步学习DataBinding，我觉得还是比较快速和容易上手的。 至于ObervablueFields，它其实也是为了能够减少代码量，当一个Bean没有那么多属性的时候，我们不需要写这么多的get和set方法，使用ObervablueFields只需要通过两行代码即可实现相同效果。 下面是Demo： 修改User类加上age属性： 123456// 使用ObservableFieldpublic static ObservableField&lt;String&gt; age = new ObservableField&lt;&gt;();public static ObservableField&lt;String&gt; getAge() &#123; return age;&#125; 修改content_data_binding.xml多加一个TextView 12345&lt;TextView android:id="@+id/age" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.age&#125;" /&gt; 修改MainActivity修改onFabClicked() 123456public void onFabClicked(View view)&#123; Toast.makeText(getApplicationContext(), "FAB clicked!", Toast.LENGTH_SHORT).show(); user.setName("BlueLzyzzz"); user.setEmail("blueblueblue@163.com"); User.age.set("20");&#125; 其实就是多加了一行，User.age.set(“20”); 因为age是静态变量，所以可以直接引用。 效果嘛。。还是回头看动图吧~ 在实际项目中，通常一个API返回的Bean都会有十几个属性，多的可能有几十个，我们不可能一个个去写getter和setter还有@Bindable，这时候可以通过ObervablueFields来减少工作量，也可以通过插件来自动生成需要的代码。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DataBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况还有书籍推荐]]></title>
    <url>%2Farticles%2Frecommand_book_and_movie0821.html</url>
    <content type="text"><![CDATA[转眼就到了8月下旬，这个月还没写过博客呢 由于最近忙于求职&amp;入职，只能写点 修仙 休闲的文章了 今天给大家推荐一下辞职之后，暑假期间看过的书籍 近况我在5月底的时候从上一家公司离职了，原计划是和高考的同学们一起，开开心心过个暑假，再开开心心一起去上学 (工作- -)，所以呢，从6月份开始，就计划着去旅游，空闲时间看看书，看看电影，也不觉得时间过得很快。没想到去完旅游回来，一看银行账户的余额已经所剩无几了，吓得我赶紧开始投简历找工作，重新加入到搬砖的大军当中。 大家看到我的最近一篇博客是7月23号的，为什么半个月都没更新呢？因为在这个求职的过程中，我的心态还是比较轻松的，去面试的第一家公司就成功拿到了offer，后来去其他公司面试的时候都比较有底气，也不担心找不到工作，就是抱着找到合适的公司再入职的心态，结果一直到了8月初才找到心仪的公司。 趁还没有入正题之前，稍微提一下Android面试的常见问题和需要的知识储备吧，我面的是高级Android工程师，所以基本上没有公司直接问我Activity生命周期，启动方式这种简单的理论性问题了，而是结合具体的场景，例如：页面有3级，点击推送后直接打开第三级的页面，我需要从第三级直接回到第一级，需要怎么做？根据我面试了好几家公司的情况来说，问的知识点基本上都包括在这几个方面： Java基础 - 集合用法，实现原理，理解面向对象特性 推荐书籍：《Java核心技术卷一》，《Effective Java》 Android技术 - Activity/Fragment，网络请求框架，Databinding，RxJava，Unit Test，屏幕适配，性能优化，RecyclerView，Kotlin 推荐资料：《Android开发艺术探索》，《Android源码设计模式解析与实战》，《Kotlin in Action》，Android Developer(学习新技术好去处) 其他：数据结构与算法 - 数组，链表，队列，设计模式 - 单例，观察者，工厂 推荐资料：《算法（第四版）》，《图解算法》，《Head First 设计模式》 PS: 有条件的可以看英文版，毕竟翻译过来意思没有原版的直接清晰。 唠唠叨叨了这么多，也算是对近期求职过程的一个记录吧。好了，终于可以开始进入正题了，每本书会加上我个人的看法（不喜欢的评论&amp;点赞就好了，哈哈哈） 书籍六月：推荐书籍： 疯狂Java讲义 学习Java的人应该都听过这本书吧，甚至很多人的第一本入门书籍就是它了，作为找工作复习Java基础用，代码案例巨多，可以和Head First Java配合一起看，至于《Java核心技术》，个人觉得对于零基础的小白来说还是太难了，很多概念不好理解，需要通过代码运行看结果才容易掌握。 推荐指数：5星 Android开发进阶-从小工到专家 面向Android中级开发者的进阶书籍，可惜里面的知识点讲解都比较碎片化，不是很系统，而且错别字很多，看了几章就看不下去了，作为一个Android开发，不推荐大家看这本书，进阶的话推荐《Android开发艺术探索》 推荐指数：2星 无言的宇宙 隐藏在24个数学公式背后的故事 - 从副标题可以看出来，这本书其实就是一本关于数学公式的科普书籍，学渣表示很多都看不太懂，只能当成小说来看了。针对豆瓣评分8.9来说，我的建议是：大家如果数学基础比较好的话，可以尝试跟着作者的思路，去体会隐藏在数学公式背后的美妙之处，对于数学基础不太好的人，例如我，就只能看懂一部分，剩下的，阿弥陀佛。 推荐指数：3星 意志力 这本书我是和《自控力》来比较的，感觉比较偏向于理论，没有《自控力》的实操性强，也就是偏向于道，而缺少了术，因为全书的每个章节都会提出大量的案例，对意志力这个主题进行讲解，所以如果对人的大脑运行机制有兴趣的童鞋，可以找来看一看，如果只是想着如何提高意志力的方法，那么还是推荐《自控力》这本书， 里面有很多的指引和具体的实施方法。 推荐指数：3星 力哥说理财-互联网金融 emmm…怎么说呢，这本书专注于互联网金融的入门理论，也就是介绍相关的基础知识，关于：余额宝，P2P，众筹等新兴的互联网金融产业都有详细的介绍，小白可以把这本书作为入门书籍。 推荐指数：4星 人间失格 6月看的唯一一本小说，而且还是给我留下了深刻印象的小说。 介绍一下作者： 太宰治（1909-1948），日本文学的重要人物，“私小说”领域的天才作家。 太宰治出身于东北地主家庭，从小体弱敏感；中学开始迷上文学，崇拜泉镜花和芥川龙之介；高中时立志于文学创作，开始发表随笔等。 1935年凭借《逆行》获得第一届芥川奖候补作品；1945年《女学生》获第四届北村透谷文学奖。 太宰治后期创作的《人间失格》、《斜阳》、《维庸之妻》、《Goodbye》等被认为是其最优秀的作品。 太宰治一生多次求死，在自我放逐和沉沦中结束了自己的生命。 直至1948年自杀，在他短暂的一生中，他向世人展示了无与伦比的文学才华，留下众多不朽佳作。其多数作品采用“私小说”的自我告白形式，充满了纯粹而敏锐的感受性，吸引着一代又一代的年轻人。 《人间失格》这本书，我个人感觉就像太宰治的生平一样，性格敏感而又具有浓厚的自我意识，在清醒的自我和混沌的世俗中生存，最终选择了自杀这个结局。看完以后仿佛我成了书中的主角，深深地体会到主角的痛苦与无奈。这也是小说的成功之处，能让读者产生代入感。 推荐指数：4星 把时间当作朋友 李笑来老师，大家应该都很熟悉了，近年来他身上最耀眼的标签是“中国最大的比特币玩家”，哈哈哈。在这里只评论书，不评论人，这本书写得是真的好，作者本身的经历得出来的经验，足以让我们这些后辈从中吸取教训并得以成长。 推荐指数：5星 看过但不推荐的书籍： 共富精神 这本书是2017年出版的，针对最近比较火的共享经济进行分析，作者通过社会学，经济学，心理学等各个学科的综合，针对“共富型社会”以及“共享经济”作出说明，为什么这会是未来社会的潮流。然后指引我们要朝着“共赢”，“共富”的目标去努力，对我个人而言，这本书比较像是政府报告。。也可能是我的意识形态还达不到作者的高度吧。anyway。 推荐指数：1星 一本书读懂投资理财学 京东99块10本买回来的书，里面大部分观点在基金三部曲里面都已经看过了，所以，快速翻了一遍。over 推荐指数：1星 语言的力量 这本书我就不放图片了，有兴趣的可以去豆瓣读书看简介，烂书，个人不推荐！ 七月：推荐书籍： 人类群星闪耀时 这本书让我记住了作者的名字：斯蒂芬·茨威格 ，并且饶有兴趣地百度了一下作者的简介，主要是因为这本书对每个小故事里面的人物描写刻画实在是太真实了，看完以后我仿佛已经认识了故事中的主人公，知道他的长相，脾性以及做事的风格。具有这种侧写能力的人，除了《龙族》里面的诺诺，暂时也只有你了，斯蒂芬。 推荐指数：5星 寻找时间的人 说实话，这本书其实我并没有太看懂，后面有时间再读一遍吧。 推荐指数：3星 月亮与六便士 The Moon and Sixpence，你是选择月亮呢，还是选择六便士呢？正如现在很多年轻人面临的玫瑰和面包的选择一样，在这里我想引用简介里的一段话： “满地都是六便士，他却抬头看见了月亮。” 银行家查尔斯，人到中年，事业有成，为了追求内心隐秘的绘画梦想，突然抛妻别子，弃家出走。他深知：人的每一种身份都是一种自我绑架，唯有失去是通向自由之途。 在异国他乡，他贫病交加，对梦想却愈发坚定执着。他说：我必须画画，就像溺水的人必须挣扎。 在经历种种离奇遭遇后，他来到南太平洋的一座孤岛，同当地一位姑娘结婚生子，成功创作出一系列惊世杰作。就在此时，他被绝症和双目失明击倒，临死之前，他做出了让所有人震惊的决定…… 人世漫长得转瞬即逝，有人见尘埃，有人见星辰。查尔斯就是那个终其一生在追逐星辰的人。 希望你也能成为，终其一生在追逐星辰的人。 推荐指数：5星 别闹了，费曼先生 理工科的学生，或者是程序员们，推荐你们都去看一看 *推荐指数：满分💯 * 不推荐书籍： Python编程导论 历史不忍细看 这两本书都是比较空洞的，没有细节和实质性内容，所以还没有看完就丢到一边了。 最后转眼就到8月底了，这个月的第一篇文章，接下来应该就能恢复正常的更新节奏了，打算写点Android的常用技术，想到哪里就写到哪里吧，哈哈~]]></content>
      <categories>
        <category>日常说</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Scrapy及踩坑经验]]></title>
    <url>%2Farticles%2Finstall_scrapy_for_mac.html</url>
    <content type="text"><![CDATA[Mac下安装Scrapy 折腾了一下午的踩坑坑坑经验 前言 系统 - macOS 10.13.6 Python - 2.7 和 3.6 共存 Mac出厂自带python2.7版本，后面我又自己安装了Python3.X，于是电脑里就有两个版本共存的情况，今天打算装个Scrapy玩玩，不了解Scrapy的童鞋可以看官方文档：Scrapy官网文档 结果没想到一装就是3小时，中间遇到了无数的坑，最终通过曲线救国的方式才把Scrapy装上了，于是趁热打铁，赶紧把踩坑经验写下来，方便以后自己查阅，也方便遇到类似问题的朋友们参考。 主要遇到的问题有以下几个： pip install scrapy 安装速度过慢 OSError: [Errno 1] Operation not permitted: ‘/tmp/pip-HG6JNq-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info scrapy: command not found 这几个问题在后面会有解决方法，首先我们按照正常的安装流程走一遍。 第一步：安装pip这里默认大家都已经安装了Homebrew，如果还没了解的，可以百度或者看看我的另一篇博客：Mac安装python3以及问题总结 终端输入： 1sudo python get-pip.py 即可完成pip安装 第二步：安装Scrapy终端输入： 1sudo pip install Scrapy 如果一切顺利的话（当然这个概率比较小。。），你会看到安装成功的语句，输入 scrapy -v 就能看到scrapy的版本号了，目前最新的是1.5.1。 那么如果没有成功安装，而是报错了怎么办呢。。根据我google到的情况，报错的情况真的是千奇百怪，所以这里我也只能列举自己遇到的，至于其他的只能向搜索引擎求助了。 第三步：踩坑经验1.pip install scrapy 的下载速度过慢解决方式：更换下载源，可以使用国内的豆瓣 1pip install -i https://pypi.douban.com/simple scrapy 2.安装过程报错（1） OSError: [Errno 1] Operation not permitted: ‘/tmp/pip-HG6JNq-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info 解决方法：忽略已经安装的six包 1sudo pip install scrapy --ignore-installed six 参考来源：Six issue when installing package （2） [Errno 13] Permission denied 解决方法：通过 users 文件夹安装 1python -m pip install --user google-assistant-sdk[samples] 参考来源：Permission denied How i solve this problem 3. 安装成功但是报command not found错误我主要是在这一步卡了很久，网上查到的资料是说，报错原因是环境变量没有配置好，但是我加入环境变量后也还是不行，所以在这里我先附上参考链接，对我没用可能对其他人有用呢。 Scrapy not installed correctly on mac? bash: scrapy: command not found 哪怕我把scrapy的路径加入到环境变量中，还是有这个错误。于是我先把scrapy卸载掉，然后再用python3来安装，没想到就完美解决这个问题了。。 只需一行 1pip3 install scrapy 安装完的效果就是文章开头的截图，输入scrapy -v 能看到版本信息，也能通过scrapy来创建爬虫项目了。 一点猜测：由于mac自带python2.7，在安装的过程中scrapy成功装上了，但是环境变量不对，导致找不到scrapy正确的执行路径。Stack Overflow上也有类似的问题，但是暂时还没有人解答。 Python: -bash: scrapy: command not found on Mac OS 这个哥们遇到的问题和我一模一样，成功安装，可以导入，环境变量也加了，就是死活找不到scrapy。 关于Scrapy安装经验暂时就这么多，如果有大神能够解除疑惑，欢迎多多交流。]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy入门-第一个爬虫项目]]></title>
    <url>%2Farticles%2Ffirst_scrapy_project.html</url>
    <content type="text"><![CDATA[Scrapy初体验 实现一个最简单的爬虫项目 前言千辛万苦安装完Scrapy，当然要马上体验一下啦。详见：Mac安装Scrapy及踩坑经验 本文采用循序渐进的方式，一步步写出一个完整的爬虫，包括 使用Scrapy创建项目 使用Scrapy爬取整个网页 使用Scrapy爬取所需元素 使用Scrapy保存数据到json文件 相当于Scrapy入门教程中的基础篇，如果希望学习Scrapy这个强大的爬虫框架，只要懂一点点Python语法，可以跟着一起来动手了。 创建项目只需一行命令即可创建名为 tutorial 的Scrapy项目： 1scrapy startproject tutorial 然后 cd tutorial 进入项目目录，通过 tree tutorial 命令看一下整个项目的结构 12345678910tutorial/ scrapy.cfg # deploy configuration file tutorial/ # project's Python module, you'll import your code from here __init__.py items.py # project items definition file middlewares.py # project middlewares file pipelines.py # project pipelines file settings.py # project settings file spiders/ # a directory where you'll later put your spiders __init__.py OK，这是创建项目的第一步，然后我们再通过 12cd /tutorialscrapy genspider QuoteSpider 创建爬虫的模板文件，QuoteSpider就是文件名，在当前目录下生成一个QuoteSpider.py文件 然后我们通过PyCharm打开这个 tutorial 项目 项目结构图： 在 QuoteSpider.py 我们开始编写爬虫代码，其他几个文件都有自己的作用，但是本文暂时不需要用到，所以就不介绍了。 有需要的童鞋可以参考知乎的这篇文章： Scrapy爬虫框架教程（一）– Scrapy入门 爬取整个网页修改QuotesSpider.py文件 1234567891011121314import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): page = response.url.split("/")[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) name 是爬虫的名字，作为唯一标识不可重复 parse() 方法进行页面解析，我们这里直接保存为html文件 写完代码，怎么开始运行呢？ 终端输入： scrapy crawl quotes 就能看到当前目录下多了两个html文件： 这就完成了我们最最简单的一个爬虫了，总结一下： scrapy startproject name 创建项目 scrapy genspider spider_name 创建爬虫文件 编写代码 scrapy crawl spider_name 运行爬虫 提取所需元素通过爬取整页，我们掌握了最基本的爬虫，但是实际上，通常我们需要的只是网页中一部分对我们有用的信息，那么就涉及到了元素的过滤和筛选。在Scrapy中，我们可以通过 shell 来获取网页元素。 举个例子： 1scrapy shell 'http://quotes.toscrape.com/page/1/' 你会看到以下信息： 1234567891011121314152018-07-22 23:59:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/1/&gt; (referer: None)[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x103186400&gt;[s] item &#123;&#125;[s] request &lt;GET http://quotes.toscrape.com/page/1/&gt;[s] response &lt;200 http://quotes.toscrape.com/page/1/&gt;[s] settings &lt;scrapy.settings.Settings object at 0x10400f7f0&gt;[s] spider &lt;DefaultSpider 'default' at 0x1042f6dd8&gt;[s] Useful shortcuts:[s] fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s] fetch(req) Fetch a scrapy.Request and update local objects [s] shelp() Shell help (print this help)[s] view(response) View response in a browser&gt;&gt;&gt; 在这里，我们再通过css选择器来选择所需的元素。例如： 12&gt;&gt;&gt; response.css('title::text').extract_first()'Quotes to Scrape' title：网页中的标签，也就是我们所需要的元素 extrac_first() ：相当于返回title中的第一个值，因为css返回的是一个列表做个试验，我们这样写 response.css(‘title::text’).extract()输出结果为：[‘Quotes to Scrape’]，说明返回值就是一个列表 其他所有元素都能通过这个方式来得到，因此接下来我们通过一个完整的例子来实践一下。 获取所需元素并存到json文件目标：获取网页的text，author，tags元素，并保存下来 步骤1：获取所需的元素（通过CSS）123456for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; 这些标签我们可以从html文件中通过查看源码得到他们的层级关系 步骤2：完整的QuotesSpider.py代码1234567891011121314151617import scrapyclass QuotesSpider(scrapy.Spider): name = "quotes" start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.css('small.author::text').extract_first(), 'tags': quote.css('div.tags a.tag::text').extract(), &#125; 步骤3：保存数据到json文件通过以下命令： 1scrapy crawl quotes -o quotes.json -o：输出 quotes.json：保存的json文件名 最终保存下来的结果： 总结就以上的Demo而言，Scrapy这个爬虫框架的上手难度算是比较低的，不需要额外的配置，也没有很复杂的模板，基本达到了开箱即用的效果。而且编写代码的过程中也非常简单。一边阅读官方文档，一边自己操作，花了晚上2个小时的时间就能做出这样的效果，个人还是很满意的（为Scrapy打call~）。至于后面的进阶操作，还需要慢慢实践，不断踩坑总结。一起努力吧！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Room Entity使用]]></title>
    <url>%2Farticles%2Fandroid_room_entity_use.html</url>
    <content type="text"><![CDATA[Android Room 第二篇 - Entity使用 主要介绍entity的作用 说明：大部分译自Android Developers的Room官网指导文档第二篇，小部分自己查阅资料和理解后加上。 原文地址：https://developer.android.com/training/data-storage/room/defining-data 第一篇：Android Room概述 使用Room entities 来定义数据当你在使用Room的时候，定义了一组相关的字段作为一个实体。对于每个实体，都会通过在数据库里面创建一张表的方式来处理这些数据。 通常来说，Room 会为实体类中定义的每个字段在数据库中创建“列”。如果实体类中有某个字段你不想在数据库中进行存储的，你可以对这些字段使用@Ignore注解。 下面这个代码块展示了如何定义一个实体 1234567891011@Entitypublic class User &#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 为了能够保存某个字段，Room必须能够对它进行操作。你可以使用public修饰符，或者你可以提供getter和setter方法。如果你选择后者，记住Room是基于JavaBeans约定的。 主键每个实体必须定义至少一个字段作为主键。即使是实体只有一个字段，你仍然需要对该字段使用@PrimaryKey注解。同时，如果你想通过Room来自动分配ID，也可以设置@PrimaryKey的autoGenerate属性。如果实体有组合主键，你可以通过primaryKeys属性来说声明，下面是代码示例： 12345678@Entity(primaryKeys = &#123;"firstName", "lastName"&#125;)public class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 通常来说，Room会使用类名作为数据库表名。如果你希望自定义表名，在@Entity注解下设置tableName属性，下面是代码示例： 1234@Entity(tableName = "users")public class User &#123; ...&#125; 注意：在SQLite中，表名是不区分大小写的 和tableName属性类似。Room用变量名称作为数据库表的字段名称。如果你希望字段名和变量名不一样，在变量处加上@ColumnInfo注解，下面是代码示例： 1234567891011121314@Entity(tableName = "users")public class User &#123; @PrimaryKey public int id; @ColumnInfo(name = "first_name") public String firstName; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125; 索引和唯一性根据你操作数据的方式，可能你需要通过索引来提高查询数据库的速度。想要对实体添加索引，可以通过在@Entity注解下添加indices属性来实现，加上你想要添加索引的列名。下面是代码示例： 123456789101112131415@Entity(indices = &#123;@Index("name"), @Index(value = &#123;"last_name", "address"&#125;)&#125;)public class User &#123; @PrimaryKey public int id; public String firstName; public String address; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125; 有时候，一些字段需要具有唯一性。你可以通过在@Index注解下设置unique为true，即可强制实现该字段的唯一性。下面这段代码就防止firstName和lastName这两列具有相同的属性，保证其唯一性 123456789101112131415@Entity(indices = &#123;@Index(value = &#123;"first_name", "last_name"&#125;, unique = true)&#125;)public class User &#123; @PrimaryKey public int id; @ColumnInfo(name = "first_name") public String firstName; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125; 定义对象之间的关系由于SQLite是关系型数据库，你可以指定对象之间的关系。虽然大多数对象关系型数据库都匀速实体对象互相引用，但是Room是明确禁止的。如果你想知道这个决定背后的技术原因，可以参见：Understand why Room doesn’t allow object references. 虽然你不能使用直接关系，Room仍然允许你在实体之间定义外键。 例如，如果有另一个实体叫做Book，你可以在User实体下使用@ForeignKey注解来定义他们之间的关系，就像下面的代码段所示： 123456789101112@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = "id", childColumns = "user_id"))public class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = "user_id") public int userId;&#125; 外键是非常强大的，它能够允许你在引用实体发生改变时，指定当前实体做出相应操作。例如，当一个在@ForeignKey注解使用了onDelete = CASCADE 语句的User被删除了，你可以让SQLite删除这个User下所有的books 注意: SQLite 处理 @Insert(onConflict = REPLACE) 的时候看作是 REMOVE 和 REPLACE 操作，而不是单纯的UPDATE操作。这个方法会替换冲突值，同时也会对外键约束有影响。更多细节请看：SQLite documentation 创建嵌套对象有时，你希望将实体或普通旧Java对象（POJO）表达为数据库逻辑中的一个整体，即使该对象包含多个字段。在这些情况下，你可以使用@Embedded批注来表示要分解到表中子字段的对象。然后，你可以像查找其他单个列一样查询嵌入字段。 例如，我们的User类可以包含Address类型的字段，它表示名为street，city，state和postCode的字段的组合。要将组合列分别存储在表中，请在User类中包含使用@Embedded注释的Address字段，如以下代码段所示： 12345678910111213141516171819public class Address &#123; public String street; public String state; public String city; @ColumnInfo(name = "post_code") public int postCode;&#125;@Entitypublic class User &#123; @PrimaryKey public int id; public String firstName; @Embedded public Address address;&#125; 这个表示User对象的表包含具有以下名称的列：id，firstName，street，state，city和post_code。 注意：嵌套字段能够包含在其他嵌套内 如果实体具有多个相同类型的嵌入字段，则可以通过设置prefix属性使每个列保持唯一。然后，Room将提供的值添加到嵌入对象中每个列名称的开头。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Room</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Room概述]]></title>
    <url>%2Farticles%2Fandroid_room_overview.html</url>
    <content type="text"><![CDATA[Android Room 第一篇 - 概述 主要是Room功能和组件介绍，还有简单的使用例子 说明：大部分译自Android Developers的Room官网指导文档第一篇，小部分自己查阅资料和理解后加上。 原文地址：https://developer.android.com/training/data-storage/room/ 定义：Room 在SQLite上提供了一个抽象层，从而在操作SQLite的时候能够流畅的访问数据库。 为什么要有Room： 如果能够实现结构化数据的本地存储，那么对于App来说是一件意义非凡并且好处巨大的事情。 最常见的用图就是缓存相关数据。通过这个方式，当设备无法连接到网络时，用户仍然能够通过离线方式来浏览内容。当设备重新连接网络后，所有内容会通过服务器同步进行变更。由于Room已经为开发者考虑了以上的问题，因此我们强烈推荐使用Room来代替SQLite。然鹅，如果你一意孤行非要用的话，好吧我不拦你，自备梯子，直走右拐谢谢：Save Data Using SQLite. 构成 ：Room主要由三个组件构成： @Database：包含了数据库holder和一些服务，作为app持久化状态，关系型数据的底层连接的主要连接点。 使用@Database注解的类需要满足以下条件： 集成RoomDatabase的抽象类 包含实体列表，并且通过注解和数据库有所关联 包含一个无参抽象方法并且返回的类需要用@Dao注解 运行时，你可以通过 Room.databaseBuilder() orRoom.inMemoryDatabaseBuilder()两种方式来创建Database实例。 @Entity：用来注解实体类，@Database通过entities属性引用被@Entitiy注解的类，并利用该类的所有字段作为表的列明来创建表 @Dao：提供访问数据库的方法。 这三个组件之间的关系如下图： 使用：接下来举个小例子，包含了一个简单的数据库，里面有一个实体和一个DAO： 1.添加依赖Room依赖 12345678910111213141516dependencies &#123; def room_version = "1.1.1" implementation "android.arch.persistence.room:runtime:$room_version" annotationProcessor "android.arch.persistence.room:compiler:$room_version" // optional - RxJava support for Room implementation "android.arch.persistence.room:rxjava2:$room_version" // optional - Guava support for Room, including Optional and ListenableFuture implementation "android.arch.persistence.room:guava:$room_version" // Test helpers testImplementation "android.arch.persistence.room:testing:$room_version" &#125; 注意：这个是Room官方文档的依赖项，其中optional的可以不加，因为暂时不需要Rxjava。 2.开始正式体验Room首先创建实体类 - User.java 123456789101112131415@Entitypublic class User &#123; @PrimaryKey private int uid; @ColumnInfo(name = "first_name") private String firstName; @ColumnInfo(name = "last_name") private String lastName; // Getters and setters are ignored for brevity, // but they're required for Room to work. &#125; 然后是Dao - UserDao.java 12345678910111213141516171819@Daopublic interface UserDao &#123; @Query("SELECT * FROM user") List&lt;User&gt; getAll(); @Query("SELECT * FROM user WHERE uid IN (:userIds)") List&lt;User&gt; loadAllByIds(int[] userIds); @Query("SELECT * FROM user WHERE first_name LIKE :first AND " + "last_name LIKE :last LIMIT 1") User findByName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user); &#125; 最后是Database类 - AppDatabase.java 1234@Database(entities = &#123;User.class&#125;, version = 1) public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao(); &#125; 创建完上面三个类，就可以通过下面这段代码创建一个数据库实例 12AppDatabase db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, "database-name").build(); 个人总结：这篇文章主要是介绍了room的组成部分以及简单的使用方式。一句话总结就是，Entity用于建表，Dao用于CRUD，Database用于创建数据库。 接下来我会把Room这一系列的文章都翻译完，最后再通过一个小项目，达到理论实践都掌握的程度，真正理解Room这个数据库框架。 第二篇：Android Room Entity使用 第三篇：Android Room Dao使用 第四篇：Android Room迁移数据库 第五篇：Android Room测试数据库 第六篇：Android Room引用复杂数据 第七篇：Android Room实战 最后，这是我第一次翻译外文技术文章，肯定会有词不达意或者错误的地方，希望大家批评指正，共同进步。 参考： Android Room with a View Android Persistence codelab Android Architecture Components samples]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Room</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-多线程]]></title>
    <url>%2Farticles%2Fjava_se_multithreading.html</url>
    <content type="text"><![CDATA[Java基础的第五篇，也是最后一篇-多线程 多线程1.线程的创建和启动通过集成Thread类创建线程类 定义Thread类的子类，并重写run()方法 创建Tread子类的实例 调用start()方法启动线程 举个例子： 123456789101112131415161718192021222324public class FirstThread extends Thread &#123; private int i; public void run()&#123; for (;i&lt;100;i++) &#123; System.out.println(getName() + " " + i); &#125; &#125; public static void main(String[] args) &#123; for (int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName()); if (i == 20) &#123; // 创建并启动第一个线程 new FirstThread().start(); // 创建并启动第二个线程 new FirstThread().start(); &#125; &#125; &#125;&#125; 运行结果 可以看到一共有三个线程：main Thread0 Thread1 后面两个是新建的。main是程序执行后创建的。 实现Runnable接口创建线程类 定义Runnable接口的实现类，并重写run()方法 创建Runnable实现类的实例 调用start()方法启动线程 举个例子： 12345678910111213141516171819202122232425public class SecondThread implements Runnable&#123; private int i; @Override public void run() &#123; for (; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; &#125; public static void main(String[] args) &#123; for (int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 20) &#123; SecondThread st = new SecondThread(); new Thread(st,"新线程1").start(); new Thread(st,"新线程2").start(); &#125; &#125; &#125;&#125; 运行结果和FirstThread类似，就不详细描述了。 这里有一点区别：FirstThread里面新建Thread是可以直接调用start()方法，因为是Tread的子类，但是Runnable里面只是线程对象的target，不能直接调用runnable.start() 使用Callable和Future创建线程 创建Callable接口实现类，并实现call()方法 创建Callable实例使用FutureTask包装 使用FutureTask对象作为Thread对象的target创建并启动线程 调用FutureTask的get()方法获得返回值 举个例子： 12345678910111213141516171819202122232425262728293031public class ThirdThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call()&#123; int i=0; for (;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; return i; &#125; public static void main(String[] args) &#123; ThirdThread rt = new ThirdThread(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(rt); for (int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 20)&#123; new Thread(task,"有返回值的线程").start(); &#125; &#125; try &#123; System.out.println("子线程返回值：" + task.get()); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 运行结果和前面的类似，不过最后会输出call()方法的返回值 说完了Thread,Runnable,Callable三种创建线程的方式，我们来比较一下 采用Runnable、Callable接口的方式： 线程只是实现接口，还可以继承其他类 多个线程可以共享一个target对象，适合多个相同线程处理同一份资源的情况 劣势：需要使用Thread.currentThread()方法访问当前进程 采用Thread的优势正好是上面两种方法的劣势。 2.线程的生命周期新建和就绪状态使用new关键字创建对象就处于新建状态，使用start()方法之后就处于就绪状态，至于什么时候开始执行，要看JVM的调度。 运行和阻塞状态调用了sleep()方法，调用了一个阻塞式IO方法，等待某个通知…都会让线程阻塞 相对应的就是运行状态，这一块知识点有点像操作系统的CPU轮换。 线程死亡 run()或call()方法执行完成，线程正常结束 线程抛出未捕获的异常 直接调用stop() 这三种情况都会让线程结束 3.线程同步线程安全问题在这里我们可以用一个经典的问题-银行取钱问题，来进行讲解。 用户输入账户密码，系统判断是否正确 用户输入取款金额 系统判断余额是否大于取款金额 大于则取款成功，小于则取款失败 首先定义Account类,具有账户名和余额两个属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Account &#123; private String accountNo; private double balance; public Account()&#123;&#125; public Account(String accountNo,double balance)&#123; this.accountNo = accountNo; this.balance = balance; &#125; public int hashCode()&#123; return accountNo.hashCode(); &#125; public String getAccountNo() &#123; return accountNo; &#125; public void setAccountNo(String accountNo) &#123; this.accountNo = accountNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; public boolean equals(Object obj)&#123; if (this == obj)&#123; return true; &#125; if (obj != null &amp;&amp; obj.getClass() == Account.class)&#123; Account target = (Account) obj; return target.getAccountNo().equals(accountNo); &#125; return false; &#125;&#125; 然后定义一个取钱的线程类 12345678910111213141516171819202122public class DrawThread extends Thread&#123; private Account account; private double drawAmount; public DrawThread(String name, Account account, double drawAmount)&#123; super(name); this.account = account; this.drawAmount = drawAmount; &#125; public void run()&#123; if (account.getBalance() &gt;= drawAmount)&#123; System.out.println("取钱成功:" + drawAmount); account.setBalance(account.getBalance() - drawAmount); System.out.println("余额为：" + account.getBalance()); &#125;else&#123; System.out.println(getName() + "取钱失败，余额不足"); &#125; &#125;&#125; 最后还有主程序： 1234567public class DrawTest &#123; public static void main(String[] args) &#123; Account acct = new Account("1234567",1000); new DrawThread("甲",acct,800).start(); new DrawThread("乙",acct,800).start(); &#125;&#125; 启动两个子线程取钱，会出现什么结果呢？ 这种结果明显是不对的，这就是我们上面所说的线程同步问题。 之所以出现这样的结果，是因为run()方法不具有同步安全性，一旦程序并发修改Account对象，就很容易出现这种错误结果。 为了解决这个问题，Java多线程引入了同步监视器。语法如下： 1234synchronized(obj) &#123; // 同步代码块&#125; 我们再修改一下DrawThread的代码： 1234567891011121314public void run()&#123; // 使用account作为同步监视器，任何进程进入以下同步代码块之前 // 必须先获得对account账户的锁定- 其他县城无法获得锁，也就无法修改它 // 这种做法符合 加锁-修改-释放 的逻辑 synchronized (account) &#123; if (account.getBalance() &gt;= drawAmount) &#123; System.out.println("取钱成功:" + drawAmount); account.setBalance(account.getBalance() - drawAmount); System.out.println("余额为：" + account.getBalance()); &#125; else &#123; System.out.println(getName() + "取钱失败，余额不足"); &#125; &#125;&#125; 再次运行就能得到正确结果： 同步锁(Lock)Java 5开始，Java提供另一个线程同步机制-通过显示定义同步锁对象实现同步。 通常使用格式如下： 1234567891011class x &#123; public void m()&#123; lock.lock(); // 加锁 try&#123; // 需要线程安全的代码 &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 通过lock和unlock来显示加锁，释放锁。 除了上面所说的知识点，还有线程池，死锁，线程通信等，由于这些知识点都属于高级Java特性，我会在后面的进阶篇再进行总结。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-类加载机制与反射]]></title>
    <url>%2Farticles%2Fjava_se_reflect.html</url>
    <content type="text"><![CDATA[Java基础第四篇-类加载机制与反射 类加载机制与反射1.类的加载、连接和初始化JVM和类一个Java程序启动一个Java虚拟机进程，当系统被终结时，JVM进程也会被终止。 有以下几种情况： 程序运行到最后正常结束 程序使用System.exit()结束程序 程序遇到未捕获的异常或者错误而结束 程序平台强制结束了JVM进程 类的加载首先将类的class文件读入内存，创建一个java.lang.class对象。 类的连接当类被加载之后，系统会生成一个对应的Class对象，接着把类的二进制数据合并到JRE中 类的初始化虚拟机对类进行初始化，主要是静态Field进行初始化 2.类加载器类加载器负责将.class文件加载到内存中，并生成java.lang.class对象。 类加载机制 全盘负责：当一个雷加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由此类加载器负责载入 父类委托：先让parent类加载器试图加载该Class 缓存机制：缓存机制会保证所有加载过的Class都会被缓存，当程序需要使用某个Class时，类加载器先从缓存区找，当缓存区不存在该Class对象，系统才会读取该类对应的二进制数据，转换成Class对象，存入缓存区。这也就是为什么修改了Class，不许重新启动JVM，程序新修改才会生效。 这个例子可以获取根类加载器的核心类库： 1234567891011121314151617181920212223public class ClassLoaderPropTest &#123; public static void main(String[] args) throws IOException &#123; ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); System.out.println("系统类加载器：" + systemLoader); Enumeration&lt;URL&gt; eml = systemLoader.getResources(""); while (eml.hasMoreElements()) &#123; System.out.println(eml.nextElement()); &#125; ClassLoader extensionLoader = systemLoader.getParent(); System.out.println("拓展类加载器：" + extensionLoader); System.out.println("拓展类加载器的加载路径" + System.getProperty("java.ext.dirs")); System.out.println("拓展类加载器的Parent:" + extensionLoader.getParent()); &#125;&#125; 打印结果： 12345系统类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2file:/IdeaProject/out/production/IdeaProject/拓展类加载器：sun.misc.Launcher$ExtClassLoader@60e53b93拓展类加载器的加载路径/Users/blue/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java拓展类加载器的Parent:null Extension Classloader被称为扩展类加载器，负责加载JRE的拓展目录中JAR包的类 从上面结果可以看出，系统类加载器的家在路径是当前程序运行路径，拓展类加载器的加载路径是jdk路径，但是拓展类加载器的父加载器是null，说明并不是根类加载器。 最后总结一下类加载器加载Class的步骤 检测Class是否再如果，如果有-&gt; step 8 如果父类加载器不存在-&gt; step 4，如果父类加载器存在-&gt; step 3 请求使用父类加载器去载入Class，成功-&gt; step 8，失败-&gt; step 5 请求使用跟雷加载器载入Class，成功-&gt; step 8，失败-&gt; step 5 当前类加载器尝试寻找Class文件，找到-&gt; step 6，失败-&gt; step 7 从文件中载入Class,成功-&gt; step 8 抛出ClassNotFound异常 返回java.lang.class对象 3.通过反射查看类信息获得Class对象由于每个类被加载后，系统都会生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类，获得Class对象的方式如下: 使用Class类的forName(String clazzName)方法，参数是某个类的全限定类名 使用某个类的class属性获取对应的Class对象，例如：Person.class 使用某个对象的getClass(0方法 从Class中获取信息大致包含了以下几个方法： Constructor getConstructor(Class&lt;?&gt;…parameterTypes):返回指定构造器 Constructor&lt;?&gt;[] getConstructors():返回此类所有构造器 Method getMethod(String name,Class&lt;?&gt;…parameterTypes):返回指定方法 Method[] getMethods():返回此类所有public方法 Field getField(String name):返回此类指定Field Field{} getFields():返回此类所有public Field … 4.利用反射生成并操作对象创建对象通过反射来生成对象有以下两种方式： 使用Class对象的newInstance()方法 先使用Class对象获取指定的Constructor对象,在调用Constructor对象的newInstance()方法。 举个例子： 12345private Object createObject(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class&lt;?&gt; clazz = Class.forName(className); return clazz.newInstance();&#125; 调用方法生成对象后，就可以通过getMethod()方法或者getMethods()方法来获取方法。 再通过invoke()方法来执行 访问属性值通过getFields()或者getField()方法可以获取Class对象的Field。可以用以下两组方法来读取或者设置Field值 getXxx(Object obj):获取Field的属性值 setXxx(Object obj, Xxx val)：将obj对象的Field设置成val值]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-IO]]></title>
    <url>%2Farticles%2Fjava_se_io.html</url>
    <content type="text"><![CDATA[Java基础第三篇-IO Charter 15 输入/输出主要是总结了一下文件操作以及序列化，NIO。 1.File类访问文件名相关的方法： String getName() String getPath() File getAbsoluteFile() String getAbsolutePath() String getParent() 文件检测相关方法 boolean exists() boolean canWrite() boolean canRead() boolean isFile() boolean isDirectory() 获取常规文件信息 long lastModified() long length() 文件操作相关方法 boolean createNewFile():如果File对象对应文件不存在，该方法会新建一个指定的新文件 boolean delete():删除File对象对应的文件或路径 目录操作相关方法 boolean mkdir():创建一个File对象对应的目录 String[] list():列出File对象所有子文件名和路径名 File[] listFiles(): 列出File对象所有子文件和路径 static File[] listRoots():列出系统所有根路径 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FileTest &#123; public static void main(String[] args) &#123; File file = new File("."); System.out.println(file.getName()); System.out.println(file.getParent()); // 相对路径的父路径 System.out.println(file.getAbsoluteFile()); // 绝对路径 System.out.println(file.getAbsoluteFile().getParent()); // 上一级路径 try &#123; File tmpFile = File.createTempFile("aaa",".txt",file); tmpFile.deleteOnExit(); File newFile = new File(System.currentTimeMillis() + ""); System.out.println("newFile是否存在：" + newFile.exists()); newFile.createNewFile(); // 创建文件 newFile.mkdir(); // 创建目录 String[] fileList = file.list(); // 列出当前目录下所有文件和路径 System.out.println("当前路径下所有文件和路径如下："); for (String fileName : fileList) &#123; System.out.println(fileName); &#125; File[] roots = File.listRoots(); // 列出所有磁盘根路径 System.out.println("系统所有根路径如下"); for (File root : roots) &#123; System.out.println(root); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.Java的IO流InputStream/Reader:所有输入流的基类，前者是字节输入流，后者是字符输入流 OutputStream/Writer:所有输出流的基类，前者是字节输出流，后者是字符输出流 3.对象序列化是什么：实现序列化的Java对象转换成字符序列，这些字符序列可以保存到磁盘上。 为什么：为了让对象可以脱离程序的运行而独立存在。 主要是Serializable这个接口 使用对象流实现序列化1.创建一个ObjectOutputStream，这是一个输出流 1ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“Object.txt”)); 2.调用writeObject()方法输出可序列化对象 1oos.writeObject(per); 3.Person类实现Serializable接口 1234public class Person implements Serializable &#123; ... &#125; 4.使用ObjectOutputStream将Person对象写入磁盘文件 12345678910public class WriteObject &#123; public static void main(String[] args) &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“Object.txt”)))&#123; Person per = new Person(); oos.writeObject(per); // 将per对象写入输出流 &#125; &#125; &#125; 从二进制流中恢复Java对象1.创建ObjectInputStream输入流 1ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“Object.txt”)); 2.调用readObject()方法读取流中的对象 1Person p = (Person)ois.readObject(); 4.NIO由于流输入/输出一次只能处理一个字节，为了解决效率不高的问题，从JDK1.4开始加入了一些列改进输入/输出处理的新功能，这些功能简称新IO(NIO) 概述新IO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件，大大提高了处理输入\输出的速度 相关包如下： java.nio：包含于Buffer相关的类 java.nio.channels：包含Channel和Selector相关的类 java.nio.charset：包含字符集相关的类 java.nio.channels.spi：包含与Channel相关的服务提供者编程接口 java.nio.charset.spi：包含字符集相关的服务提供者编程接口 Channel和Buffer是其中核心。 Channel与传统的InputStream、OutputStream最大区别是它提供了一个map()方法，可以将数据映射到内存中。 Buffer本质上是一个数组，发送到Channel的对象都要先放到Buffer中，Channel读取数据也要到Buffer中读取。 Buffer中有3个重要概念 capacity:缓冲区的容量，创建后不可改变，不可为负值 limit:第一个不应该被读出或者写入的缓冲区位置索引,换句话说，这个索引后的区域都无法读写 position:用于指明下一个位置索引 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class BufferTest &#123; public static void main(String[] args) &#123; //创建Buffer CharBuffer buff = CharBuffer.allocate(8); System.out.println("capacity:" + buff.capacity()); System.out.println("limit:" + buff.limit()); System.out.println("position:" + buff.position()); // 存放数据 buff.put("a"); buff.put("b"); buff.put("c"); System.out.println("放入三个元素后：position: " + buff.position() ); // 调用flip() buff.flip(); System.out.println("执行flip后,limit:" + buff.limit()); System.out.println("执行flip后,position:" + buff.position()); //调用clear() buff.clear(); System.out.println("执行clear后,limit:" + buff.limit()); System.out.println("执行clear后，position:" + buff.position()); // 读取数据 buff.get(2); System.out.println("执行读取数据后，position:" + buff.position()); System.out.println("执行读取数据后，内容并没有被清除:" + buff.get(2)); &#125;&#125; 打印结果： 123456789capacity:8limit:8position:0放入三个元素后：position: 3执行flip后,limit:3执行flip后,position:0执行clear后,limit:8执行clear后，position:0执行读取数据后，position:0 flip():把limit设置为position所在位置，将position设置为0，也就是做好输出数据准备 clear():将position设置为0，将limit设置为capacity，为再次输入数据做好准备，但是内容并没有被清空。 上面这个程序的执行过程就是 加入三个元素后,position来到了3 执行flip(),limit设置为position的值，也就是3，position设置为0 执行clear(),position设置为0 为什么在写入数据完成后，需要调用flip()方法呢，因为这个时候limit到了position的位置，也就是说后面的无数据区域都无法访问，避免了读到null值。 5.使用ChannelChannel最常用的三类方法shi map()\read()\write()，其中map()方法用于将Channel对应的数据映射成ByteBuffer 例子： 123456789101112131415161718192021222324public class FileChannelTest &#123; public static void main(String[] args) &#123; File f = new File("FileChannelTest.java"); try &#123; FileChannel inChannel = new FileInputStream(f).getChannel(); FileChannel outChannel = new FileOutputStream("a.txt").getChannel(); MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY,0,f.length()); Charset charset = Charset.forName("GBK"); outChannel.write(buffer); CharsetDecoder decoder = charset.newDecoder(); CharBuffer charBuffer = decoder.decode(buffer); System.out.println(charBuffer); &#125; catch (java.io.IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通过MappedByteBuffer将channel中的数据映射成ByteBuffer,然后写入FileChannel。 除了这种一次性把全部数据映射的方式，我们也可以采取类似传统字节流的方式 例子： 12345678910111213141516171819public class ReadFile &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("ReadFile.java"); FileChannel fcin = fis.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate(64); while (fcin.read(byteBuffer) != -1)&#123; byteBuffer.flip(); Charset charset = Charset.forName("GBK"); CharsetDecoder decoder = charset.newDecoder(); CharBuffer cbuff = decoder.decode(byteBuffer); System.out.println(cbuff); cbuff.clear(); &#125; &#125;&#125; 通过flip()和clear()进行读取的限制，防止读出null值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-集合]]></title>
    <url>%2Farticles%2Fjava_se_collection.html</url>
    <content type="text"><![CDATA[Java基础第二篇-集合 Java集合1 集合概述集合类主要由两个接口派生：Collection和Map Set:无序集合，不可重复 Queue:队列 List:有序集合，可以重复 2.Collection和Iterator接口Collection接口是List Set Queue接口的父接口，常用的有以下方法： boolean add(Object o):添加元素 boolean addAll(Collection c):把集合中所有元素添加到指定集合中,集合对象被改变了，则返回true void clear(): 清除集合所有元素 boolean contains(Object c):返回集合是否包含指定元素 boolean containsAll(Collection c):返回集合是否包含c中所有元素 boolean isEmpty():返回集合是否为空 boolean remove(Object c):删除指定元素 boolean removeAll(Collection c):从集合中删除集合c包含的所有元素 boolean retainAll(Collection c):从集合中删除集合c不包含的元素 int size():返回集合元素个数 Object[] toArray():把集合转换成数组 一个小例子： 123456789101112131415161718192021222324252627282930313233343536373839public class CollectionTest &#123; public static void main(String[] args) &#123; Collection c = new ArrayList(); c.add("aaa"); c.add(6); System.out.println("c集合的元素个数为：" + c.size()); c.remove(6); System.out.println("c集合元素个数为:" + c.size()); System.out.println("c集合是否包含'aaa':" + c.contains("aaa")); c.add("从零开始学Java"); Collection books = new HashSet(); books.add("从零开始学Java"); books.add("从零开始学Python"); System.out.println("集合c是否完全包含集合books:" + c.containsAll(books)); c.removeAll(books); System.out.println("c集合去掉books后的元素：" + c); books.retainAll(c); System.out.println("books集合和c集合的交集元素：" + books); &#125;&#125; 3.IteratorIterator:迭代器，主要用于遍历集合中的元素 boolean hasNext() Object next() void remove() 例子： 123456789101112131415161718192021222324public class IteratorTest &#123; public static void main(String[] args) &#123; Collection books = new HashSet(); books.add("aaa"); books.add("bbb"); books.add("ccc"); Iterator it = books.iterator(); while (it.hasNext())&#123; String book = (String) it.next(); System.out.println(book); if (book.equals("aaa")) it.remove(); &#125; &#125;&#125; 注意：Iterator必须依附于Collection。 4.Set集合Set集合不允许添加相同元素，判断方法是：equals，因此我们看看以下这个例子 12345678910111213public class SetTest &#123; public static void main(String[] args) &#123; Set books = new HashSet(); books.add("aaa"); boolean result = books.add("aaa"); System.out.println(result + "---&gt;" + books); &#125;&#125; 打印结果为： 1false---&gt;[aaa] 因为这两个String不是同一个对象，==返回结果为false，但是Set中判断方式是equals，所以返回的是true,Set中最终只有一个aaa HashSet类通过hashCode()方法得到hashCode值，然后再决定存储位置。 HashSet判断两个元素相等标准是 equals()和hashCode()同时相同 特点： &gt; 不能保证元素的排列顺序，顺序可能会发生变化 &gt; HashSet不是同步的 &gt; 集合元素值可以是null 举个例子： 12345678910111213141516171819202122232425262728293031323334353637public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet books = new HashSet(); books.add(new A()); books.add(new A()); books.add(new B()); books.add(new B()); books.add(new C()); books.add(new C()); System.out.println(books); &#125;&#125;class A&#123; public boolean equals(Object c) &#123; return true; &#125;&#125;class B&#123; public int hashCode() &#123; return 1; &#125;&#125;class C&#123; public int hashCode() &#123; return 2; &#125; public boolean equals(Object c) &#123; return true; &#125;&#125; 输出结果： 1[collection.A@5e2de80c, collection.B@1, collection.B@1, collection.C@2, collection.A@60e53b93] 两个A对象，两个B对象，一个C对象 说明只有equals()或者hashCode()相等，还是HashSet仍然把他们当成两个对象 TreeSet类特点：确保集合元素处于排序状态。 常见方法： 123456789101112131415161718192021222324 public static void main(String[] args) &#123; TreeSet nums = new TreeSet(); nums.add(5); nums.add(2); nums.add(10); nums.add(-2); System.out.println(nums); System.out.println("第一个元素：" + nums.first() +" 最后一个元素：" + nums.last()); System.out.println("小于4的元素集合：" + nums.headSet(4)); System.out.println("大于5的元素集合：" + nums.tailSet(5)); System.out.println("-5到2的集合: " + nums.subSet(-5,2)); &#125;&#125; 输出结果： 12345[-2, 2, 5, 10]第一个元素：-2 最后一个元素：10小于4的元素集合：[-2, 2]大于5的元素集合：[5, 10]-5到2的集合: [-2] 5 List集合常见方法： 1234567891011121314151617181920212223242526272829303132 public class ListTest &#123; public static void main(String[] args) &#123; List books = new ArrayList(); books.add("aaa"); books.add("bbb"); books.add("ccc"); System.out.println(books); books.add(1,"ddd"); // 在第二个位置插入ddd for (int i=0;i&lt;books.size();i++) &#123; System.out.println(books.get(i)); &#125; //删除第三个元素 books.remove(2); System.out.println(books); //判断指定元素的位置 System.out.println(books.indexOf("bbb")); books.set(1,"eee"); // 将第二个位置替换成eee System.out.println(books); &#125;&#125; 6.Queue集合特点：Queue用于模拟队列这种数据结构，具有FIFO-先进先出的特点。 常见方法： void add(Object c): 指定元素加入队列尾部 Object element(): 获取队列头部元素 boolean offer(Object c): 将指定元素加入队列尾部 Object peek(): 获取队列头部元素 Object poll(): 获取队列头部元素，并删除 Object remove():删除队列头部元素 7.Map特点：用于保存具有映射关系的数据，通常以键值对的形式存在. HashMap和Hashtable实现类 Hashtable是线程安全的，但是HashMap是线程不安全的。 Hashtable不允许使用null作为key和value，但是HashMap可以 注意：key是唯一不可重复的 8.操作集合的工具类：Collections排序操作： static void reverse(List list)：反转 static void shuffle(List list):随机排序 static void sort(List list):升序排序 static void sort(List list, Comparator c)：根据Comparator产生的顺序排序 static void swap(List list,int i,int j):将i和j元素交换 static void rotate(List list,int distance):将后distance元素往前移 查找、替换操作 static int binarySearch(List list,Object key)：二分查找(必须保证有序) static Object max(Collection coll):找出最大值 static Object min(Collection coll):找出最小值 static void fill(List list,Object obj):指定元素obj替换List所有元素 static int frequency(Collection c,Object c):返回指定元素出现次数 static int indexOfSubList(List source,List target):返回子List对象在父List第一次出现的位置 static int lastIndexOfSubList(List source,List target):返回子List对象在父List最后一次出现的位置 static boolean replaceAll(List list,Object oldVal,Object newVal):替换 同步控制Collections提供了多个synchronizedXxx()方法，用于把集合包装成线程同步的集合，从而解决多线程并发访问的安全问题。 例子： 12345678910111213public class SynchroinizedTest &#123; public static void main(String[] args) &#123; Collection c = Collections.synchronizedCollection(new ArrayList&lt;&gt;()); List list = Collections.synchronizedList(new ArrayList&lt;&gt;()); Set s = Collections.synchronizedSet(new HashSet&lt;&gt;()); Map m = Collections.synchronizedMap(new HashMap&lt;&gt;()); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-泛型]]></title>
    <url>%2Farticles%2Fjava_se_genericity.html</url>
    <content type="text"><![CDATA[Java基础第一篇 - 泛型 泛型1. 入门：泛型的引入是为了让Java能够记住集合中的数据类型，而不是统一用Object来处理。 例如： 12345678910111213public class ListErr &#123; public static void main(String[] args) &#123; List strList = new ArrayList(); strList.add(“aaaa); strList.add(5); for(int i=0; i&lt;strList.size(); i++) &#123; String str = strList.get(i); // 这里会报错，因为加了一个Int数据 &#125; &#125;&#125; 这个时候程序会报ClassCastException异常。 我们可以通过手动实现编译时检查类型。通过组合的方式来复用ArrayList类。 1234567891011121314151617181920212223242526272829class StrList &#123; private List strList = new ArrayList (); public boolean add(String ele) &#123; return strList.add(ele); &#125; public String get(int index) &#123; return (String) strList.get(index); &#125; public int size() &#123; return strList.size(); &#125;&#125;public class CheckType&#123; public static void main(String[] args) &#123; List strList = new ArrayList(); strList.add("aaa"); strList.add("bbb"); strList.add("ccc"); strList.add(5); //这行会导致编译失败 for (int i=0; i&lt;strList.size();i++) &#123; String str = (String) strList.get(i); &#125; &#125;&#125; 而当我们使用泛型的时候如下： 123456789101112public class GenericList &#123; public static void main(String[] args) &#123; List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); strList.add("aaa"); strList.add("bbb"); strList.add("ccc"); //strList.add(5); 这行会导致编译失败 for (String str : strList) &#123; System.out.println(str); &#125; &#125;&#125; 通过一个&lt;&gt;指定参数类型，就不会发生上面那种情况了。 2. 深入泛型泛型能够在哪些场景下使用呢？ 定义类，接口，方法时使用类型形参，这个类型形参将在声明变量，创建对象，调用方法时动态指定。 1234567891011121314151617public interface List&lt;E&gt; &#123; void add(E x); Iterator&lt;E&gt; iterator();&#125; // 定义接口时指定一个类型形参，形参名为E public interface Iterator&lt;E&gt; &#123; E next(); boolean hasNext();&#125; // 定义接口时指定了两个类型形参，形参名为K，V public interface Map&lt;K,V&gt; &#123; Set&lt;K&gt; keySet() V put(K key, V value)&#125; 除了在集合类里面使用泛型，我们也可以自定义泛型类,例如 12345public class Apple&lt;T&gt; &#123; private T info; public Apple()&#123;&#125;;&#125; 上面定义了一个带泛型声明的Apple类，这个T没有实际意义。但是我们可以生成Apple Apple等多个逻辑子类。 注意： 定义构造器不需要加&lt;&gt;。 3. 泛型类派生子类1public class A extends Apple&lt;T&gt;&#123;&#125; // 错误的，不能再包含类型形参 正确写法： 1public class A extends Apple&lt;String&gt; 这个时候，getInfo() 和 void setInfo(String info)都会由T被替换成为String 当然，也可以不写类型参数 1public class A extends Apple 这样写也是正确的，但是Java编译器可能会发出警告：使用了未经检查或者不安全的操作-这就是泛型检查的警告。 4. 并不存在泛型类其实ArrayList 类能否当成ArrayList的子类呢？ 可以的。 但是系统并没有生成新的class文件。 12345List&lt;String&gt; 11 = new ArrayList();List&lt;Integer&gt; 12 = new ArrayList();System.out.printLN(11.getClass() == 12.getClass()); 结果输出true.说明无论是实际类型参数是什么，他们运行时都是同样的类。 因为泛型在Java中都被当成同一类处理，内存中也只占用一块内存空间，因此静态方法，静态变量等声明不允许使用类型参数。 5. 使用类型通配符? 是元素类型未知的意思，也是Java里的类型通配符。 123public class test(List&lt;?&gt; c)&#123; ... &#125; 设定类型通配符的上限例如：定义一个类shape，有两个子类circle rectangle 再定义一个Canvas类 1234567public class Canvas &#123; public void drawAll(List&lt;Shape&gt; shapes) &#123; ... &#125;&#125; 这个时候，如果调用 12345List&lt;Circle&gt; circleList = new ArrayList&lt;&gt;(); Canvas c = new Canvas();c.drawAll(circleList); 就会报错，因为List并不是List的子类。我们可以考虑使用List&lt;?&gt;。 但是这个方法有个不好的地方，就是需要进行强制类型转换，过于繁琐。因此我们可以使用被限制的泛型通配符 List&lt;? extends shape&gt; 这就代表了所有shape泛型List的父类 那么像List，List这些都可以用了。因为这些都是shape的子类。 设定类型形参的上限1234public class Apple&lt;T extends Number&gt; &#123; T col;&#125; 表明了col的上限是Number类，传入参数时只能是Number或者Number类的子类。 6. 泛型方法用法格式如下： 1234修饰符&lt;T, S&gt; 返回值类型 方法名(形参列表) &#123; 方法体 &#125; 例如： 1234567public &lt;T&gt; void fromArrayToCollection (T[] a, Collection&lt;T&gt; c) &#123; for(T o : a) &#123; c.add(o); &#125;&#125; 声明一个泛型方法，带有T类型形参。这个T可以在该方法内当成普通类型使用。并且这个T可以通过系统自动推断类型，不需要显示传入。 7. 泛型方法和类型通配符的区别通常情况下泛型方法都可以替代类型通配符。例如： 12345// 类型通配符 public interface Collection&lt;E&gt; &#123; boolean containsAll(Collection&lt;?&gt; c);&#125; 可以采用泛型方法 1234public interface Collection&lt;E&gt; &#123; &lt;T&gt; boolean containsAll(Collection&lt;T&gt; c);&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView调用JS失败问题总结]]></title>
    <url>%2Farticles%2Fwebview_and_js_problems.html</url>
    <content type="text"><![CDATA[最近在项目里需要在WebView调用JS方法，遇到了一些坑，在此记录下来。 方便以后查找回顾。 背景说明一般来说，如果需要在WebView调用JS方法，只需要进行以下几步： 1、设置WebView支持JS 1webSettings.setJavaScriptEnabled(true); 2、加载html文件/url 12345webView.loadUrl("file:///android_asset/index.html");或者webView.loadUrl("www.baidu.com"); 3、调用JS方法 1234// 无参webView.loadUrl("javascript:helloworld()");// 有参webView.loadUrl("javascript:helloworld('" + word + "')"); 注意：JS里面的变量需要用’’来表示 现在遇到的情况就是：在无参数的时候能够正常调用JS，有参情况无法调用，接下来就一步步来排查。 排查问题1、首先要让WebView支持JS 1234WebSettings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true);webSettings.setJavaScriptCanOpenWindowsAutomatically(true); 2、然后传参的时候记得在变量加上’’ 1webView.loadUrl("javascript:helloworld('" + word + "')"); 这个时候还是不行，上网查了一下，貌似WebView加载url是异步的，js应该在加载完html后再调用，因此再加上下面这段代码 3、重写onPageFinished方法 1234567webView.setWebViewClient(new WebViewClient() &#123; @Override public void onPageFinished(WebView view, String url) &#123; String word = "test"; webView.loadUrl("javascript:helloworld('" + word + "')"); &#125;&#125;); 这个时候发现还是不行，最后想想，会不会是因为ajax请求有跨域的问题，但是看控制台又没有报错，不管了，先把代码加上 4、解决跨域问题 1234567891011121314151617if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN)&#123; forecastWebView.getSettings().setAllowUniversalAccessFromFileURLs(true);&#125;else&#123; try &#123; Class&lt;?&gt; clazz = forecastWebView.getSettings().getClass(); Method method = clazz.getMethod("setAllowUniversalAccessFromFileURLs", boolean.class); if (method != null) &#123; method.invoke(forecastWebView.getSettings(), true); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 由于在sdk &gt; 16以上，也就是4.1以上就能直接设置，但是低于4.1的版本只能通过反射的方式来设置，代码大家看一下就懂了。 最后再Build &amp; Run，发现困扰了很久的调用问题居然被解决了。虽然过程比较曲折，但是也算是学习到了一些经验，因此也把这个过程总结下来。 总结如果JS调用失败，一般有以下几个解决方案，大家根据实际情况来使用： 设置WebView支持JS 传参的时候记得变量需要加上’’ 重写onPageFinished方法 解决跨域问题]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派新手指南(二)-必备设置]]></title>
    <url>%2Farticles%2Fraspberry_general_setting.html</url>
    <content type="text"><![CDATA[新手设置指南： 1、设置中文 2、设置静态IP 3、VNC登录 …… 前言经过了：树莓派新手指南 后 树莓派已经基本能用了，但是还有些地方不太方便，例如：怎么全是英文，能不能不接显示器看到图形界面等等一番折腾以后，就有了这篇 树莓派新手指南(2)-必备设置 一、设置中文1.语言和区域设置 在命令行输入 sudo raspi-config 出现树莓派设置界面 选择第四项“Localisation Options”，然后再选择第一项“Change Locale” 把zn_CN开头的这几项都选上，然后保存（刚开始应该都是英文界面，我这是改完以后的截图） Tips：可以使用page down翻页比较快 设置完成后 sudo reboot 重启树莓派即可完成中文设置 如果重启后发现界面的中文显示不出来，那么说明你的系统没有自带中文库字体 sudo apt-get install ttf-wqy-zenhei 命令行安装开源中文字体，然后再重启即可。 二、设置静态IP为什么要使用静态IP一、可以防范DHCP自动分配的IP来回变动，导致远程SSH时常无法连接 二、提高树莓派网络连接速度 怎么设置静态IP网上很多资料是修改 /etc/network/interface配置文件，增加静态IP的设定，不过这个方法有个问题，即使取得了静态IP，DHCP服务依然会自动为树莓派分配动态IP和DNS地址，导致路由表默认网关出现冲突，手动给定的默认DNS不生效的情况。 解决这个问题的方法特别简单，输入sudo cat /etc/network/interfaces可以看到，interfaces文件的开头注释里告诉我们，要修改静态IP地址，需要修改的是/etc/dhcpcd.conf 也就是DHCP的配置文件 输入 sudo nano /etc/dhcpcd.conf 打开配置文件，找到 example static ip configuration 这一段，然后修改成(IP可以随意修改，只要不要和已有的冲突就行) 12345# Example static IP configuration:interface wlan0static ip_address=192.168.1.168/24static routers=192.168.1.1static domain_name_servers=192.168.1.1 ctrl + o 保存 ctrl + x 退出 Tips: wlan0: 代表的是无线连接，如果你接了网线，改成eth0 三、VNC登录首先我们需要开启VNC 方法一在命令行输入 vncserver 回车就可以了，这个方法重启后需要重启开启 方法二命令行输入 sudo raspi-config 选择第五项“5 interface Options ” 然后再选择第三项：”VNC”，再选择enabled，即可。 在树莓派上开启了VNC后，我们需要在电脑上安装VNC软件 windows: VNC Viewer Mac： VNC Viewer 输入树莓派的ip，端口(开启VNC后在终端能看到) 就可以看到树莓派的界面啦 经过了这些设置，接下来就可以使用树莓派发掘它好玩的地方lalala~]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派新手指南（一）]]></title>
    <url>%2Farticles%2Fraspberry_use_guide.html</url>
    <content type="text"><![CDATA[最近入手了树莓派3B，从组装到烧录系统，再到远程登录 花了一个晚上的时间 于是有了这篇从入门到初级的文章 一、组装一般来说包括但不限于以下组件 RASPBERRY PI 3B 电源 散热片 小风扇 TF卡（注意不是SD卡，而是Micro SD卡） 跟着说明书的步骤来安装就可以了，只要注意一点，如果用的是官方的红白外壳，那么需要先完成安装再插入TF卡。 二、下载&amp;烧录系统1.下载 Raspbian树莓派官方深度定制的硬件驱动与软件程序，官方推荐系统。如果你第一次使用树莓派，请下载这个。Debian的软件策略偏保守，稳定第一，升级是次要的。 两个下载源： (1)树莓派实验室下载地址 下载链接：http://downloads.raspberrypi.org/raspbian_latest默认帐号：Username: pi Password: raspberry （2）树莓派官网下载地址 下载链接：https://www.raspberrypi.org/downloads/ 默认帐号：Username: pi Password: raspberry 打开官网会看到以下界面，左边的是NOOBS，包括了好几个系统 我们只要点击右边这个，下载Raspbian系统就足够了。 点击进去之后会发现有两个选项，看标题应该就能看懂了 左边是带图形化界面的，右边是不带图形化界面的。OK，我们选择左边的 2.烧录系统下载完成后我们就要进行系统烧录了。使用的工具是win32DiskImager，百度直接搜就能找到下载地址。 选择SD卡 选择下载好的镜像文件 点击“写入” 弹出的对话框点击“Yes”，然后等待烧录完成，这个过程大概要10分钟… 三、开机这部分重点讲一下，因为我没有外接显示器，所以用的是SSH登陆的方式。 需要准备的工具 读卡器（必选） 网线（可选） 一、有网线的情况（1）开启SSH 由于树莓派3默认关闭了SSH，因此我们需要先用读卡器接入SD卡，在boot目录，也就是根目录下新建一个文件：SSH（无后缀），然后保存，就可以开启SSH功能了。 （2）获取IP地址 接上网线后，通过路由器找到树莓派的IP：树莓派Mac地址都是b8开头，很容易就能找到。 （3）登陆树莓派 得到树莓派的IP地址后，就可以通过ssh登录了，windows下可以选用putty进行登录，由于我是Mac电脑，用的是shuttle，也可以直接命令行登录，如图： 二、没网线的情况这种情况只能通过wifi连接，获取IP地址，然后再SSH登录 （1）是一样的，需要先开启ssh功能 （2）连接WIFI 在boot（根目录）下新建wpa_supplicant.conf文件，内容如下： 123456789ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=GBnetwork=&#123; ssid="WIFI-NAME" key_mgmt=WPA-PSK psk="wifi-password" priority=5&#125; ssid：wifi名称 psk：wifi密码 priority：优先度 key_mgmt：ap加密类型 （3）登录树莓派 开机后树莓派会自动连上WIFI，同上面第三步一样，就可以通过ssh登录了。 附：有显示器的情况树莓派的接口为HDMI，如果显示器为VGA的话，就需要一条转接线。 接上后开启树莓派，能看到绿色指示灯闪烁，显示器就能看到图形化界面了，其他操作和windows差不多~ 四、常见预警标志如果看到显示器上显示一个警告图标，说明存在问题 （1）彩色色块/闪电符号 供电不足，可能导致系统不稳定，容易死机 原因：1、供电电源不是标准的电流电源（5V/2-2.5A）2、未使用优质USB线 3、GPIO口负载太多传感器 4、USB口负载外设 （2）黄色色块/温度计符号 散热问题，可能导致卡死，甚至烧坏主板 原因：没有安装散热片和小风扇 五、待续经过上面几个步骤以后，初步可以使用树莓派了，但是还有一些设置没有做好，接下来还会写点设置方面的文章，然后再开始发掘树莓派上好玩的功能。 设置中文 设置静态IP VNC登陆]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>ssh</tag>
        <tag>vnc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客100天总结]]></title>
    <url>%2Farticles%2Fone-hundred-days-summary.html</url>
    <content type="text"><![CDATA[本博客已经运行了100天了 是时候该总结一下了 一、本博客主要写什么​ 作为一名新入职场的菜鸟，最近越来越觉得大学四年时间都被荒废了，没有好好学习该掌握的理论知识，导致现在工作效率的低下。搭建这个博客的初衷就是：在工作中遇到很多问题，以及学到了很多新技术，这些都是我想通过博客写成文章，记录下来的。这些不仅仅是经验之谈，更是人生阅历，也是阶段性的总结。因此，在博客运行100天之际，写下这篇文章，谈谈这段时间都做了什么。 ​ 本博客主要是为了记录 技术上遇到的问题，好用的小工具，学习到的新技术，目前是Android开发，对Python有兴趣，主要是爬虫和数据分析方向。 读过的好书，包括读书笔记，以及个人的总结和思考 看过的电影 — 这个应该比较少，毕竟一部电影2h，还是挺耗时间的 例如: 无问西东 日常生活中的琐事，或者是自己的思考过程，也就是碎碎念~ 二、100天总结搭建个人博客100天总结： 读书 Android开发 这两个就是近100天主要进行的活动，由于项目加班较多，因此也没有多少时间总结遇到的问题，踩过的坑，但是我都记在Evernote里面了，以后有时间再挑一些写吧。 读书这段时间读完了以下书籍： 一月： 拿工薪，三十几岁你也能赚到600万 2018/01/02 爱嘉定投魔法 2018/01/04 买基金为自己加薪 2018/01/05 二月： 时间管理：小强升职记 2018/02/22 罗辑思维2 2018/02/27 三月： 百万富翁快车道 2018/03/07 远见：如何规划职业生涯3大阶段 2018/03/18 发现你的天赋：天分与热情成就人生 2018/03/24 阿里巴巴Android开发手册 2018/03/26 ​ 这段时间主要是想提高理财的能力，以及对时间管理的了解，因此结合之前看过的《刻意练习》和《好好学习》这两本书，加上《小强升职记》，对学习方法，以及工作效率都有新的看法。学习到一些技巧现在也会运用在生活中~ ​ 首先必须要推荐的是《爱嘉定投魔法》，在基金投资三部曲当中（也就是我一月份看的这三本书），整体性最强，提供的实操性也是最强的，就是《爱嘉定投魔法》。建议大家对理财有兴趣的都可以去看看，其他两本，第一本是国外的，和社会主义特色有点不大一样。第二本是台湾的，可行性和实操性有局限性，而且内容大部分和前两本类似，所以匆匆过了一遍就没看了。 ​ 对于时间管理和学习方法方面的书有很多，《和时间做朋友》《七年就是一辈子》《精进》《跃迁》等等，对于初入职场的人来说，首先可以看看《小强升职记》，如何把自己手头上的事情做好~有了空闲时间，再通过学习别人好的方法，提高效率，不断学习精进。 ​ 这些书的笔记其实都保存在EvenNote里面，但是由于比较随性，所以就没有放到博客上，打算把成体系，或者比较完整的笔记放上来，其他的就自己留着偶尔回顾吧。 Android开发​ 自己负责一个App Adnroid端的开发，没有造出什么轮子，也没有注重代码的解耦，每天按照需求加班加点开发，好不容易做完了。希望接下来继续review代码，学习优秀的架构思想和设计模式，不仅仅实现功能，还要把代码和项目做得漂亮。提高抽象能力，更加注重基础！ 这段时间还是学习到了很多东西的 自定义View从0到1，现在基本都能实现出来想要的UI效果 更加了解事件分发机制，处理了各种各样的滑动冲突，刚开始真的是有点懵逼。。 对MVP模式更加熟悉 Kotlin从入门到放弃，慢慢把代码迁移过来吧 看完了 Android权威编程指南 正在看 Android开发进阶 从小工到专家 打算看 Android群英传 Android开发艺术探索 Android源码设计模式 三、2018年展望和计划一、读书保持每个月3本书的进度，有时间的话可以把读书笔记和思考总结出来。 二、技术由于深感基础太差，目前跟着萧大的编程入门指南来学习，2018-03-28正处于启蒙阶段，Python导论和CS50这两门课还是比较简单的，容易激发对计算机科学的兴趣，空闲时间正在读《编码》，以下这段话摘自编程入门指南 为了更好理解，可以将学习编程类比为学习厨艺：你为了烧得一手好菜买了一些关于菜谱的书，如果你只是想为家人做菜，这会是一个不错的主意，你重复菜谱上的步骤也能做出不赖的菜肴，但是如果你有更大的野心，真的想在朋友面前露一手，做一些独一无二的美味佳肴，甚至成为「大厨」，你必须理解这些菜谱背后大师的想法，理解其中的理论，而不仅仅是一味地实践。但是如果你每天唯一的工作就是阅读那些厚重的理论书籍，因为缺乏实践，你只会成为一个糟糕的厨子，甚至永远成为不了厨子，因为看了几天书后你就因为枯燥放弃了厨艺的学习。 总之，编程是连接理论与实践的纽带，是计算机科学与计算机应用技术相交融的领域。正确的编程学习方法应该是：通过自顶而下的探索与项目实践，获得编程直觉与推动力；从自底向上的打基础过程中，获得最重要的通用方法并巩固编程思想的理解。 作为初学者，应以后者为主，前者为辅。 三、碎碎念 Android是主线，不断打怪嗑药得经验升级~ Python和计算机科学的学习可以同时进行 每天坚持看书~自己也要有思考总结！ 最后的最后，距离2018年已经过去了1/4，还有278天结束，加油吧💪！！！ 需要电子书的童鞋也可以留下书名+邮箱，我有空的时候会发给你们~]]></content>
      <categories>
        <category>日常说</category>
      </categories>
      <tags>
        <tag>博客总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书笔记】远见：如何规划职业生涯3大阶段]]></title>
    <url>%2Farticles%2Freading-career-planing.html</url>
    <content type="text"><![CDATA[本书是从整个职业生涯的角度，对每一个阶段进行解读，并且提供了一些建议。 职业生涯45年，每15年一个阶段。到底怎么做才能拥有一个正向的职业生涯？ 遇到失业，不能平衡家庭和工作，要跨国工作等问题，又该怎么办？ 让这本书为我们一一讲解。 本书总览Part 1 ： 介绍正确的职场思维、框架和工具 Part 2 ：提供实用性建议和案例，帮助应对职业生涯的三个主要阶段 Part 3 ：以现实为基础，如何平衡工作与家庭的关系 第一部分：远见思维与工具箱1、远见思维：多行动，少忧虑2、3大阶段，聚焦45年职业生涯第一阶段、加添燃料，强势开局 前15年的唯一目标就是：为接下来的两个阶段打好基础 这个阶段是探索和弥补自身短板的时候。学习要比纯粹的成功更重要。跌倒不可怕，只要吸取教训，并加以利用就行。 第二阶段、聚焦长版，到达高点 中间的15年是着眼于核心长版，专注长处，树立起自己的品牌。 第三阶段、优化长尾，持续发挥影响力 最后几年从领导变成顾问或者辅助的角色。 3、储备3大职场燃料如果说读了这本书你需要记住什么的话，那就是真正成功的可持续职业生涯是靠职场燃料推动的。 聪明的职业策略应该是：在整个职业生涯中积累职场燃料并不断更新，同时精明地消费它们。 可迁移技能 ： 解决问题的能力，说服式沟通技巧、完成任务的能力、情商 有意义的经验：创业，第二语言，跨过工作，志愿者项目等等 持久的关系，即职业生态系统：上司，客户，商业伙伴，身边的人才，同类人 4、5个数字，树立正确职场思维 职业生涯的长度：60 - 年龄 = 退休年数 精通一项技能所需的时间：1W小时 40岁以后赚到的个人财富百分比：85-90% 社交货币：一般在200个左右 职场支持者的人数：找到3~5个真正能成为导师的人 5、4大黄金问题，评估职业价值​ 1号燃料清单： ​ 学位、专业证书 ​ 语言，包括音乐和计算机语言 ​ 上司和同事对你评估的优点 ​ 你收到的关于情商的评价 ​ 你的“人才账户” ​ 2号燃料清单 ​ 个人旅游 ​ 国外工作经历 ​ 企业管理或创业经验 ​ 社区或志愿者活动 ​ 个人贡献的项目，产品，活动 ​ 公开演讲、写作、表演经验 ​ 教学、资讯或指导的经验 ​ 兴趣、业余活动、工作之余热情 ​ ​ 3号燃料清单： ​ 支持者，关键同事，专家团，联系人 ​ 4大黄金问题： ​ 1.我是否正在学习和成长？ ​ 2.我是否正在对某些人，现在的公司，乃至整个社会拥有影响力？ ​ 3.我体验到乐趣了吗？ ​ 4.我是否得到了奖励，并创造了经济价值？ 6、100小时测试，合理投资时间​ 每周清醒时间大概为100小时，如何分配是关键。 ​ 不同年龄段的人，工作，家庭，娱乐的时间分配比例也有所不同。 ​ 碎片时间用于投资，获取乐趣，产出。 7、 职场路径向导，做出正确的职业决策​ 首先要问自己三个问题： ​ 1.职业理想是什么，至少假设一个可能想到达到的目标 ​ 2.目前手上有什么职场燃料？ ​ 3.还需要什么职场燃料才能实现这个终极理想？ ​ 只有快速成长，才能长期成功 ​ 1.周围都是比自己聪明的人 ​ 2.有失败的机会 ​ 3.公司能让自己肩负重大责任 第二部分 三大职业生涯阶段第一阶段 加添燃料，强势开局​ 1.利用在读时间好好学习，储备燃料 ​ 2.制定求职计划 ​ 3.积极参与校园招聘 ​ 4.做好心理准备 ​ 5.不断探索 第二阶段 锚定甜蜜去，聚焦长版​ 在20多岁，甚至30多岁的时候，不管我们对工作是否有热情和兴趣，我们都可以把工作做得非常好，因为我们年轻，充满活力，我们的满足感主要来源于工作之外。但是到最后，由于与这一领域缺乏深度的联系，各种困扰就会出现，这让让会发生在我们40多岁的时候。我们会感到越来越无法投入工作，竞争力不断下降。我们天生的创造力已经快耗尽了。我们无法关注所在领域发生的变化，因为我们已经脱轨。更年轻，更有创造力，而且更廉价的人很快就会取代我们。 创造精通技能的秘方就是意愿和时间 你必须自己帮自己开门，不停的问自己“另外一边有什么，我为什么不能去呢？”。永远不要停下对未来的规划，要努力让自己成为幸运儿。 第三阶段 优化长尾 发挥影响力建议1：试验，自愿接受挑战。 建议2：创业，开辟全新疆域。 建议3：管理学习曲线，保持关联性。 第三部分 应对职场和生活的冲突如何做好职场父母：1.不要让职业生涯和为人父母成为非此即彼的选项。 2.找到一个热爱家庭的雇主。 3.设立现实的期望和严格的界限。 4.管理你的时间和精力 如何应对职场危机：1.清晰客观地认识问题：这是一个不可避免的事件？一个认知上的问题？业绩上的问题？ 2.有时候，职场危机可能是由于别人对你的技能，目标的错位认知引起的。 3.在其他情况中，你的不足之处可能是真实存在的 4.有些职场危机是可以预见并且规避的：时刻关注公司，行业，业绩的变化。 5.遇到危机要快速重回正轨：重新组织，重新包装，重新连接，重新建立。 智能时代下的职场选择：1.数字技术和数据分析 2.将时间货币投资到技能之上：时间是人生的唯一货币 3.获得收入的答案就是工作 结尾改善3个因素，提升幸福指数 50%是基因决定的 10%是生活环境决定的 40%是主动的行为决定的：追求新的知识，新的成就，控制自己的想法。 表达感恩 培养乐观的心态 避免过度思虑和社会攀比 多行善事 维护人际关系 发展合作的策略 学会原谅 增加心流体验 享受生活的乐趣 努力实现目标 关注身体健康 个人总结职场分为三大阶段前15年：不断尝试，争当斜杠青年，学习经验和技能，特别是可迁移技能 中15年：发挥优势，专注长处，成为某个领域的专家(给自己贴标签)，树立起个人品牌。 后15年：通过人脉，经验，影响力等优势创造价值，或者再创业。 几点感想1.向优秀的人学习，上司，同事，客户等，既是积累人脉，也是学习优点的机会。 2.活到老学到老，现在新闻经常说华为清退34岁以上老员工，中兴42岁高官被辞退等等，那是因为人都是有惰性的，前几年努力工作，当上中层管理，或者技术组长以后，进入了自己的舒适区就不愿意挪窝了。那再过几年，跟不上时代的变化，自然就会被淘汰。因此有一点很重要：成为终身学习者。 3.每个阶段的重点都不同，前期积累，中期收获，后期发挥余热。 前期努力工作，学习技能是重点，10000小时必不可少。 中期由于家庭需要照顾，不能像年轻的时候把时间都用于工作，因此需要使用策略来平衡两者。 到了后期，财富积累有了，个人经验也足够了，可以选择之前没尝试过的领域，开拓人生宽度。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为小绿锁快速续命]]></title>
    <url>%2Farticles%2Fupdate-https-by-acme-sh.html</url>
    <content type="text"><![CDATA[眼看着小绿锁快到期了，但是crontab又失效了 作为一个懒人，只好上网找现成的工具来解决 登登登登，主角登场：acme.sh 简单介绍ACMEACME 全称是 Automated Certificate Management Environment，直译过来是自动化证书管理环境的意思，Let’s Encrypt 的证书签发过程使用的就是 ACME 协议。有关 ACME 协议的更多资料可以在这个仓库找到。 之前我的网站就是用的 Let’s Encrypt 这个免费、自动化、开放的证书签发服务。正好到3月19号就到期了，需要续签，于是就找到了acme.sh这个小工具。 acme.sh的好处: 一键快捷安装 acme.sh 一行命令生成证书 自动更新证书 自动更新 acme.sh 使用方法官方文档（中文）：acme.sh说明 其实官方文档里面已经说很详细了，我也是跟着文档一步步来操作的。 这篇文章把一些要注意的地方和截图都补上，让大家能清晰快速地更新证书~ 主要步骤：1.安装acme.sh安装很简单, 一个命令: 12&gt; curl https://get.acme.sh | sh&gt; 这个命令把acme.sh安装到home目录下，并且自动创建cronjob 注意：安装过程不会污染已有的系统任何功能和文件, 所有的修改都限制在安装目录中: ~/.acme.sh/ 2.生成证书acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证 我使用的是http方式，如果想用dns验证的请看官方文档 首先进入/home/.acme.sh/ 目录，然后执行下面这条命令 1acme.sh --issue -d bluelzy.com -d www.bluelzy.com --webroot /var/www/bluelzy.com www.bluelzy.com -&gt; 换成你的域名 /var/www/bluelzy.com -&gt; 换成你的网站根目录 如果你用的 apache服务器, acme.sh 还可以智能的从 apache的配置中自动完成验证, 你不需要指定网站根目录: 1acme.sh --issue -d mydomain.com --apache 如果你用的 nginx服务器, 或者反代, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录: 1acme.sh --issue -d mydomain.com --nginx 如无意外应该能看到以下输出： 1234[Sat Mar 17 22:38:56 EDT 2018] Your cert is in /root/.acme.sh/bluelzy.com/bluelzy.com.cer[Sat Mar 17 22:38:56 EDT 2018] Your cert key is in /root/.acme.sh/bluelzy.com/bluelzy.com.key[Sat Mar 17 22:38:56 EDT 2018] The intermediate CA cert is in /root/.acme.sh/bluelzy.com/ca.cer[Sat Mar 17 22:38:56 EDT 2018] And the full chain certs is there: /root/.acme.sh/bluelzy.com/fullchain.cer 代表证书已经成功生成了！ 3.copy/安装证书前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方. 注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化. 正确的使用方法是使用 --installcert 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如: 123acme.sh --installcert -d &lt;domain&gt;.com \ --key-file /etc/nginx/ssl/&lt;domain&gt;.key \ --fullchain-file /etc/nginx/ssl/fullchain.cer \ 解释一下： Nginx 的配置 ssl_certificate 使用 /etc/nginx/ssl/fullchain.cer ，而非 /etc/nginx/ssl/&lt;domain&gt;.cer ，否则 SSL Labs 的测试会报 Chain issues Incomplete 错误。 4.修改配置文件打开nginx的配置文件，找到 123456# SSL证书配置 ssl_certificate /etc/letsencrypt/live/bluelzy.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/bluelzy.com/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; 把ssl_certificate路径换成：/etc/nginx/ssl/fullchain.cer 把ssl_certificate_key路径换成：/etc/nginx/ssl/.key 注意：如何你的证书不是保存在这个路径，请找到正确的路径，再修改！ 保存后执行一下： 1service nginx force-reload (一个小提醒, 这里用的是 service nginx force-reload, 不是 service nginx reload, 据测试, reload 并不会重新加载证书, 所以用的 force-reload) 再刷新自己的网站~就能看到证书已经被更新啦！！！ 5.更新证书目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心. 6.更新acme.sh目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步. 升级 acme.sh 到最新版 : 1acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级: 1acme.sh --upgrade --auto-upgrade 之后, acme.sh 就会自动保持更新了. 你也可以随时关闭自动更新: 1acme.sh --upgrade --auto-upgrade 0 开启自动更新： 注意事项第一个坑在第二步中： 1acme.sh --issue -d bluelzy.com -d www.bluelzy.com --webroot /var/www/bluelzy.com webroot:参数是网站的根目录，否则会报错无法验证域名 第二个坑在第三步中： 如果复制的文件夹不存在，那么需要先创建文件夹，再执行命令。 参考 acme.sh官方文档(中文) acme.sh官方文档(英文) 报错：Invalid response from (website)]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>https</tag>
        <tag>ACME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity传值与回传]]></title>
    <url>%2Farticles%2Factivity_transmit_value.html</url>
    <content type="text"><![CDATA[记录一个基础问题， Activity传值与回传，后面遇到类似的问题就不用再问人了。 Activity传值与回传Android Developers: 获取Activity的结果 链接只讲了怎么获取返回的数据，没有写返回数据的方法。 假设 FirstActivity 为初始Activity，SecondActivity 为跳转Activity 首先 在FirstActivity 通过startActivityForResult(Intent intent, int requestCode) 方法跳转Activity Intent i = new Intent(FirstActivity.this, SecondActivity.class) startActivityForResult(i,requestCode); 然后 在FirstActivity 重写 onActivityResult(int requestCode, int resultCode, Intent data)方法 三个参数分别为：请求码，返回码，返回数据 switch (requestCode) { case requestCode: ​ if (resultCode == RESULT_OK) { ​ // do something ​ } ​ break; 最后 在SecondActivity 通过setResult(int resultCode, Intent data)方法返回数据 参数为：返回码，返回数据 Intent i = new Intent(); i.putExtra(“bean”,bean); this.setResult(RESULT_OK,i); finish(); 即可在FirstActivity 的onActivityResult()方法中接收到回传的数据。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用腾讯地图SDK的自动补全功能]]></title>
    <url>%2Farticles%2Ftencent_map_search.html</url>
    <content type="text"><![CDATA[上一篇讲了高德地图的自动补全 这一篇来讲一讲腾讯地图的使用 大体上都差不多，只是集成步骤有点区别而已… 说明本文只使用了腾讯地图的 自动提示 功能 本文只使用了腾讯地图的 自动提示 功能 本文只使用了腾讯地图的 自动提示 功能 其他2D，3D，地图街景等功能请自行查阅官方文档 另外，如果想用高德地图的朋友 请看我的上一篇博客：使用高德地图SDK的自动补全功能 一、集成腾讯地图SDK1.集成检索SDK有两种方法 - 基于AS，使用Eclipse的童鞋请参考官方文档 使用 maven矢量地图 v4.0.3.2 开始支持 maven 配置地图sdk，配置方法： 工程顶级 gradle.properties 文件中加入： 123maven&#123; url "https://oss.sonatype.org/content/groups/public"&#125; module build.gradle 文件中添加依赖库名称： 1234dependencies &#123; //这里始终使用最新的稳定版本，用户也可以指定 4.0.3.2 之后的地图 sdk 版本号 compile 'com.tencent.map:tencent-map-vector-sdk:latest.release'&#125; 使用JAR包 下载地址：http://lbs.qq.com/android_v1/log_search.html 解压并且把TencentSearch_v1.x.x.jar 加入到libs目录下，右键add as library 参考文档：http://lbs.qq.com/android_v1/guide-project-setup.html 这样就完成了第一步。 2.申请key 申请开发者账号：http://lbs.qq.com/console/user_info.html 需要填写手机和邮箱 进入控制台以后，就可以看到自己的KEY的，在授权应用设置自己的包名 3.在app -&gt; AndroidManifest.xml 加入： 123&lt;meta-data android:name="TencentMapSDK" android:value="输入申请的开发者权限"/&gt; 4.混淆 123#腾讯地图检索sdk-keep class com.tencent.lbssearch.**&#123;*;&#125;-keep class com.google.gson.examples.android.model.** &#123; *; &#125; 完成了工程设置以后，就是撸代码的时间了~ 二、开始撸代码1，创建activity_poi_keyword_search.xml布局文件，如下： 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/et_keyword" android:layout_width="match_parent" android:layout_height="50dp" android:background="@color/white" android:hint="请输入地址关键字搜索" android:paddingLeft="8dp" android:textColor="@color/deep_black" android:textSize="14sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="@color/line_color"/&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 2，创建recyclerview的item布局item_poi_keyword_search.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout android:id="@+id/ll_item_layout" xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="wrap_content" android:background="@color/white" android:orientation="vertical" &gt; &lt;View android:layout_width="match_parent" android:layout_height="0.5dp" android:background="@color/line_color"/&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="vertical" android:paddingBottom="8dp" android:paddingLeft="10dp" android:paddingRight="10dp" android:paddingTop="8dp"&gt; &lt;TextView android:id="@+id/tv_detailAddress" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:textColor="@color/deep_black" android:textSize="16sp"/&gt; &lt;TextView android:id="@+id/tv_content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:textColor="@color/black" android:textSize="16sp"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 3，创建实体类PoiAddressBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.Serializable;public class PoiAddressBean implements Serializable &#123; private String longitude;//经度 private String latitude;//纬度 private String text;//信息内容 public String detailAddress;//详细地址 public String province;//省 public String city;//城市 public String district;//区域 public PoiAddressBean(String lon, String lat, String detailAddress, String text, String province, String city, String district)&#123; this.longitude = lon; this.latitude = lat; this.text = text; this.detailAddress = detailAddress; this.province = province; this.city = city; this.district = district; &#125; public String getLongitude() &#123; return longitude; &#125; public String getLatitude() &#123; return latitude; &#125; public String getText() &#123; return text; &#125; public String getDetailAddress() &#123; return detailAddress; &#125; public String getProvince() &#123; return province; &#125; public String getCity() &#123; return city; &#125; public String getDistrict() &#123; return district; &#125;&#125; 4，创建适配器PoiKeywordSearchAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import com.alpha58.poidemo.activity.PoiKeywordSearchActivity;import com.alpha58.poidemo.R;import com.alpha58.poidemo.bean.PoiAddressBean;import java.util.List;public class PoiKeywordSearchAdapter extends RecyclerView.Adapter&lt;PoiKeywordSearchAdapter.MyViewHolder&gt; &#123; List&lt;PoiAddressBean&gt; poiAddressBean; Context mContext; public PoiKeywordSearchAdapter(Context context, List&lt;PoiAddressBean&gt; poiAddressBean) &#123; this.poiAddressBean = poiAddressBean; this.mContext = context; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view; view = LayoutInflater.from(mContext).inflate(R.layout.item_poi_keyword_search, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; final PoiAddressBean poiAddressBean = this.poiAddressBean.get(position); holder.tv_detailAddress.setText(poiAddressBean.getDetailAddress()); holder.tv_content.setText(poiAddressBean.getText()); holder.ll_item_layout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; ((PoiKeywordSearchActivity)mContext).setDetailAddress(poiAddressBean.getDetailAddress()); &#125; &#125;); &#125; @Override public int getItemCount() &#123; if (poiAddressBean != null) &#123; return poiAddressBean.size(); &#125; else &#123; return 0; &#125; &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv_content; TextView tv_detailAddress; LinearLayout ll_item_layout; public MyViewHolder(View itemView) &#123; super(itemView); tv_detailAddress = (TextView) itemView.findViewById(R.id.tv_detailAddress); tv_content = (TextView) itemView.findViewById(R.id.tv_content); ll_item_layout = (LinearLayout) itemView.findViewById(R.id.ll_item_layout); &#125; &#125;&#125; 5，创建搜索界面类PoiKeywordSearchActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.text.Editable;import android.text.TextWatcher;import android.widget.EditText;import com.alpha58.poidemo.R;import com.alpha58.poidemo.adapter.PoiKeywordSearchAdapter;import com.alpha58.poidemo.bean.PoiAddressBean;import com.alpha58.poidemo.util.ToastUtil;import com.amap.api.services.core.AMapException;import com.amap.api.services.core.LatLonPoint;import com.amap.api.services.core.PoiItem;import com.amap.api.services.core.SuggestionCity;import com.amap.api.services.poisearch.PoiResult;import com.amap.api.services.poisearch.PoiSearch;import java.util.ArrayList;import java.util.List;public class PoiKeywordSearchActivity extends AppCompatActivity implements PoiSearch.OnPoiSearchListener &#123; private RecyclerView mRecyclerView; private EditText mEt_keyword; private String keyWord = "";// 要输入的poi搜索关键字 private PoiResult poiResult; // poi返回的结果 private int currentPage = 0;// 当前页面，从0开始计数 private PoiSearch.Query query;// Poi查询条件类 private PoiSearch poiSearch;// POI搜索 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_poi_keyword_search); initView(); initListener(); initData(); &#125; private void initView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); mEt_keyword = (EditText) findViewById(R.id.et_keyword); &#125; private void initListener() &#123; mEt_keyword.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; keyWord = String.valueOf(charSequence); if ("".equals(keyWord)) &#123; ToastUtil.show(PoiKeywordSearchActivity.this,"请输入搜索关键字"); return; &#125; else &#123; doSearchQuery(); &#125; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125; &#125;); &#125; /** * 开始进行poi搜索 */ protected void doSearchQuery() &#123; currentPage = 0; //不输入城市名称有些地方搜索不到 query = new PoiSearch.Query(keyWord, "", "深圳");// 第一个参数表示搜索字符串，第二个参数表示poi搜索类型，第三个参数表示poi搜索区域（空字符串代表全国） //这里没有做分页加载了,默认给50条数据 query.setPageSize(50);// 设置每页最多返回多少条poiitem query.setPageNum(currentPage);// 设置查第一页 poiSearch = new PoiSearch(this, query); poiSearch.setOnPoiSearchListener(this); poiSearch.searchPOIAsyn(); &#125; private void initData() &#123; mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); &#125; /** * POI信息查询回调方法 */ @Override public void onPoiSearched(PoiResult result, int rCode) &#123; if (rCode == AMapException.CODE_AMAP_SUCCESS) &#123; if (result != null &amp;&amp; result.getQuery() != null) &#123; // 搜索poi的结果 if (result.getQuery().equals(query)) &#123; // 是否是同一条 poiResult = result; ArrayList&lt;PoiAddressBean&gt; data = new ArrayList&lt;PoiAddressBean&gt;();//自己创建的数据集合 // 取得搜索到的poiitems有多少页 List&lt;PoiItem&gt; poiItems = poiResult.getPois();// 取得第一页的poiitem数据，页数从数字0开始 List&lt;SuggestionCity&gt; suggestionCities = poiResult .getSearchSuggestionCitys();// 当搜索不到poiitem数据时，会返回含有搜索关键字的城市信息 for(PoiItem item : poiItems)&#123; //获取经纬度对象 LatLonPoint llp = item.getLatLonPoint(); double lon = llp.getLongitude(); double lat = llp.getLatitude(); String title = item.getTitle(); String text = item.getSnippet(); String provinceName = item.getProvinceName(); String cityName = item.getCityName(); String adName = item.getAdName(); data.add(new PoiAddressBean(String.valueOf(lon), String.valueOf(lat), title, text,provinceName, cityName,adName)); &#125; PoiKeywordSearchAdapter adapter = new PoiKeywordSearchAdapter(PoiKeywordSearchActivity.this,data); mRecyclerView.setAdapter(adapter); &#125; &#125; else &#123; ToastUtil.show(PoiKeywordSearchActivity.this, getString(R.string.no_result)); &#125; &#125; else &#123; ToastUtil.showerror(this, rCode); &#125; &#125; /** * POI信息查询回调方法 */ @Override public void onPoiItemSearched(PoiItem item, int rCode) &#123; // TODO Auto-generated method stub &#125; /** * 设置详情地址 * @param detailAddress */ public void setDetailAddress(String detailAddress) &#123; mEt_keyword.setText(detailAddress); &#125;&#125; 6.在AndroidManifest中注册PoiKeywordSearchActivity 7.在需要用到的地方startActivity跳转到PoiKeywordSearchActivity即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>腾讯地图</tag>
        <tag>第三方控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用高德地图SDK的自动补全功能]]></title>
    <url>%2Farticles%2Famap_search.html</url>
    <content type="text"><![CDATA[2018转眼即至 又是新的一年 祝大家新年大吉，狗年旺旺！ 本文：使用高德地图SDK的自动补全地址功能 前言最近一直加班赶项目进度，有很多想写的博客都没时间写，趁过年抽空把遇到的问题和一些心得记下来，这一篇是介绍如何使用高德地图SDK的自动补全地址功能。 一、集成高德地图SDK下载地址：http://lbs.amap.com/api/android-sdk/download/ 解压，把jar包复制到libs文件夹，右键add as library 因为之前项目已经集成高德地图了，所以申请秘钥，加入权限，这些步骤就省略了。 二、创建搜索代码1，创建activity_poi_keyword_search.xml布局文件，如下： 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/et_keyword" android:layout_width="match_parent" android:layout_height="50dp" android:background="@color/white" android:hint="请输入地址关键字搜索" android:paddingLeft="8dp" android:textColor="@color/deep_black" android:textSize="14sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="@color/line_color"/&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 2，创建recyclerview的item布局item_poi_keyword_search.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout android:id="@+id/ll_item_layout" xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="wrap_content" android:background="@color/white" android:orientation="vertical" &gt; &lt;View android:layout_width="match_parent" android:layout_height="0.5dp" android:background="@color/line_color"/&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="vertical" android:paddingBottom="8dp" android:paddingLeft="10dp" android:paddingRight="10dp" android:paddingTop="8dp"&gt; &lt;TextView android:id="@+id/tv_detailAddress" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:textColor="@color/deep_black" android:textSize="16sp"/&gt; &lt;TextView android:id="@+id/tv_content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:textColor="@color/black" android:textSize="16sp"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 3，创建实体类PoiAddressBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.Serializable;public class PoiAddressBean implements Serializable &#123; private String longitude;//经度 private String latitude;//纬度 private String text;//信息内容 public String detailAddress;//详细地址 public String province;//省 public String city;//城市 public String district;//区域 public PoiAddressBean(String lon, String lat, String detailAddress, String text, String province, String city, String district)&#123; this.longitude = lon; this.latitude = lat; this.text = text; this.detailAddress = detailAddress; this.province = province; this.city = city; this.district = district; &#125; public String getLongitude() &#123; return longitude; &#125; public String getLatitude() &#123; return latitude; &#125; public String getText() &#123; return text; &#125; public String getDetailAddress() &#123; return detailAddress; &#125; public String getProvince() &#123; return province; &#125; public String getCity() &#123; return city; &#125; public String getDistrict() &#123; return district; &#125;&#125; 4，创建适配器PoiKeywordSearchAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import com.alpha58.poidemo.activity.PoiKeywordSearchActivity;import com.alpha58.poidemo.R;import com.alpha58.poidemo.bean.PoiAddressBean;import java.util.List;public class PoiKeywordSearchAdapter extends RecyclerView.Adapter&lt;PoiKeywordSearchAdapter.MyViewHolder&gt; &#123; List&lt;PoiAddressBean&gt; poiAddressBean; Context mContext; public PoiKeywordSearchAdapter(Context context, List&lt;PoiAddressBean&gt; poiAddressBean) &#123; this.poiAddressBean = poiAddressBean; this.mContext = context; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view; view = LayoutInflater.from(mContext).inflate(R.layout.item_poi_keyword_search, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; final PoiAddressBean poiAddressBean = this.poiAddressBean.get(position); holder.tv_detailAddress.setText(poiAddressBean.getDetailAddress()); holder.tv_content.setText(poiAddressBean.getText()); holder.ll_item_layout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; ((PoiKeywordSearchActivity)mContext).setDetailAddress(poiAddressBean.getDetailAddress()); &#125; &#125;); &#125; @Override public int getItemCount() &#123; if (poiAddressBean != null) &#123; return poiAddressBean.size(); &#125; else &#123; return 0; &#125; &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv_content; TextView tv_detailAddress; LinearLayout ll_item_layout; public MyViewHolder(View itemView) &#123; super(itemView); tv_detailAddress = (TextView) itemView.findViewById(R.id.tv_detailAddress); tv_content = (TextView) itemView.findViewById(R.id.tv_content); ll_item_layout = (LinearLayout) itemView.findViewById(R.id.ll_item_layout); &#125; &#125;&#125; 5，创建搜索界面类PoiKeywordSearchActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.text.Editable;import android.text.TextWatcher;import android.widget.EditText;import com.alpha58.poidemo.R;import com.alpha58.poidemo.adapter.PoiKeywordSearchAdapter;import com.alpha58.poidemo.bean.PoiAddressBean;import com.alpha58.poidemo.util.ToastUtil;import com.amap.api.services.core.AMapException;import com.amap.api.services.core.LatLonPoint;import com.amap.api.services.core.PoiItem;import com.amap.api.services.core.SuggestionCity;import com.amap.api.services.poisearch.PoiResult;import com.amap.api.services.poisearch.PoiSearch;import java.util.ArrayList;import java.util.List;public class PoiKeywordSearchActivity extends AppCompatActivity implements PoiSearch.OnPoiSearchListener &#123; private RecyclerView mRecyclerView; private EditText mEt_keyword; private String keyWord = "";// 要输入的poi搜索关键字 private PoiResult poiResult; // poi返回的结果 private int currentPage = 0;// 当前页面，从0开始计数 private PoiSearch.Query query;// Poi查询条件类 private PoiSearch poiSearch;// POI搜索 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_poi_keyword_search); initView(); initListener(); initData(); &#125; private void initView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); mEt_keyword = (EditText) findViewById(R.id.et_keyword); &#125; private void initListener() &#123; mEt_keyword.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; keyWord = String.valueOf(charSequence); if ("".equals(keyWord)) &#123; ToastUtil.show(PoiKeywordSearchActivity.this,"请输入搜索关键字"); return; &#125; else &#123; doSearchQuery(); &#125; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125; &#125;); &#125; /** * 开始进行poi搜索 */ protected void doSearchQuery() &#123; currentPage = 0; //不输入城市名称有些地方搜索不到 query = new PoiSearch.Query(keyWord, "", "深圳");// 第一个参数表示搜索字符串，第二个参数表示poi搜索类型，第三个参数表示poi搜索区域（空字符串代表全国） //这里没有做分页加载了,默认给50条数据 query.setPageSize(50);// 设置每页最多返回多少条poiitem query.setPageNum(currentPage);// 设置查第一页 poiSearch = new PoiSearch(this, query); poiSearch.setOnPoiSearchListener(this); poiSearch.searchPOIAsyn(); &#125; private void initData() &#123; mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); &#125; /** * POI信息查询回调方法 */ @Override public void onPoiSearched(PoiResult result, int rCode) &#123; if (rCode == AMapException.CODE_AMAP_SUCCESS) &#123; if (result != null &amp;&amp; result.getQuery() != null) &#123; // 搜索poi的结果 if (result.getQuery().equals(query)) &#123; // 是否是同一条 poiResult = result; ArrayList&lt;PoiAddressBean&gt; data = new ArrayList&lt;PoiAddressBean&gt;();//自己创建的数据集合 // 取得搜索到的poiitems有多少页 List&lt;PoiItem&gt; poiItems = poiResult.getPois();// 取得第一页的poiitem数据，页数从数字0开始 List&lt;SuggestionCity&gt; suggestionCities = poiResult .getSearchSuggestionCitys();// 当搜索不到poiitem数据时，会返回含有搜索关键字的城市信息 for(PoiItem item : poiItems)&#123; //获取经纬度对象 LatLonPoint llp = item.getLatLonPoint(); double lon = llp.getLongitude(); double lat = llp.getLatitude(); String title = item.getTitle(); String text = item.getSnippet(); String provinceName = item.getProvinceName(); String cityName = item.getCityName(); String adName = item.getAdName(); data.add(new PoiAddressBean(String.valueOf(lon), String.valueOf(lat), title, text,provinceName, cityName,adName)); &#125; PoiKeywordSearchAdapter adapter = new PoiKeywordSearchAdapter(PoiKeywordSearchActivity.this,data); mRecyclerView.setAdapter(adapter); &#125; &#125; else &#123; ToastUtil.show(PoiKeywordSearchActivity.this, getString(R.string.no_result)); &#125; &#125; else &#123; ToastUtil.showerror(this, rCode); &#125; &#125; /** * POI信息查询回调方法 */ @Override public void onPoiItemSearched(PoiItem item, int rCode) &#123; // TODO Auto-generated method stub &#125; /** * 设置详情地址 * @param detailAddress */ public void setDetailAddress(String detailAddress) &#123; mEt_keyword.setText(detailAddress); &#125;&#125; 6.在AndroidManifest中注册PoiKeywordSearchActivity 7.在需要用到的地方startActivity跳转到PoiKeywordSearchActivity即可 更新除了高德地图，我还试了一下腾讯地图SDK的自动提示功能。 对比了一下，感觉还是腾讯的地址提示更接近常用的选项，目前已经从高德转到腾讯了。 文章地址：使用腾讯地图SDK的自动补全功能]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>第三方控件</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影-无问西东]]></title>
    <url>%2Farticles%2Fforever_young.html</url>
    <content type="text"><![CDATA[如果提前了解了你所要面对的人生 你是否还会有勇气前来？ 《无问西东》有感 流水账今天是2018年1月21日，下午约了几个朋友一起去看电影，听说最近《无问西东》很火，经常看到宣传的海报，加上周围的人也是好评不断，于是就定了这部。 在看之前并没有了解过这部电影是说什么的，直接在猫眼上买了票，就直奔电影院而去。结果到电影院的时候，已经开场了（晚了两分钟），荧幕上张果果（张震饰）在说什么商业，背叛的，几个人互相看了一眼，低声说 “不会是走错片场了吧”，把票又拿出来反复看了两遍，发现没有，好吧，于是接着看下去。 电影看完了，看到周围很多人都在偷偷的抹眼泪，自己也是从中感受到震撼和感动。于是就有了这篇观后感。 接下来内容有大量剧透 请谨慎食用 观后感首先交代一下故事背景，这篇电影是清华大学宣传片，里面出现了很多影响时代的大人物，包括梅贻琦、梁启超、徐志摩、陈演恪等等大师级的人物，通过一条主线把整部电影想表达的主题 “真、善、美” 给串联出来。 整部电影分为四个小故事。 第一个是陈楚生饰演的一个文科很好，但是选择读理科的学生，他在1923年的时候于清华求学，这个时候是他人生中迷茫找不到方向的时候，当时的校长-梅贻琦，把他叫到办公室，对他说了这样一番话 人把自己置身于忙碌当中，有一种麻木的踏实，但丧失了真实，你的青春也不过只有这些日子。什么是真实：你看到什么，听到什么，做什么，和谁在一起。 这段话在我看电影的时候，深深感到震撼，或者说触碰到内心深处的一段话。 可能因为我正值青春，和求学的陈楚生差不多的年纪，自然也有着对未来不确定，对人生迷茫的时候，这段话想表达的意思其实就是： 去做你真正想做的事，而不是别人希望你去做的事 别人说公务员好，稳定不辛苦，难道就是自己想要的 “真实” 吗？ 别人说有车有房就是成功，甚至攀比，炫耀，难道这也是想要的 “真实” 吗？ 就像唐朝的以胖为美，到现在流行的A4腰，筷子腿。时代在变化，普罗大众也总是习惯将主流价值观当成是自己内心的方向。但是真正能传承下去的，只有那些能给人带来力量，甚至信仰的事物。 这就是电影中说的 “他们身上都有一种淡定从容的气质，让我羡慕不已” 找到那件能够让你废寝忘食，甚至一直盘旋在你的脑海里，只要有时间就会去做的事，那就是“真实”。 第二个故事是193X年，西南联合大学在云南昆明成立，这中间经历了多少的艰苦和长途跋涉，当时的条件有多苦难，大家可以去了解一下。 这里举些例子： 法律研究所的费青，将家中全部藏书出售，只换了三千块国币； 校长梅贻琦，曾任中华民国教育部部长，为了组建学生服务社，好赚点外快补贴老师们的拮据生活，卖掉了自己所有值钱的东西。 有次上课时迟到了，他歉疚地解释：“我刚才在街上给我内人的糕点摊守摊，她去进货了，可她办事不利，我告诉她八点我有课，她七点半还没回来，我只好丢下摊，跑来了，不过，今天点心卖得特好，有钱挣啊！” 同学们却纷纷拭泪，他们知道校长为了办学变卖了值钱的家当，连师母都得去街上卖早点。 梅贻琦的一儿一女也在联大读书，按规定，联大学生都能领取救济，但梅贻琦不让自己的孩子领取。后来梅贻琦，把儿女都送去参军。 闻一多为了补贴家用，刻章卖钱。刻章广告由其他教授操刀：“浠水闻一多教授，文坛先进，经学名家，辨文字于毫芒，几人知己；谈风雅之原始，海内推崇……爰缀短言为引，公定薄润于后。” 落款署着梅贻琦、蒋梦麟、冯友兰、唐兰、朱自清、沈从文等十二位先生的名字。 回归到电影。 这个故事里面的主角-王力宏，饰演的是一位富家子弟，最终选择弃笔从戎，成为了一名飞行员，最终在与日军的交战中撞向敌军战舰光荣牺牲。 其实在今天的社会主流观点看来，他就是一个标准的富二代，三代五将，根本不需要去昆明过这种苦日子，甚至是付出自己的生命。但是也正因为这种反差，才更让人觉得，在国家有难的时候，总是会有人勇敢地站出来捍卫自己的国家和民族尊严，也正因为有这些热血先烈的付出和牺牲，才换来了今天我们幸福宁静的生活。 华北之大，已经安放不下一张平静的书桌了！” — 清华大学校长蒋南翔 第三个故事是196X年的时候，发生在陈鹏（黄晓明），李想，王敏佳（章子怡），三个人的故事，这段主要是爱情以及人性的黑暗面，剧情就不透露了。直接说说我的感想吧。在王敏佳被众人批斗的时候，李想选择为了自己的前途而后退，王敏佳站在批斗台上带着笑意望向李想，为他有了更光明的前途而高兴的时候，人性中的黑暗和善良交织在一起，形成了强烈的对照。 人性中的“善” 往往比光明的前途，更重要。 最后一个故事就是当代啦。张果果（张震）被出卖，背叛，高管之间的勾心斗角，仿佛就是现在办公室里经常能看到的剧情。 在纠结了很久之后，他还是选择了遵循自己的内心，不求回报的帮助有需要的人，并且守住了自己的“善”，没有因为上司的出卖，而选择报复。 这几个故事不是完全独立开来的，每一个前人的选择都直接或者间接影响了后面的人，这个也是这部电影想表达的态度，人们总是由于各种各样的关系连接在一起，没有谁是完全孤立的个体，我们应当尽力去做的就是： 不忘初心，保持对这个世界最大的善意。 还有，好好读书！ 附上最后的旁白 看到和听到的，经常令你们沮丧，世俗是这样强大，强大到生不出改变它们的念头。 可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子， 不知你们是否还会在意的，那些世俗让你们在意的事情，比如占有多少，才更荣耀，拥有什么，才能被爱。 等你们长大，你们因绿芽冒出土地而喜悦，会对出生的朝阳欢呼雀跃，也会给别人善意和温暖，但是却会在赞美别的生命的同时，常常，甚至永远忘了自己的珍贵。 愿你在被打击的时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵， 爱你所爱，行你所行，听从你心，无问西东 以及个人觉得好的台词： 不要放弃，对自己的思索，对自己的真实。 这些人站在那里，自信而笃定，那种从容让我十分羡慕。 今哀鸿遍野，饿殍满地，儿岂敢言累 你所能的到的名利光荣，祖上早就有了。妈妈只希望你过上自己想要的幸福生活，平安。 这个时代缺的不是完美的人，而是从心底给出的真心，正义，无畏与同情。 如果大家对于，善良，真诚，梦想，正义，这些老掉牙的词还抱有希望的话，这部片子应该也会符合你的口味。 以上仅代表个人观点，不接受批评反驳O(∩_∩)O！]]></content>
      <categories>
        <category>日常说</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>电影</tag>
        <tag>无问西东</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哪有什么真正的言论自由？]]></title>
    <url>%2Farticles%2Fsay_something_about_zhihu.html</url>
    <content type="text"><![CDATA[我是一个极少在社交平台发表言论的人 昨天在知乎上首次回答一个问题，就是关于Hexo加入评论系统的 知乎地址：有哪些不用登陆的Hexo评论系统？ 居然就被知乎封号了… 起因当时忘了截图了，我的回答大概就是 12345推荐Valine，附上我的博客以及官方文档我的博客链接官网文档链接 over.就是这么简单 然后就被告知，需要发短信恢复账号使用 知乎没有告诉我，到底违反了什么条例，也没有警告。莫名其妙就被停用了。 过程于是，只能发短信去恢复使用 发完短信以后，知乎还是恢复了我的账号使用，但是并没有告知我到底违反了哪一条规定。 于是自己去搜索，结果发现和我一样有相同遭遇，甚至比我更惨的人，不在少数。 吐槽其实我想说的是，既然我违反了条例，为什么你不能通知我，然后让我修改或者删除答案，而是直接停用账号呢？ 这就好比，我欠了电费，你不是把欠费通知单发给我，告知我欠费详情，然后给个期限让我缴费，而是直接把我的房子都收回去了。 我的收藏，我支持的live，这些难道就因为这一个回答，全都受影响了吗？ 知乎作为一个知识分享平台，尚且如此，那么其他平台，对于网友言论的掌控力度，是不是有过之而无不及呢。这样想想，真是有点细思极恐。 这可能也是，我宁愿在国外买主机，买域名，搭博客，都不愿在在国内备案的原因吧。 起码，还能有一个让自己说点真心话的地方。 最后附上一些链接，有兴趣的可以点进去看看： 知乎账号被停用，如何恢复？ 知乎账号为何被停用？ 被知乎封号是怎样一个体验？ 历史总是惊人的相似，希望我们能成为坐在马车上前进，而不是在车轱辘底下被碾得粉身碎骨的那个人。 END]]></content>
      <categories>
        <category>日常说</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为你的Hexo加上评论系统-Valine]]></title>
    <url>%2Farticles%2Fuse_valine_for_your_blog.html</url>
    <content type="text"><![CDATA[简洁，方便，好用的评论系统 Valine 附带折腾一上午的踩坑经验 Valine简介Hexo的评论系统有很多，常见的有以下几个 多说 网易云跟帖 畅言 来必力（LiveRe） Disqus Hypercomments valine 首先多说和网易云已经倒下了，其次畅言需要备案，Disqus，Hypercomments和LiveRe都是国外的，加载速度贼慢，甚至有被墙的可能，寻觅了很久之后，从Material主题换成next主题之后，终于找到了一个好用的评论系统，那就是 valine 我使用的是Next 5.1.3版本，本身就已经集成了valine，因此正常情况下是按照官方文档走就可以了，5分钟开启你的评论系统~ 开启Valine注册Leancloud我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号 Leancloud官网，点我注册 注册完以后需要创建一个应用，名字可以随便起，然后 *进入应用-&gt;设置-&gt;应用key * 获取你的appid 和 appkey 如图所示： 拿到你的appid和appkey之后，打开主题配置文件 搜索 valine，填入appid 和 appkey 我的配置： 123456789valine: enable: true appid: your app id appkey: your app key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o来啊，快活啊! guest_info: nick,mail,link pageSize: 10 最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去 刷新一下~ 是不是就能看到评论框了？ 结尾彩蛋如果能正常使用，那么恭喜大家。 如果大家遇到问题了，那么可以请继续往下看： 这是 5.1.3版本 的配置文件 1234567valine: enable: true appid: appkey: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o来啊，快活啊! 这是 6.0.1版本 的配置文件: 12345678910valine: enable: true app_id: app_key: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o 来呀！快活呀！~ avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 看到区别了吗，app_id 和 app_key 这两个字段名是不一样的，如果字段名不对，那么是不会去加载Valine.min.js文件，也就是评论系统根本不会生效。这个问题折腾了一上午，最后还是联系作者才解决。 因此，在这里我要给作者打call： 欢迎加入Valine交流群: 80972291 2018/08/12 更： 感谢热心网友，群号应该为：480972291 漫漫长夜~又水完了一篇博客。。 对了，免费版本不支持高并发，大家评论的时候请排好队，不然Leancloud要给我发邮件了~谢谢！ 2019/01/27 更新: 无意义评论我会删掉，例如1234，abcd，这种，哪怕输入 测试 , test, 6666 也可以啊 因为在后台看到这种留言会很烦。如果你们写文章，或者做分享，别人的反馈是毫无意义的，相信你们心里也会有点不爽吧，希望大家相互理解。Peace &amp; Love. 参考 Valine官方文档 Valine作者博客 hexo博客评论新神器——Valine/]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>valine</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弃暗投明-Hexo更换next主题]]></title>
    <url>%2Farticles%2Fchange_to_next_theme.html</url>
    <content type="text"><![CDATA[用了将近一个月的Material主题，终于决定换成next主题 这篇博客主要是美化和踩坑的总结 Let’s go… 界面美化修改文章底部“#” 标签 文件：/themes/next/layout/_macro/post.swig 搜索 1rel="tag"&gt;# 将 # 换成 1&lt; i class="fa fa-tag" &gt; &lt;/i&gt; 其中 1"fa fa-tag" 可以换成自己喜欢的图标 详情请戳：Font Awesome 在文末添加”本文结束” 在 \themes\next\layout\_macro 新建 passage-end-tag.swig 文件 添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #636363;font-size:14px;letter-spacing: 10px"&gt;本文结束啦&lt;i class="fa fa-bell"&gt;&lt;/i&gt;感谢您的阅读&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 文件： \themes\next\layout_macro\post.swig 找到post-body 并添加代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后在 主题配置文件 末尾添加： 123// 文本结束提示语passage_end_tag: enabled: true 标签和分类加年份 文件：~/blog/themes/next/layout/category.swig 找到 1&#123;% for post in page.posts %&#125; 加入： 1234567891011&#123;# Show year #&#125; &#123;% set year %&#125; &#123;% set post.year = date(post.date, 'YYYY') %&#125; &#123;% if post.year !== year %&#125; &#123;% set year = post.year %&#125; &lt;div class="collection-title"&gt; &lt;h2 class="archive-year motion-element" id="archive-year-&#123;&#123; year &#125;&#125;"&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;# endshow #&#125; 然后在文件末尾加上 1234567&#123;% block script_extra %&#125; &#123;% if theme.use_motion %&#125; &lt;script type="text/javascript" id="motion.page.archive"&gt; $('.archive-year').velocity('transition.slideLeftIn'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endblock %&#125; 在博客底部加入本站运行时间 文件：layout/footer.swig 找到 1&#123;% if theme.footer.theme.enable %&#125; 在 12&lt;/div&gt;&#123;% endif %&#125; 前加入： 12&lt;span&gt; &lt;i class="fa fa-bomb"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="showDays"&gt;&lt;/span&gt; 在文件最后加入： 12345678910111213141516171819202122232425&lt;script&gt; var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var birthDay = Date.UTC(2017,12,17,00,00,00); // 这里设置建站时间 setInterval(function() &#123; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = now - birthDay; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById('showDays').innerHTML="本站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒"; &#125;, 1000);&lt;/script&gt; 个性化设置自定义样式由于next主题本身就提供了自定义的文件，设置的属性会直接覆盖默认的，不想用的时候可以直接还原，不用担心出问题~ 推荐阅读： 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 hexo的next主题个性化配置教程 我是参考这两篇博客再进行调整的，当然也可以直接看我的配置文件： 文件： ~/blog/themes/next/source/css/_custom.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// Custom styles.// 页面留白更改.header-inner &#123; padding-top: 0px; padding-bottom: 0px;&#125;.posts-expand &#123; padding-top: 10px;&#125;.posts-expand .post-meta &#123; margin: 5px 0px 0px 0px;&#125;.post-button &#123; margin-top: 0px;&#125;// 菜单.menu &#123; text-align: center; margin-top: 0px; margin-bottom: 0px; padding: 5px; background-color: rgba(255, 255, 255, 0.75); box-shadow: 0px 10px 10px 0px rgba(0, 0, 0, 0.15);&#125;// 去除在页面文章之间的分割线.posts-expand .post-eof &#123; margin: 0px; background-color: rgba(255, 255, 255, 0);&#125;// 去除页面底部页码上面的横线.pagination &#123; border: none; margin: 0px;&#125;// 时间轴样式.posts-collapse &#123; margin: 50px 0px;&#125;@media (max-width: 1023px) &#123; .posts-collapse &#123; margin: 50px 20px; &#125;&#125;// 时间轴文章标题.posts-collapse .post-title a &#123; color: rgb(80, 115, 184);&#125;.posts-collapse .post-title a:hover &#123; color: rgb(161, 102, 171);&#125;// 时间轴文章标题底部虚线.posts-collapse .post-header:hover &#123; border-bottom-color: rgb(161, 102, 171);&#125;// 自定义ABOUT页面的样式.about-page &#123; margin: -80px 0px 60px 0px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255); padding: 106px 36px 36px 36px;&#125;@media (max-width: 767px) &#123; .about-page &#123; margin: -73px 0px 50px 0px; padding: 96px 15px 20px 15px; &#125;&#125;h2.about-title &#123; border-left: none !important; margin-left: 0px !important; padding-left: 0px !important; text-align: center; background-image: linear-gradient(90deg, #a166ab 0%, #a166ab 40%, #ef4e7b 45%, #f37055 50%, #ef4e7b 55%, #a166ab 60%, #a166ab 100%); background-size: cover; -webkit-background-clip: text; -webkit-text-fill-color: transparent; user-select: none;&#125;// 本地搜索框.local-search-popup .local-search-input-wrapper input &#123; padding: 9px 0px; height: 21px; background-color: rgb(255, 255, 255);&#125;.local-search-popup .popup-btn-close &#123; border-left: none;&#125;// 标签云页面超链接样式（为emoji特设）.tag-cloud a &#123; color: rgb(80, 115, 184); border-bottom: 1px solid rgb(80, 115, 184); text-decoration: none;&#125;.tag-cloud a:hover &#123; color: rgb(161, 102, 171); border-bottom: 1px solid rgb(161, 102, 171); text-decoration: none;&#125;// 选中文字部分的样式::selection &#123; background-color: rgb(38, 140, 242); color: rgb(255, 255, 255);&#125;*::-moz-selection &#123; background-color: rgb(38, 140, 242); color: rgb(255, 255, 255);&#125;// 文章``代码块的自定义样式code &#123; margin: 0px 4px;&#125;// 文章```代码块顶部样式.highlight figcaption &#123; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9;&#125;.highlight figcaption a &#123; color: rgb(80, 115, 184);&#125;// 文章```代码块diff样式pre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125; 自定义字体 除了样式的设置，还有字体的设置，这个是在主题配置文件中修改的： 12345678910111213141516171819202122232425262728293031font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) # 亲测这个可用，如果不可用，自己搜索 [Google 字体 国内镜像]，找个能用的就行 host: https://fonts.cat.net # Global font settings used on &lt;body&gt; element. # 全局字体，应用在 body 元素上 global: external: true family: Lato # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: Roboto Mono 自定义背景图片 文件：themes\next\source\css\ _custom\custom.styl 在最后加上： 1234567// 页面背景图body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; 希望背景变暗的可以加上这段： 1234// 页面背景色.container &#123; background-color: rgba(0, 0, 0, 0.75);&#125; 不满意的可以根据自己的需要再调整，接下来就是集成第三方服务了 第三方集成这部分主要讲一下数据统计 以及 坑爹的评论系统 数据统计可以参考官方文档：第三方服务集成 目前我开启了 google分析 以及 LeanCloud 关于google分析，可以看我之前写的博客：使用Hexo搭建个人博客(三) LeanCloud的集成也很简单 注册LeanCloud账号,创建应用，然后进入应用-&gt;设置-&gt;应用key 在主题配置文件加入appid和appkey: 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 你的appid app_key: 你的appkey 评论系统首先来看看next关于第三方评论系统的官方文档：http://theme-next.iissnan.com/third-party-services.html#comment-system 支持的有 Disqus Facebook Comments HyperComments 网易云跟帖 来必力 有需要的请参考文档自行食用。 之前用Material主题的时候我用的是来必力，但是无奈每次打开的速度都贼慢，已经到了无法忍受的地步了。 恩，又为自己换主题找了个借口，所以在next下惊喜的发现，虽然文档没写，但是配置文件里居然有 Valine 于是开始了长达一个上午的折腾~具体细节会重新开一篇文章记录，这里直接说设置步骤： 非常简单，在主题配置文件加入你的LeanCloud的appid以及appkey即可~ 123456789valine: enable: true appid: your app id appkey: your app key notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: ヾﾉ≧∀≦)o来啊，快活啊! guest_info: nick,mail,link pageSize: 10 没有开启邮箱提醒的请把 notify 和 verify 设为 false 刷新一下，就能看到评论框了。完结撒花。 更新：关于Valine评论请看：为你的Hexo加上评论系统-Valine 参考 - 排名不分先后 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 hexo的next主题个性化配置教程 为NexT主题添加文章阅读量统计功能 第三方服务集成]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客提速-Nginx开启gzip压缩]]></title>
    <url>%2Farticles%2Fopen_gzip_for_nginx.html</url>
    <content type="text"><![CDATA[本文说明这是对于个人博客优化的一个记录。今天打开博客，发现加载速度有点慢，于是在Google Analytics里面检查了打开速度，没想到谷歌还提供了优化的建议，其中有一项就是开启网页压缩~使用的就是Nginx的gzip压缩 Nginx服务器启用gzip压缩首先，打开nginx的配置文件，我的博客有单独的配置文件，打开命令如下： 1vi /etc/nginx/conf.d/blog.conf 然后在配置文件中加入这一段 gzip on; gzip_proxied any; gzip_min_length 1100; gzip_buffers 16 8k; gzip_types text/plain text/css application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;保存退出并重启nginx 1sudo /etc/init.d/nginx reload 接下来就可以看结果了： 通过这个网址：https://nixcp.com/tools/gzip-test/ 测试是否成功开启gzip 通过这个网址：http://www.whatsmyip.org/http-compression-test/ 看压缩效果 最后经过测试，我的网页压缩效果如下： 未开启之前是47K，开启以后只有12K，压缩了74%，效果杠杠的。 总结​ 开启gzip，不仅可以提高网页加载速度，减少服务器的负载，还能提高网站排名，还没为自己的网站开启gzip压缩的童鞋，赶快去试试吧~]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>Nginx</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客(三)]]></title>
    <url>%2Farticles%2Fues_Hexo_build_blog_three.html</url>
    <content type="text"><![CDATA[本文说明2018年的第一篇博客，首先祝大家新年快乐，学习进步，工作顺利！ 这是使用Hexo搭建个人博客系列的最后一篇文章，主要介绍Material主题的配置。 Material主题配置文档：Click Me 不了解Material主题的可以看这里：Github地址 前文：使用Hexo搭建个人博客(一)使用Hexo搭建个人博客(二) 主题配置 主题配置文件在：/你的博客目录/themes/material/_config.ymlclone下来的时候把名字改成_config.yml即可 基本配置 – Head infohead favicon: “/img/favicon.png” 网站的图标 high_res_favicon: “/img/favicon.png” 高清版图标 apple_touch_icon: “/img/favicon.png” IOS主屏图标 keywords: Blue’s Blog, Android, Python 网站关键词 site_verification: google: 谷歌 Search Console 验证baidu: 百度站长平台验证 样式设定 – Style Settingsscheme – Material主题样式一般使用Paradox uiux – 设置主题UI slogan: - 首页的标语 theme_color: “主题主要颜色” theme_sub_color: “主题次要颜色” #00838F hyperlink_color: “超链颜色” button_color: “按钮颜色” android_chrome_color: “Chrome浏览器颜色” nprogress_color: “顶部进度条颜色” nprogress_buffer: “800” – 加载缓存时间 reading – 设置阅读体验 entry_excerpt: 首页文章输出摘要的字符长度。 thumbnail – 设置缩略图 purecolor: 填入颜色代码。如果文章内无设置缩略图，此项又不为空，则使用纯色缩略图。 random_amount: 随机图片数量，根据 主题所在文件夹/source/img/random 中的图片数量设置。Material 主题默认提供了 19 张 Material 风格的缩略图。 background – 设置背景图purecolor: &quot;#F4F4F4&quot; --纯色背景 # bgimg: &quot;/img/bg.jpg&quot; --图片背景 bing: -- bing随机背景 enable: false parameter: color=: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow. type=: A (动物), C (人文), N (自然), S (太空), T (旅行).img – 设置站点图片 logo: 显示于 blog_info 模块中。 avatar: 你的头像设置。 daily_pic: 显示于 daily_pic 模块中。 sidebar_header: 显示于 sidebar 顶部。 footerico: 设置 footer 中 SNS 图标的路径。 random_thumbnail: 随机缩略图的路径。 footer_image: 你可以在侧边栏底部放置任何你想要的图片。 自定义设定copyright_since – 设置站点成立时间 copyright_since: 2017 就会显示2017-2018 footer_text – 设置底部文字例如：footer_text: &apos;&lt;a href=&quot;http://www.miitbeian.gov.cn&quot; rel=&quot;nofollow&quot;&gt;某ICP备xxxxxxxx号-x&lt;/a&gt;&apos;Code – 设置代码高亮Material内置两个选项 perttify 和 hanabi，个人比较喜欢perttify，因为hanabi太花哨了，附上配置文件 12345678prettify: enable: true theme: "atelier-estuary-light" # atelier-estuary-light tomorrow-night-eighties这三个配色我都挺喜欢的，供参考：atelier-estuary-light atelier-estuary-light tomorrow-night-eighties Post License – 版权说明老规矩，直接附上配置： 12345'本文作者：&lt;a href="https://bluelzy.com" target="_blank"&gt;BlueLzy&lt;/a&gt;&lt;br&gt;本文采用 &lt;a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank"&gt;CC BY-NC-SA 3.0 Unported License&lt;/a&gt; 协议进行许可, 阅读&lt;a href="https://bluelzy.com/creativecommons.html" target="_blank"&gt;相关说明&lt;/a&gt;' 菜单设定sns – 设置sns信息 用于填写你的 SNS 信息，其中 email 会显示在侧边栏，其他信息会以按钮的形式显示在 footer。 email twitter facebook googleplus weibo instagram tumblr github linkedin facebook sns_share – 定义分享菜单中的项目 这部分会出现在文章分享按钮菜单上 twitter googleplus weibo linkedin qq telegram sidebar – 设置边栏菜单这一块应该大家都能看懂，直接附上配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344dropdown: Email Me: link: "mailto: bluehobert@gmail.com" icon: email Github: link: "https://github.com/bluezzyy" icon: layers homepage: use: true icon: home divider: false archives: use: true icon: inbox divider: false categories: use: true icon: chrome_reader_mode divider: true pages: 标签云: link: "/tags" icon: label divider: false 时间轴: link: "/timeline" icon: cloud divider: false 关于我: link: "/about.html" icon: person divider: true article_num: use: true divider: false footer: divider: false theme: false support: false feedback: false material: false 第三方服务 其实Material内置的第三方服务已经基本足够使用了，RSS，评论系统，搜索系统，数据统计与分析等等 这部分可以按照自己实际情况，以及配合官方文档服用，效果更佳，在这里我只介绍自己博客用到的配置，包括：​ 评论系统：来比力 搜索系统：本地搜索 数据统计：谷歌统计 评论系统首先注册来必力来必力官网 然后登陆，安装city版本并获取uid：安装地址 最后修改站点的配置文件 1234567comment: use: livere shortname: # duoshuo or disqus shortname changyan_appid: changyan_conf: changyan_thread_key_type: path livere_data_uid: # 来必力的uid 再刷新一下博客，就可以看到评论系统啦~ 搜索系统123search: use: local swiftype_key: 即可通过关键字搜索本站 数据统计(Google Analytics)我们只需要获取到跟踪ID即可 可以参考Google Analytics（分析）帮助 或者按照以下步骤操作，登陆google analytics 找到管理 -&gt; 媒体资源 -&gt; 跟踪信息 -&gt; 跟踪代码 获取到跟踪ID后，修改配置文件 找到主题配置文件中的analytics字段： 在google_site_id 字段加上你的跟踪ID，保存即可 总结Material基本的配置介绍这么多，关于进阶配置，大家可以去看官方文档，或者自己再慢慢摸索，接下来我还会写一些关于博客优化的文章。 参考 Material主题配置文档 Material主题 Github地址]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>主题</tag>
        <tag>material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客(二)]]></title>
    <url>%2Farticles%2Fues_Hexo_build_blog_two.html</url>
    <content type="text"><![CDATA[本文说明：本文是使用Hexo搭建个人博客系列的第二篇，主要包括 本地安装hexo 服务器配置 把个人博客部署到服务器 关于购买VPS和注册域名，解析域名到IP请看：Hexo搭建个人博客(一) 接下来让我们一步步把博客给搭建起来，跟着这篇博客做，最终就可以把博客部署到服务器上，并且运行起来~ 本地环境配置安装依赖环境安装Hexo需要先安装node.js和git 下载Node.js : Node.js下载地址 下载Git: Git下载地址 安装Hexo只需要一行命令： $ npm install hexo-cli -g例如我的博客目录是 /MyBlog通过命令 cd /MyBlog切换到博客目录 然后在博客目录下初始化hexo博客，blog为博客名，可随意更改 hexo init blog 进入博客目录并安装插件依赖 cd blog npm install最后执行命令 hexo g hexo s 顺利的话，应该能看到终端打印出地址：http://localhost:4000/ 点击地址打开浏览器，应该能看到Hexo默认主题的界面了~当然，我的主题已经换了，所以打开是这样的： 安装部署依赖环境部署Hexo使用 hexo deploy命令即可，但是在这之前，需要先安装依赖环境server和deploy-git 在终端输入： $ npm install hexo-server --save # $ npm install hexo-deployer-git --save至此，本地环境就搭建好了，除了这个，我们还需要搭建服务器的环境，所以接下来就是服务器的配置。 服务器配置安装Git和NodeJS只需要两行命令 $ yum install git # 安装git curl --silent --location https://rpm.nodesource.com/setup_5.x | bash - # 安装NodeJS创建Git用户 为了能让Hexo直接部署到VPS上，需要在服务器新建用户git 步骤： 1234adduser git # 添加git用户sudo passwd git # 给git用户设置密码 chmod 740 /etc/sudoers vim /etc/sudoers 然后找到这一行 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 并添加 1git ALL=(ALL) ALL 接下来我们需要把电脑的公钥配置到服务器，这样才能向服务器提交代码 123456su gitmkdir ~/.sshvim ~/.ssh/authorized_keys#然后在本地执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到authorized_keyschmod 600 ~/.ssh/authorzied_keyschmod 700 ~/.ssh OK，到这里，我们就把服务器git用户给配置完了，可以通过命令 1ssh -v git@SERVER # SERVER是你的服务器地址 来测试一下，是不是可以免密码登陆到服务器，如果可以，那就说明没问题了。 安装和配置Nginx安装Nginx由于我的vps上运行的是CentOS 6 的系统，直接安装Nginx会报错，解决方法请参考这篇博客：CentOS 6 安装Nginx CentOS 7 可以直接执行命令： $ sudo yum install epel-release $ sudo yum install nginx 然后再启动Nginx： sudo systemctl start nginxCentOS 6 启动Nginx的命令应该是：​ /etc/init.d/nginx start 这个时候在浏览器输入服务器ip地址或者域名，就能看到Nginx欢迎页。 配置Nginx 在 /etc/nginx/conf.d/ 创建虚拟主机配置文件 blog.conf 加入以下内容： server_name: 改成你的服务器名字，或者域名 root: 改成你的博客根目录 1234567891011server&#123; listen 80; #listen [::]:80; server_name bluelzy.com www.bluelzy.com; index index.html index.htm index.php default.html default.htm default.php; #这里要改成网站的根目录 root /var/www/hexo; include other.conf;&#125; 然后再重启一下Nginx，即可 service nginx restart创建Git仓库既然本地环境配好了，服务器所需要的环境也配好了，那么现在就需要在服务器建一个仓库，用来管理博客的代码，这一块比较重要，关乎到能不能成功部署博客。 其实就是两步： 创建仓库 设置git hook 创建仓库执行以下命令： 123$ cd ~ $ mkdir blog.git &amp;&amp; cd blog.git$ git init --bare 解释一下这一行： git init --bare意思是初始化一个裸仓库，创建一个裸仓库，并且这个仓库是可以被正常 clone 和 push 更新的， 裸仓库不包含工作区，所以并不会存在在裸仓库上直接提交变更的情况。 设置git hook我们使用 post-receive这个钩子.在 ~/blog.git 裸库的 hooks文件夹中，新建post-receive文件。 vim ~/blog.git/hooks/post-receive在文件中加入： 12#!/bin/shgit --work-tree=/var/www/hexo --git-dir=~/blog.git checkout -f 注意： –work-tree=/var/www/hexo 要改成你的博客根目录，也就是上面Nginx配置文件中的root 保存退出(wq) 然后再赋予这个文件运行的权限 chmod +x post-receive​ OK,到这一步，服务器的配置也已经全部完成了。 恭喜你，如果能按着博客一步步看到这里，并且一切正常，那么你离成功搭建一个博客，还差最后一步…. 本地配置_config.yml打开Hexo站点目录下的_config.yml文件，找到 deploy关键字 12345deploy: type: git repo: git@SERVER:/home/git/blog.git // 仓库地址 branch: master message: 提交的信息 把SERVER改成你的服务器地址，然后保存文件，大功告成！ 测试我们使用 123hexo cleanhexo ghexo d 把Hexo从本地部署到服务器上，执行完之后，在浏览器访问你的服务器地址，应该就能看到博客首页了。 以后写好文章，再执行上面这三句命令，就可以实现自动化部署了，真是人生一大乐事(捂嘴) 总结&amp;期望这篇文章从本地环境到服务器环境，再到自动化部署都作了一个详细的说明，从无到有搭建起了一个个人博客。接下来我会结合自己的博客，介绍一下 主题选择 主题配置 第三方服务 参考 从 0 开始搭建 hexo 博客 阿里云VPS搭建自己的的Hexo博客 开始新的折腾，Hexo博客Git-VPS部署完整记录]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>vps</tag>
        <tag>godaddy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim简单入门]]></title>
    <url>%2Farticles%2Fvim_guide.html</url>
    <content type="text"><![CDATA[命令模式刚进入vim 都是该模式想要插入字符：请按键盘上的i 切换到插入模式键盘上的 “:” 切换到底线命令模式，在最底一行输入命令。 插入模式想要退出到命令模式请点击键盘上的esc 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 q 不保存,直接退出 q! 不保存，并强制退出 e! 放弃所有修改，从上次保存文件开始再编辑 w 保存文件,但不退出 w! 强制保存，不退出 wq或x 保存，并退出 wq! 强制保存，并退出 一般操作步骤 vim file_name 打开文件 此时是命令模式 按i 进入插入模式，进行自己需要的修改 按esc 返回到命令模式，按 : 进入底线命令模式 输入wq 保存并退出]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6 安装Nginx]]></title>
    <url>%2Farticles%2Finstall_nginx_for_centos6.html</url>
    <content type="text"><![CDATA[问题： 直接yum install nginx -y 会报package not found 的错 解决： 在/etc/yum.repos.d/目录下创建一个源配置文件nginx.repo： 123cd /etc/yum.repos.d/ vim nginx.repo 填写如下内容： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 保存，则会产生一个/etc/yum.repos.d/nginx.repo文件。 我们现在再来执行Nginx安装命令： yum install nginx -y现在应该就可以顺利安装了 安装完成，下面直接就可以启动Nginx了： /etc/init.d/nginx start访问服务器，如无意外，应该就能看到Nginx欢迎页面了。 搞定收工~ 备注：如果对vim不熟悉的可以百度或者google一下也可以看我写的这篇：Vim简单入门]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>CentOS 6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客(一)]]></title>
    <url>%2Farticles%2Fues_Hexo_build_blog_one.html</url>
    <content type="text"><![CDATA[本文说明：本文是使用Hexo搭建个人博客系列的第一篇，主要是介绍一些准备工作，也是作为搭建本人博客的过程回顾，主要包括 购买VPS 注册域名 解析域名 注意：如果不希望自己花费太多RMB的话，也可以选择部署到github pages上，可以参考手把手教你使用Hexo + Github Pages搭建个人独立博客 原理其实都是类似的，本博客的搭建使用VPS + Hexo OK，接下来就一步步来准备这些所需的搭建环境。 购买VPS去哪里买我是在搬瓦工上购买的,最便宜的9.9和19.9美元/年的方案已经卖完了，所以我选择的是29.9$/年的，折算下来大概是185RMB，毕竟有自己的服务器，搭建博客只是其中一个小用途而已，还能用他做很多别的事情，所以我觉得还是很划算的。最重要的是 他支持支付宝啊~ 附上链接：搬瓦工VPS官网 路线选择推荐选择KVM + CN2 ping值稳定在150ms左右，速度还是可以接受的 购买步骤进入搬瓦工的官网，选择VPS Hosting 看到下面有不同配置和价格的主机，选择适合自己的，然后点击 order kvm 确认订单，然后点击add to cart 加入购物车 确认无误后，点击checkout 填写个人信息，这里邮箱要写真实的，其他可以随便写付款方式选择alipay 也就是支付宝，然后扫码完成付款即可 其他推荐 VultrVultr官网地址支持Paypal、信用卡或比特币付款。需要充值验证后才能开通VPS. LinodeLinode官网地址老牌VPS提供商，价格也会比较贵，配置高，服务好. 注册域名关于购买域名，我是在大名鼎鼎的狗爹(godaddy)上买的，没有选择国内的万网，因为自己的网站也不打算备案。接下来简单的写一下购买步骤 附上官网地址：狗爹官网 狗爹已经完全支持中文了，而且最重要的是，他也支持支付宝，按照步骤操作，应该是没太大问题的~ 解析域名OK，现在我们有了服务器，也有了域名，需要做的就是把域名和服务器绑定起来，我使用的是Dnspod 官方教程：DNSPOD域名解析 修改Godaddy的DNS解析: godaddy修改DNS 总结一下，首先在Dnspod上注册账号，填入需要解析的域名和ip，然后会生成dns服务器，最后把godaddy的dns服务改成刚刚生成的那两个dnf服务器地址即可，输入域名应该就能访问到你的网站啦~ 上面的两个教程都说的很清楚了，还有困惑的欢迎留言~* 总结 这篇文章主要是搭建博客的前期准备，下一篇文章我们就正式开始使用hexo搭建博客了，主要介绍 本地安装hexo 服务器配置nginx 把个人博客部署到服务器 参考 Blog绑定域名——Godaddy + DNSPod]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>vps</tag>
        <tag>godaddy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shuttle安装以及配置简介]]></title>
    <url>%2Farticles%2Fshuttle_brief_introduction.html</url>
    <content type="text"><![CDATA[本文说明：本文介绍Shuttle的安装以及配置，主要是根据Github上的官方文档进行翻译说明，还有自己的一些补充，如果习惯直接看文档的朋友，可以直接关掉这篇文章了~ Shuttle是什么点击我跳转到Shuttle的Github 看一下官方简介，就一句话 1A simple SSH shortcut menu for macOS 顾名思义，就是一个Mac上管理SSH的工具 Shuttle怎么用接下来，让我给大家介绍一下Shuttle的用法 安装Shuttle首先到Shuttle的官网下载：点击我跳转到下载地址然后把Shuttle复制到Application文件夹下即可 Shuttle配置这部分是本文的重点，敲黑板通过命令 open ~/.shuttle.json 打开.shuttle.json文件 Global settings 全局配置 “editor”: “VALUE”, 设置编辑器，可选项default, nano, vi, vim “launch_at_login”: VALUE, 设置是否开机启动 “terminal”: “VALUE”, 设置终端，一般是Terminal.app或者iTerm “iTerm_version”: “VALUE”, 设置iTerm版本，分别有三种 “iTerm_version”: “legacy”, 2.14版本 &quot;iTerm\_version&quot;: &quot;stable&quot;, 最新版本 &quot;iTerm\_version&quot;: &quot;nightly&quot;, nightly build 版本 “default_theme”: “Homebrew” 设置终端主题 open_in”: “VALUE” 有两个可选项 Tab 或者 new 顾名思义，新建一个Tab 或者 在新窗口执行命令 “show_ssh_config_hosts”: VALUE 设置是否解析config文件，默认是true “ssh_config_ignore_keywords”: [“VALUE”] 设置忽略解析的关键字 Command settings 命令配置 “cmd”: “VALUE” 设置命令例如 “cmd”: “ps aux | grep [s]sh” “name”: “VALUE” 设置菜单栏显示的名称 “inTerminal”: “VALUE” new 新建一个窗口执行命令 tab 新建一个Tab执行命令 current 在当前窗口执行命令 “theme”: “VALUE” 设置主题~我用的是basic “title”: “VALUE” 这个标题是显示在终端窗口的标题~ Shuttle示例12345678910111213141516"hosts": [ &#123; "cmd": "ssh root@127.0.0.1 -p 4000", "inTerminal": "tab", "name": "SSH - root用户", "theme": "basic", "title": "Blue" &#125;, &#123; "cmd": "ssh root@127.0.0.1 -p 4000", "inTerminal": "tab", "name": "SSH - git用户", "theme": "basic", "title": "Blue" &#125; ] 总结shuttle 除了可以用来当SSH管理工具以外，还能执行多条命令操作，提高效率，只要用分号分隔即可 例如 pwd; ls; cd /; 就会按顺序执行以上三条命令。 好了，本文只是简单介绍了shuttle的基本用法，欢迎大家一起交流学习~ ​]]></content>
      <categories>
        <category>休闲类</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>shuttle</tag>
        <tag>linux</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Farticles%2Ffirst_article.html</url>
    <content type="text"><![CDATA[emmm….接下来打算写写搭建这个博客的过程。毕竟捣鼓了整整一个周末这个博客不仅仅会写技术，也会记录日常生活~ 反正就是一个想到什么写什么的地方 我是Blue 嘻嘻]]></content>
      <categories>
        <category>日常说</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
